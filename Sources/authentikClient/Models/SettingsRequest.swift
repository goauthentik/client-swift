//
// SettingsRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Settings Serializer */
public struct SettingsRequest: Sendable, Codable, ParameterConvertible, Hashable {

    public static let avatarsRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let eventRetentionRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let reputationLowerLimitRule = NumericRule<Int>(minimum: -2147483648, exclusiveMinimum: false, maximum: 0, exclusiveMaximum: false, multipleOf: nil)
    public static let reputationUpperLimitRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    public static let defaultTokenDurationRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let defaultTokenLengthRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    /** Configure how authentik should show avatars for users. */
    public var avatars: String?
    /** Enable the ability for users to change their name. */
    public var defaultUserChangeName: Bool?
    /** Enable the ability for users to change their email address. */
    public var defaultUserChangeEmail: Bool?
    /** Enable the ability for users to change their username. */
    public var defaultUserChangeUsername: Bool?
    /** Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2). */
    public var eventRetention: String?
    /** Reputation cannot decrease lower than this value. Zero or negative. */
    public var reputationLowerLimit: Int?
    /** Reputation cannot increase higher than this value. Zero or positive. */
    public var reputationUpperLimit: Int?
    public var footerLinks: JSONValue?
    /** When enabled, all the events caused by a user will be deleted upon the user's deletion. */
    public var gdprCompliance: Bool?
    /** Globally enable/disable impersonation. */
    public var impersonation: Bool?
    /** Require administrators to provide a reason for impersonating a user. */
    public var impersonationRequireReason: Bool?
    /** Default token duration */
    public var defaultTokenDuration: String?
    /** Default token length */
    public var defaultTokenLength: Int?
    public var flags: PatchedSettingsRequestFlags

    public init(avatars: String? = nil, defaultUserChangeName: Bool? = nil, defaultUserChangeEmail: Bool? = nil, defaultUserChangeUsername: Bool? = nil, eventRetention: String? = nil, reputationLowerLimit: Int? = nil, reputationUpperLimit: Int? = nil, footerLinks: JSONValue? = nil, gdprCompliance: Bool? = nil, impersonation: Bool? = nil, impersonationRequireReason: Bool? = nil, defaultTokenDuration: String? = nil, defaultTokenLength: Int? = nil, flags: PatchedSettingsRequestFlags) {
        self.avatars = avatars
        self.defaultUserChangeName = defaultUserChangeName
        self.defaultUserChangeEmail = defaultUserChangeEmail
        self.defaultUserChangeUsername = defaultUserChangeUsername
        self.eventRetention = eventRetention
        self.reputationLowerLimit = reputationLowerLimit
        self.reputationUpperLimit = reputationUpperLimit
        self.footerLinks = footerLinks
        self.gdprCompliance = gdprCompliance
        self.impersonation = impersonation
        self.impersonationRequireReason = impersonationRequireReason
        self.defaultTokenDuration = defaultTokenDuration
        self.defaultTokenLength = defaultTokenLength
        self.flags = flags
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case avatars
        case defaultUserChangeName = "default_user_change_name"
        case defaultUserChangeEmail = "default_user_change_email"
        case defaultUserChangeUsername = "default_user_change_username"
        case eventRetention = "event_retention"
        case reputationLowerLimit = "reputation_lower_limit"
        case reputationUpperLimit = "reputation_upper_limit"
        case footerLinks = "footer_links"
        case gdprCompliance = "gdpr_compliance"
        case impersonation
        case impersonationRequireReason = "impersonation_require_reason"
        case defaultTokenDuration = "default_token_duration"
        case defaultTokenLength = "default_token_length"
        case flags
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(avatars, forKey: .avatars)
        try container.encodeIfPresent(defaultUserChangeName, forKey: .defaultUserChangeName)
        try container.encodeIfPresent(defaultUserChangeEmail, forKey: .defaultUserChangeEmail)
        try container.encodeIfPresent(defaultUserChangeUsername, forKey: .defaultUserChangeUsername)
        try container.encodeIfPresent(eventRetention, forKey: .eventRetention)
        try container.encodeIfPresent(reputationLowerLimit, forKey: .reputationLowerLimit)
        try container.encodeIfPresent(reputationUpperLimit, forKey: .reputationUpperLimit)
        try container.encodeIfPresent(footerLinks, forKey: .footerLinks)
        try container.encodeIfPresent(gdprCompliance, forKey: .gdprCompliance)
        try container.encodeIfPresent(impersonation, forKey: .impersonation)
        try container.encodeIfPresent(impersonationRequireReason, forKey: .impersonationRequireReason)
        try container.encodeIfPresent(defaultTokenDuration, forKey: .defaultTokenDuration)
        try container.encodeIfPresent(defaultTokenLength, forKey: .defaultTokenLength)
        try container.encode(flags, forKey: .flags)
    }
}

