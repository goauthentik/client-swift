//
// KerberosSource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Kerberos Source Serializer */
public struct KerberosSource: Sendable, Codable, ParameterConvertible, Hashable {

    public static let slugRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^[-a-zA-Z0-9_]+$/")
    public var pk: UUID
    /** Source's display Name. */
    public var name: String
    /** Internal source name, used in URLs. */
    public var slug: String
    public var enabled: Bool?
    /** When enabled, this source will be displayed as a prominent button on the login page, instead of a small icon. */
    public var promoted: Bool?
    /** Flow to use when authenticating existing users. */
    public var authenticationFlow: UUID?
    /** Flow to use when enrolling new users. */
    public var enrollmentFlow: UUID?
    public var userPropertyMappings: [UUID]?
    public var groupPropertyMappings: [UUID]?
    /** Get object component so that we know how to edit the object */
    public var component: String
    /** Return object's verbose_name */
    public var verboseName: String
    /** Return object's plural verbose_name */
    public var verboseNamePlural: String
    /** Return internal model name */
    public var metaModelName: String
    public var policyEngineMode: PolicyEngineMode?
    /** How the source determines if an existing user should be authenticated or a new user enrolled. */
    public var userMatchingMode: UserMatchingModeEnum?
    /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
    public var managed: String?
    public var userPathTemplate: String?
    public var icon: String?
    public var iconUrl: String
    /** How the source determines if an existing group should be used or a new group created. */
    public var groupMatchingMode: GroupMatchingModeEnum?
    /** Kerberos realm */
    public var realm: String
    /** Custom krb5.conf to use. Uses the system one by default */
    public var krb5Conf: String?
    /** KAdmin server type */
    public var kadminType: KadminTypeEnum?
    /** Sync users from Kerberos into authentik */
    public var syncUsers: Bool?
    /** When a user changes their password, sync it back to Kerberos */
    public var syncUsersPassword: Bool?
    /** Principal to authenticate to kadmin for sync. */
    public var syncPrincipal: String?
    /** Credentials cache to authenticate to kadmin for sync. Must be in the form TYPE:residual */
    public var syncCcache: String?
    /** Get cached source connectivity */
    public var connectivity: [String: String]?
    /** Force the use of a specific server name for SPNEGO. Must be in the form HTTP@hostname */
    public var spnegoServerName: String?
    /** Credential cache to use for SPNEGO in form type:residual */
    public var spnegoCcache: String?
    /** If enabled, the authentik-stored password will be updated upon login with the Kerberos password backend */
    public var passwordLoginUpdateInternalPassword: Bool?
    /** When to trigger sync for outgoing providers */
    public var syncOutgoingTriggerMode: SyncOutgoingTriggerModeEnum?

    public init(pk: UUID, name: String, slug: String, enabled: Bool? = nil, promoted: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, userPropertyMappings: [UUID]? = nil, groupPropertyMappings: [UUID]? = nil, component: String, verboseName: String, verboseNamePlural: String, metaModelName: String, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, managed: String?, userPathTemplate: String? = nil, icon: String? = nil, iconUrl: String, groupMatchingMode: GroupMatchingModeEnum? = nil, realm: String, krb5Conf: String? = nil, kadminType: KadminTypeEnum? = nil, syncUsers: Bool? = nil, syncUsersPassword: Bool? = nil, syncPrincipal: String? = nil, syncCcache: String? = nil, connectivity: [String: String]?, spnegoServerName: String? = nil, spnegoCcache: String? = nil, passwordLoginUpdateInternalPassword: Bool? = nil, syncOutgoingTriggerMode: SyncOutgoingTriggerModeEnum? = nil) {
        self.pk = pk
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.promoted = promoted
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.userPropertyMappings = userPropertyMappings
        self.groupPropertyMappings = groupPropertyMappings
        self.component = component
        self.verboseName = verboseName
        self.verboseNamePlural = verboseNamePlural
        self.metaModelName = metaModelName
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.managed = managed
        self.userPathTemplate = userPathTemplate
        self.icon = icon
        self.iconUrl = iconUrl
        self.groupMatchingMode = groupMatchingMode
        self.realm = realm
        self.krb5Conf = krb5Conf
        self.kadminType = kadminType
        self.syncUsers = syncUsers
        self.syncUsersPassword = syncUsersPassword
        self.syncPrincipal = syncPrincipal
        self.syncCcache = syncCcache
        self.connectivity = connectivity
        self.spnegoServerName = spnegoServerName
        self.spnegoCcache = spnegoCcache
        self.passwordLoginUpdateInternalPassword = passwordLoginUpdateInternalPassword
        self.syncOutgoingTriggerMode = syncOutgoingTriggerMode
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case slug
        case enabled
        case promoted
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case userPropertyMappings = "user_property_mappings"
        case groupPropertyMappings = "group_property_mappings"
        case component
        case verboseName = "verbose_name"
        case verboseNamePlural = "verbose_name_plural"
        case metaModelName = "meta_model_name"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case managed
        case userPathTemplate = "user_path_template"
        case icon
        case iconUrl = "icon_url"
        case groupMatchingMode = "group_matching_mode"
        case realm
        case krb5Conf = "krb5_conf"
        case kadminType = "kadmin_type"
        case syncUsers = "sync_users"
        case syncUsersPassword = "sync_users_password"
        case syncPrincipal = "sync_principal"
        case syncCcache = "sync_ccache"
        case connectivity
        case spnegoServerName = "spnego_server_name"
        case spnegoCcache = "spnego_ccache"
        case passwordLoginUpdateInternalPassword = "password_login_update_internal_password"
        case syncOutgoingTriggerMode = "sync_outgoing_trigger_mode"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(promoted, forKey: .promoted)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encodeIfPresent(userPropertyMappings, forKey: .userPropertyMappings)
        try container.encodeIfPresent(groupPropertyMappings, forKey: .groupPropertyMappings)
        try container.encode(component, forKey: .component)
        try container.encode(verboseName, forKey: .verboseName)
        try container.encode(verboseNamePlural, forKey: .verboseNamePlural)
        try container.encode(metaModelName, forKey: .metaModelName)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encode(managed, forKey: .managed)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encodeIfPresent(icon, forKey: .icon)
        try container.encode(iconUrl, forKey: .iconUrl)
        try container.encodeIfPresent(groupMatchingMode, forKey: .groupMatchingMode)
        try container.encode(realm, forKey: .realm)
        try container.encodeIfPresent(krb5Conf, forKey: .krb5Conf)
        try container.encodeIfPresent(kadminType, forKey: .kadminType)
        try container.encodeIfPresent(syncUsers, forKey: .syncUsers)
        try container.encodeIfPresent(syncUsersPassword, forKey: .syncUsersPassword)
        try container.encodeIfPresent(syncPrincipal, forKey: .syncPrincipal)
        try container.encodeIfPresent(syncCcache, forKey: .syncCcache)
        try container.encode(connectivity, forKey: .connectivity)
        try container.encodeIfPresent(spnegoServerName, forKey: .spnegoServerName)
        try container.encodeIfPresent(spnegoCcache, forKey: .spnegoCcache)
        try container.encodeIfPresent(passwordLoginUpdateInternalPassword, forKey: .passwordLoginUpdateInternalPassword)
        try container.encodeIfPresent(syncOutgoingTriggerMode, forKey: .syncOutgoingTriggerMode)
    }
}

