//
// KerberosSourceRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Kerberos Source Serializer */
public struct KerberosSourceRequest: Sendable, Codable, ParameterConvertible, Hashable {

    public static let nameRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let slugRule = StringRule(minLength: 1, maxLength: 50, pattern: "/^[-a-zA-Z0-9_]+$/")
    public static let userPathTemplateRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let realmRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    /** Source's display Name. */
    public var name: String
    /** Internal source name, used in URLs. */
    public var slug: String
    public var enabled: Bool?
    /** Flow to use when authenticating existing users. */
    public var authenticationFlow: UUID?
    /** Flow to use when enrolling new users. */
    public var enrollmentFlow: UUID?
    public var userPropertyMappings: [UUID]?
    public var groupPropertyMappings: [UUID]?
    public var policyEngineMode: PolicyEngineMode?
    /** How the source determines if an existing user should be authenticated or a new user enrolled. */
    public var userMatchingMode: UserMatchingModeEnum?
    public var userPathTemplate: String?
    /** How the source determines if an existing group should be used or a new group created. */
    public var groupMatchingMode: GroupMatchingModeEnum?
    /** Kerberos realm */
    public var realm: String
    /** Custom krb5.conf to use. Uses the system one by default */
    public var krb5Conf: String?
    /** KAdmin server type */
    public var kadminType: KadminTypeEnum?
    /** Sync users from Kerberos into authentik */
    public var syncUsers: Bool?
    /** When a user changes their password, sync it back to Kerberos */
    public var syncUsersPassword: Bool?
    /** Principal to authenticate to kadmin for sync. */
    public var syncPrincipal: String?
    /** Password to authenticate to kadmin for sync */
    public var syncPassword: String?
    /** Keytab to authenticate to kadmin for sync. Must be base64-encoded or in the form TYPE:residual */
    public var syncKeytab: String?
    /** Credentials cache to authenticate to kadmin for sync. Must be in the form TYPE:residual */
    public var syncCcache: String?
    /** Force the use of a specific server name for SPNEGO. Must be in the form HTTP@hostname */
    public var spnegoServerName: String?
    /** SPNEGO keytab base64-encoded or path to keytab in the form FILE:path */
    public var spnegoKeytab: String?
    /** Credential cache to use for SPNEGO in form type:residual */
    public var spnegoCcache: String?
    /** If enabled, the authentik-stored password will be updated upon login with the Kerberos password backend */
    public var passwordLoginUpdateInternalPassword: Bool?

    public init(name: String, slug: String, enabled: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, userPropertyMappings: [UUID]? = nil, groupPropertyMappings: [UUID]? = nil, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, userPathTemplate: String? = nil, groupMatchingMode: GroupMatchingModeEnum? = nil, realm: String, krb5Conf: String? = nil, kadminType: KadminTypeEnum? = nil, syncUsers: Bool? = nil, syncUsersPassword: Bool? = nil, syncPrincipal: String? = nil, syncPassword: String? = nil, syncKeytab: String? = nil, syncCcache: String? = nil, spnegoServerName: String? = nil, spnegoKeytab: String? = nil, spnegoCcache: String? = nil, passwordLoginUpdateInternalPassword: Bool? = nil) {
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.userPropertyMappings = userPropertyMappings
        self.groupPropertyMappings = groupPropertyMappings
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.userPathTemplate = userPathTemplate
        self.groupMatchingMode = groupMatchingMode
        self.realm = realm
        self.krb5Conf = krb5Conf
        self.kadminType = kadminType
        self.syncUsers = syncUsers
        self.syncUsersPassword = syncUsersPassword
        self.syncPrincipal = syncPrincipal
        self.syncPassword = syncPassword
        self.syncKeytab = syncKeytab
        self.syncCcache = syncCcache
        self.spnegoServerName = spnegoServerName
        self.spnegoKeytab = spnegoKeytab
        self.spnegoCcache = spnegoCcache
        self.passwordLoginUpdateInternalPassword = passwordLoginUpdateInternalPassword
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case slug
        case enabled
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case userPropertyMappings = "user_property_mappings"
        case groupPropertyMappings = "group_property_mappings"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case userPathTemplate = "user_path_template"
        case groupMatchingMode = "group_matching_mode"
        case realm
        case krb5Conf = "krb5_conf"
        case kadminType = "kadmin_type"
        case syncUsers = "sync_users"
        case syncUsersPassword = "sync_users_password"
        case syncPrincipal = "sync_principal"
        case syncPassword = "sync_password"
        case syncKeytab = "sync_keytab"
        case syncCcache = "sync_ccache"
        case spnegoServerName = "spnego_server_name"
        case spnegoKeytab = "spnego_keytab"
        case spnegoCcache = "spnego_ccache"
        case passwordLoginUpdateInternalPassword = "password_login_update_internal_password"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encodeIfPresent(userPropertyMappings, forKey: .userPropertyMappings)
        try container.encodeIfPresent(groupPropertyMappings, forKey: .groupPropertyMappings)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encodeIfPresent(groupMatchingMode, forKey: .groupMatchingMode)
        try container.encode(realm, forKey: .realm)
        try container.encodeIfPresent(krb5Conf, forKey: .krb5Conf)
        try container.encodeIfPresent(kadminType, forKey: .kadminType)
        try container.encodeIfPresent(syncUsers, forKey: .syncUsers)
        try container.encodeIfPresent(syncUsersPassword, forKey: .syncUsersPassword)
        try container.encodeIfPresent(syncPrincipal, forKey: .syncPrincipal)
        try container.encodeIfPresent(syncPassword, forKey: .syncPassword)
        try container.encodeIfPresent(syncKeytab, forKey: .syncKeytab)
        try container.encodeIfPresent(syncCcache, forKey: .syncCcache)
        try container.encodeIfPresent(spnegoServerName, forKey: .spnegoServerName)
        try container.encodeIfPresent(spnegoKeytab, forKey: .spnegoKeytab)
        try container.encodeIfPresent(spnegoCcache, forKey: .spnegoCcache)
        try container.encodeIfPresent(passwordLoginUpdateInternalPassword, forKey: .passwordLoginUpdateInternalPassword)
    }
}

