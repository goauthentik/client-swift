//
// CaptchaStageRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** CaptchaStage Serializer */
public struct CaptchaStageRequest: Sendable, Codable, ParameterConvertible, Hashable {

    public static let nameRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let publicKeyRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let privateKeyRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let jsUrlRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let apiUrlRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public var name: String
    public var flowSet: [FlowSetRequest]?
    /** Public key, acquired your captcha Provider. */
    public var publicKey: String
    /** Private key, acquired your captcha Provider. */
    public var privateKey: String
    public var jsUrl: String?
    public var apiUrl: String?
    public var interactive: Bool?
    public var scoreMinThreshold: Double?
    public var scoreMaxThreshold: Double?
    /** When enabled and the received captcha score is outside of the given threshold, the stage will show an error message. When not enabled, the flow will continue, but the data from the captcha will be available in the context for policy decisions */
    public var errorOnInvalidScore: Bool?

    public init(name: String, flowSet: [FlowSetRequest]? = nil, publicKey: String, privateKey: String, jsUrl: String? = nil, apiUrl: String? = nil, interactive: Bool? = nil, scoreMinThreshold: Double? = nil, scoreMaxThreshold: Double? = nil, errorOnInvalidScore: Bool? = nil) {
        self.name = name
        self.flowSet = flowSet
        self.publicKey = publicKey
        self.privateKey = privateKey
        self.jsUrl = jsUrl
        self.apiUrl = apiUrl
        self.interactive = interactive
        self.scoreMinThreshold = scoreMinThreshold
        self.scoreMaxThreshold = scoreMaxThreshold
        self.errorOnInvalidScore = errorOnInvalidScore
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case flowSet = "flow_set"
        case publicKey = "public_key"
        case privateKey = "private_key"
        case jsUrl = "js_url"
        case apiUrl = "api_url"
        case interactive
        case scoreMinThreshold = "score_min_threshold"
        case scoreMaxThreshold = "score_max_threshold"
        case errorOnInvalidScore = "error_on_invalid_score"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(flowSet, forKey: .flowSet)
        try container.encode(publicKey, forKey: .publicKey)
        try container.encode(privateKey, forKey: .privateKey)
        try container.encodeIfPresent(jsUrl, forKey: .jsUrl)
        try container.encodeIfPresent(apiUrl, forKey: .apiUrl)
        try container.encodeIfPresent(interactive, forKey: .interactive)
        try container.encodeIfPresent(scoreMinThreshold, forKey: .scoreMinThreshold)
        try container.encodeIfPresent(scoreMaxThreshold, forKey: .scoreMaxThreshold)
        try container.encodeIfPresent(errorOnInvalidScore, forKey: .errorOnInvalidScore)
    }
}

