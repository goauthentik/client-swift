//
// PatchedLDAPSourceRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** LDAP Source Serializer */
public struct PatchedLDAPSourceRequest: Sendable, Codable, ParameterConvertible, Hashable {

    public static let nameRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let slugRule = StringRule(minLength: 1, maxLength: nil, pattern: "/^[-a-zA-Z0-9_]+$/")
    public static let userPathTemplateRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let serverUriRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let baseDnRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let userObjectFilterRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let groupObjectFilterRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let groupMembershipFieldRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let userMembershipAttributeRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let objectUniquenessFieldRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    /** Source's display Name. */
    public var name: String?
    /** Internal source name, used in URLs. */
    public var slug: String?
    public var enabled: Bool?
    /** When enabled, this source will be displayed as a prominent button on the login page, instead of a small icon. */
    public var promoted: Bool?
    /** Flow to use when authenticating existing users. */
    public var authenticationFlow: UUID?
    /** Flow to use when enrolling new users. */
    public var enrollmentFlow: UUID?
    public var userPropertyMappings: [UUID]?
    public var groupPropertyMappings: [UUID]?
    public var policyEngineMode: PolicyEngineMode?
    /** How the source determines if an existing user should be authenticated or a new user enrolled. */
    public var userMatchingMode: UserMatchingModeEnum?
    public var userPathTemplate: String?
    public var serverUri: String?
    /** Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair. */
    public var peerCertificate: UUID?
    /** Client certificate to authenticate against the LDAP Server's Certificate. */
    public var clientCertificate: UUID?
    public var bindCn: String?
    public var bindPassword: String?
    public var startTls: Bool?
    public var sni: Bool?
    public var baseDn: String?
    /** Prepended to Base DN for User-queries. */
    public var additionalUserDn: String?
    /** Prepended to Base DN for Group-queries. */
    public var additionalGroupDn: String?
    /** Consider Objects matching this filter to be Users. */
    public var userObjectFilter: String?
    /** Consider Objects matching this filter to be Groups. */
    public var groupObjectFilter: String?
    /** Field which contains members of a group. */
    public var groupMembershipField: String?
    /** Attribute which matches the value of `group_membership_field`. */
    public var userMembershipAttribute: String?
    /** Field which contains a unique Identifier. */
    public var objectUniquenessField: String?
    /** Update internal authentik password when login succeeds with LDAP */
    public var passwordLoginUpdateInternalPassword: Bool?
    public var syncUsers: Bool?
    /** When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source. */
    public var syncUsersPassword: Bool?
    public var syncGroups: Bool?
    public var syncParentGroup: UUID?
    /** Lookup group membership based on a user attribute instead of a group attribute. This allows nested group resolution on systems like FreeIPA and Active Directory */
    public var lookupGroupsFromUser: Bool?
    /** Delete authentik users and groups which were previously supplied by this source, but are now missing from it. */
    public var deleteNotFoundObjects: Bool?

    public init(name: String? = nil, slug: String? = nil, enabled: Bool? = nil, promoted: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, userPropertyMappings: [UUID]? = nil, groupPropertyMappings: [UUID]? = nil, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, userPathTemplate: String? = nil, serverUri: String? = nil, peerCertificate: UUID? = nil, clientCertificate: UUID? = nil, bindCn: String? = nil, bindPassword: String? = nil, startTls: Bool? = nil, sni: Bool? = nil, baseDn: String? = nil, additionalUserDn: String? = nil, additionalGroupDn: String? = nil, userObjectFilter: String? = nil, groupObjectFilter: String? = nil, groupMembershipField: String? = nil, userMembershipAttribute: String? = nil, objectUniquenessField: String? = nil, passwordLoginUpdateInternalPassword: Bool? = nil, syncUsers: Bool? = nil, syncUsersPassword: Bool? = nil, syncGroups: Bool? = nil, syncParentGroup: UUID? = nil, lookupGroupsFromUser: Bool? = nil, deleteNotFoundObjects: Bool? = nil) {
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.promoted = promoted
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.userPropertyMappings = userPropertyMappings
        self.groupPropertyMappings = groupPropertyMappings
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.userPathTemplate = userPathTemplate
        self.serverUri = serverUri
        self.peerCertificate = peerCertificate
        self.clientCertificate = clientCertificate
        self.bindCn = bindCn
        self.bindPassword = bindPassword
        self.startTls = startTls
        self.sni = sni
        self.baseDn = baseDn
        self.additionalUserDn = additionalUserDn
        self.additionalGroupDn = additionalGroupDn
        self.userObjectFilter = userObjectFilter
        self.groupObjectFilter = groupObjectFilter
        self.groupMembershipField = groupMembershipField
        self.userMembershipAttribute = userMembershipAttribute
        self.objectUniquenessField = objectUniquenessField
        self.passwordLoginUpdateInternalPassword = passwordLoginUpdateInternalPassword
        self.syncUsers = syncUsers
        self.syncUsersPassword = syncUsersPassword
        self.syncGroups = syncGroups
        self.syncParentGroup = syncParentGroup
        self.lookupGroupsFromUser = lookupGroupsFromUser
        self.deleteNotFoundObjects = deleteNotFoundObjects
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case slug
        case enabled
        case promoted
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case userPropertyMappings = "user_property_mappings"
        case groupPropertyMappings = "group_property_mappings"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case userPathTemplate = "user_path_template"
        case serverUri = "server_uri"
        case peerCertificate = "peer_certificate"
        case clientCertificate = "client_certificate"
        case bindCn = "bind_cn"
        case bindPassword = "bind_password"
        case startTls = "start_tls"
        case sni
        case baseDn = "base_dn"
        case additionalUserDn = "additional_user_dn"
        case additionalGroupDn = "additional_group_dn"
        case userObjectFilter = "user_object_filter"
        case groupObjectFilter = "group_object_filter"
        case groupMembershipField = "group_membership_field"
        case userMembershipAttribute = "user_membership_attribute"
        case objectUniquenessField = "object_uniqueness_field"
        case passwordLoginUpdateInternalPassword = "password_login_update_internal_password"
        case syncUsers = "sync_users"
        case syncUsersPassword = "sync_users_password"
        case syncGroups = "sync_groups"
        case syncParentGroup = "sync_parent_group"
        case lookupGroupsFromUser = "lookup_groups_from_user"
        case deleteNotFoundObjects = "delete_not_found_objects"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(promoted, forKey: .promoted)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encodeIfPresent(userPropertyMappings, forKey: .userPropertyMappings)
        try container.encodeIfPresent(groupPropertyMappings, forKey: .groupPropertyMappings)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encodeIfPresent(serverUri, forKey: .serverUri)
        try container.encodeIfPresent(peerCertificate, forKey: .peerCertificate)
        try container.encodeIfPresent(clientCertificate, forKey: .clientCertificate)
        try container.encodeIfPresent(bindCn, forKey: .bindCn)
        try container.encodeIfPresent(bindPassword, forKey: .bindPassword)
        try container.encodeIfPresent(startTls, forKey: .startTls)
        try container.encodeIfPresent(sni, forKey: .sni)
        try container.encodeIfPresent(baseDn, forKey: .baseDn)
        try container.encodeIfPresent(additionalUserDn, forKey: .additionalUserDn)
        try container.encodeIfPresent(additionalGroupDn, forKey: .additionalGroupDn)
        try container.encodeIfPresent(userObjectFilter, forKey: .userObjectFilter)
        try container.encodeIfPresent(groupObjectFilter, forKey: .groupObjectFilter)
        try container.encodeIfPresent(groupMembershipField, forKey: .groupMembershipField)
        try container.encodeIfPresent(userMembershipAttribute, forKey: .userMembershipAttribute)
        try container.encodeIfPresent(objectUniquenessField, forKey: .objectUniquenessField)
        try container.encodeIfPresent(passwordLoginUpdateInternalPassword, forKey: .passwordLoginUpdateInternalPassword)
        try container.encodeIfPresent(syncUsers, forKey: .syncUsers)
        try container.encodeIfPresent(syncUsersPassword, forKey: .syncUsersPassword)
        try container.encodeIfPresent(syncGroups, forKey: .syncGroups)
        try container.encodeIfPresent(syncParentGroup, forKey: .syncParentGroup)
        try container.encodeIfPresent(lookupGroupsFromUser, forKey: .lookupGroupsFromUser)
        try container.encodeIfPresent(deleteNotFoundObjects, forKey: .deleteNotFoundObjects)
    }
}

