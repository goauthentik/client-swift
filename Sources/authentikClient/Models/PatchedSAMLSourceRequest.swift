//
// PatchedSAMLSourceRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** SAMLSource Serializer */
public struct PatchedSAMLSourceRequest: Sendable, Codable, ParameterConvertible, Hashable {

    public static let nameRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let slugRule = StringRule(minLength: 1, maxLength: 50, pattern: "/^[-a-zA-Z0-9_]+$/")
    public static let userPathTemplateRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let ssoUrlRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let temporaryUserDeleteAfterRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    /** Source's display Name. */
    public var name: String?
    /** Internal source name, used in URLs. */
    public var slug: String?
    public var enabled: Bool?
    /** When enabled, this source will be displayed as a prominent button on the login page, instead of a small icon. */
    public var promoted: Bool?
    /** Flow to use when authenticating existing users. */
    public var authenticationFlow: UUID?
    /** Flow to use when enrolling new users. */
    public var enrollmentFlow: UUID?
    public var userPropertyMappings: [UUID]?
    public var groupPropertyMappings: [UUID]?
    public var policyEngineMode: PolicyEngineMode?
    /** How the source determines if an existing user should be authenticated or a new user enrolled. */
    public var userMatchingMode: UserMatchingModeEnum?
    public var userPathTemplate: String?
    /** How the source determines if an existing group should be used or a new group created. */
    public var groupMatchingMode: GroupMatchingModeEnum?
    /** Flow used before authentication. */
    public var preAuthenticationFlow: UUID?
    /** Also known as Entity ID. Defaults the Metadata URL. */
    public var issuer: String?
    /** URL that the initial Login request is sent to. */
    public var ssoUrl: String?
    /** Optional URL if your IDP supports Single-Logout. */
    public var sloUrl: String?
    /** Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done. */
    public var allowIdpInitiated: Bool?
    /** NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent. */
    public var nameIdPolicy: SAMLNameIDPolicyEnum?
    public var bindingType: BindingTypeEnum?
    /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
    public var verificationKp: UUID?
    /** Keypair used to sign outgoing Responses going to the Identity Provider. */
    public var signingKp: UUID?
    public var digestAlgorithm: DigestAlgorithmEnum?
    public var signatureAlgorithm: SignatureAlgorithmEnum?
    /** Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3). */
    public var temporaryUserDeleteAfter: String?
    /** When selected, incoming assertions are encrypted by the IdP using the public key of the encryption keypair. The assertion is decrypted by the SP using the the private key. */
    public var encryptionKp: UUID?
    public var signedAssertion: Bool?
    public var signedResponse: Bool?

    public init(name: String? = nil, slug: String? = nil, enabled: Bool? = nil, promoted: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, userPropertyMappings: [UUID]? = nil, groupPropertyMappings: [UUID]? = nil, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, userPathTemplate: String? = nil, groupMatchingMode: GroupMatchingModeEnum? = nil, preAuthenticationFlow: UUID? = nil, issuer: String? = nil, ssoUrl: String? = nil, sloUrl: String? = nil, allowIdpInitiated: Bool? = nil, nameIdPolicy: SAMLNameIDPolicyEnum? = nil, bindingType: BindingTypeEnum? = nil, verificationKp: UUID? = nil, signingKp: UUID? = nil, digestAlgorithm: DigestAlgorithmEnum? = nil, signatureAlgorithm: SignatureAlgorithmEnum? = nil, temporaryUserDeleteAfter: String? = nil, encryptionKp: UUID? = nil, signedAssertion: Bool? = nil, signedResponse: Bool? = nil) {
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.promoted = promoted
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.userPropertyMappings = userPropertyMappings
        self.groupPropertyMappings = groupPropertyMappings
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.userPathTemplate = userPathTemplate
        self.groupMatchingMode = groupMatchingMode
        self.preAuthenticationFlow = preAuthenticationFlow
        self.issuer = issuer
        self.ssoUrl = ssoUrl
        self.sloUrl = sloUrl
        self.allowIdpInitiated = allowIdpInitiated
        self.nameIdPolicy = nameIdPolicy
        self.bindingType = bindingType
        self.verificationKp = verificationKp
        self.signingKp = signingKp
        self.digestAlgorithm = digestAlgorithm
        self.signatureAlgorithm = signatureAlgorithm
        self.temporaryUserDeleteAfter = temporaryUserDeleteAfter
        self.encryptionKp = encryptionKp
        self.signedAssertion = signedAssertion
        self.signedResponse = signedResponse
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case slug
        case enabled
        case promoted
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case userPropertyMappings = "user_property_mappings"
        case groupPropertyMappings = "group_property_mappings"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case userPathTemplate = "user_path_template"
        case groupMatchingMode = "group_matching_mode"
        case preAuthenticationFlow = "pre_authentication_flow"
        case issuer
        case ssoUrl = "sso_url"
        case sloUrl = "slo_url"
        case allowIdpInitiated = "allow_idp_initiated"
        case nameIdPolicy = "name_id_policy"
        case bindingType = "binding_type"
        case verificationKp = "verification_kp"
        case signingKp = "signing_kp"
        case digestAlgorithm = "digest_algorithm"
        case signatureAlgorithm = "signature_algorithm"
        case temporaryUserDeleteAfter = "temporary_user_delete_after"
        case encryptionKp = "encryption_kp"
        case signedAssertion = "signed_assertion"
        case signedResponse = "signed_response"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(promoted, forKey: .promoted)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encodeIfPresent(userPropertyMappings, forKey: .userPropertyMappings)
        try container.encodeIfPresent(groupPropertyMappings, forKey: .groupPropertyMappings)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encodeIfPresent(groupMatchingMode, forKey: .groupMatchingMode)
        try container.encodeIfPresent(preAuthenticationFlow, forKey: .preAuthenticationFlow)
        try container.encodeIfPresent(issuer, forKey: .issuer)
        try container.encodeIfPresent(ssoUrl, forKey: .ssoUrl)
        try container.encodeIfPresent(sloUrl, forKey: .sloUrl)
        try container.encodeIfPresent(allowIdpInitiated, forKey: .allowIdpInitiated)
        try container.encodeIfPresent(nameIdPolicy, forKey: .nameIdPolicy)
        try container.encodeIfPresent(bindingType, forKey: .bindingType)
        try container.encodeIfPresent(verificationKp, forKey: .verificationKp)
        try container.encodeIfPresent(signingKp, forKey: .signingKp)
        try container.encodeIfPresent(digestAlgorithm, forKey: .digestAlgorithm)
        try container.encodeIfPresent(signatureAlgorithm, forKey: .signatureAlgorithm)
        try container.encodeIfPresent(temporaryUserDeleteAfter, forKey: .temporaryUserDeleteAfter)
        try container.encodeIfPresent(encryptionKp, forKey: .encryptionKp)
        try container.encodeIfPresent(signedAssertion, forKey: .signedAssertion)
        try container.encodeIfPresent(signedResponse, forKey: .signedResponse)
    }
}

