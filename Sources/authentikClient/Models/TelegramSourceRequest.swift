//
// TelegramSourceRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Source Serializer */
public struct TelegramSourceRequest: Sendable, Codable, ParameterConvertible, Hashable {

    public static let nameRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let slugRule = StringRule(minLength: 1, maxLength: nil, pattern: "/^[-a-zA-Z0-9_]+$/")
    public static let userPathTemplateRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let botUsernameRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public static let botTokenRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    /** Source's display Name. */
    public var name: String
    /** Internal source name, used in URLs. */
    public var slug: String
    public var enabled: Bool?
    /** When enabled, this source will be displayed as a prominent button on the login page, instead of a small icon. */
    public var promoted: Bool?
    /** Flow to use when authenticating existing users. */
    public var authenticationFlow: UUID?
    /** Flow to use when enrolling new users. */
    public var enrollmentFlow: UUID?
    public var userPropertyMappings: [UUID]?
    public var groupPropertyMappings: [UUID]?
    public var policyEngineMode: PolicyEngineMode?
    /** How the source determines if an existing user should be authenticated or a new user enrolled. */
    public var userMatchingMode: UserMatchingModeEnum?
    public var userPathTemplate: String?
    /** Telegram bot username */
    public var botUsername: String
    /** Telegram bot token */
    public var botToken: String
    /** Request access to send messages from your bot. */
    public var requestMessageAccess: Bool?
    /** Flow used before authentication. */
    public var preAuthenticationFlow: UUID

    public init(name: String, slug: String, enabled: Bool? = nil, promoted: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, userPropertyMappings: [UUID]? = nil, groupPropertyMappings: [UUID]? = nil, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, userPathTemplate: String? = nil, botUsername: String, botToken: String, requestMessageAccess: Bool? = nil, preAuthenticationFlow: UUID) {
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.promoted = promoted
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.userPropertyMappings = userPropertyMappings
        self.groupPropertyMappings = groupPropertyMappings
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.userPathTemplate = userPathTemplate
        self.botUsername = botUsername
        self.botToken = botToken
        self.requestMessageAccess = requestMessageAccess
        self.preAuthenticationFlow = preAuthenticationFlow
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case slug
        case enabled
        case promoted
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case userPropertyMappings = "user_property_mappings"
        case groupPropertyMappings = "group_property_mappings"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case userPathTemplate = "user_path_template"
        case botUsername = "bot_username"
        case botToken = "bot_token"
        case requestMessageAccess = "request_message_access"
        case preAuthenticationFlow = "pre_authentication_flow"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(promoted, forKey: .promoted)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encodeIfPresent(userPropertyMappings, forKey: .userPropertyMappings)
        try container.encodeIfPresent(groupPropertyMappings, forKey: .groupPropertyMappings)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encode(botUsername, forKey: .botUsername)
        try container.encode(botToken, forKey: .botToken)
        try container.encodeIfPresent(requestMessageAccess, forKey: .requestMessageAccess)
        try container.encode(preAuthenticationFlow, forKey: .preAuthenticationFlow)
    }
}

