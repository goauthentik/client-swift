//
// CaptchaStage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** CaptchaStage Serializer */
public struct CaptchaStage: Sendable, Codable, ParameterConvertible, Hashable {

    public var pk: UUID
    public var name: String
    /** Get object type so that we know how to edit the object */
    public var component: String
    /** Return object's verbose_name */
    public var verboseName: String
    /** Return object's plural verbose_name */
    public var verboseNamePlural: String
    /** Return internal model name */
    public var metaModelName: String
    public var flowSet: [FlowSet]?
    /** Public key, acquired your captcha Provider. */
    public var publicKey: String
    public var jsUrl: String?
    public var apiUrl: String?
    public var interactive: Bool?
    public var scoreMinThreshold: Double?
    public var scoreMaxThreshold: Double?
    /** When enabled and the received captcha score is outside of the given threshold, the stage will show an error message. When not enabled, the flow will continue, but the data from the captcha will be available in the context for policy decisions */
    public var errorOnInvalidScore: Bool?

    public init(pk: UUID, name: String, component: String, verboseName: String, verboseNamePlural: String, metaModelName: String, flowSet: [FlowSet]? = nil, publicKey: String, jsUrl: String? = nil, apiUrl: String? = nil, interactive: Bool? = nil, scoreMinThreshold: Double? = nil, scoreMaxThreshold: Double? = nil, errorOnInvalidScore: Bool? = nil) {
        self.pk = pk
        self.name = name
        self.component = component
        self.verboseName = verboseName
        self.verboseNamePlural = verboseNamePlural
        self.metaModelName = metaModelName
        self.flowSet = flowSet
        self.publicKey = publicKey
        self.jsUrl = jsUrl
        self.apiUrl = apiUrl
        self.interactive = interactive
        self.scoreMinThreshold = scoreMinThreshold
        self.scoreMaxThreshold = scoreMaxThreshold
        self.errorOnInvalidScore = errorOnInvalidScore
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case component
        case verboseName = "verbose_name"
        case verboseNamePlural = "verbose_name_plural"
        case metaModelName = "meta_model_name"
        case flowSet = "flow_set"
        case publicKey = "public_key"
        case jsUrl = "js_url"
        case apiUrl = "api_url"
        case interactive
        case scoreMinThreshold = "score_min_threshold"
        case scoreMaxThreshold = "score_max_threshold"
        case errorOnInvalidScore = "error_on_invalid_score"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encode(component, forKey: .component)
        try container.encode(verboseName, forKey: .verboseName)
        try container.encode(verboseNamePlural, forKey: .verboseNamePlural)
        try container.encode(metaModelName, forKey: .metaModelName)
        try container.encodeIfPresent(flowSet, forKey: .flowSet)
        try container.encode(publicKey, forKey: .publicKey)
        try container.encodeIfPresent(jsUrl, forKey: .jsUrl)
        try container.encodeIfPresent(apiUrl, forKey: .apiUrl)
        try container.encodeIfPresent(interactive, forKey: .interactive)
        try container.encodeIfPresent(scoreMinThreshold, forKey: .scoreMinThreshold)
        try container.encodeIfPresent(scoreMaxThreshold, forKey: .scoreMaxThreshold)
        try container.encodeIfPresent(errorOnInvalidScore, forKey: .errorOnInvalidScore)
    }
}

