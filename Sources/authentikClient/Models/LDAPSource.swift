//
// LDAPSource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** LDAP Source Serializer */
public struct LDAPSource: Sendable, Codable, ParameterConvertible, Hashable {

    public static let slugRule = StringRule(minLength: nil, maxLength: 50, pattern: "/^[-a-zA-Z0-9_]+$/")
    public var pk: UUID
    /** Source's display Name. */
    public var name: String
    /** Internal source name, used in URLs. */
    public var slug: String
    public var enabled: Bool?
    /** Flow to use when authenticating existing users. */
    public var authenticationFlow: UUID?
    /** Flow to use when enrolling new users. */
    public var enrollmentFlow: UUID?
    public var userPropertyMappings: [UUID]?
    public var groupPropertyMappings: [UUID]?
    /** Get object component so that we know how to edit the object */
    public var component: String
    /** Return object's verbose_name */
    public var verboseName: String
    /** Return object's plural verbose_name */
    public var verboseNamePlural: String
    /** Return internal model name */
    public var metaModelName: String
    public var policyEngineMode: PolicyEngineMode?
    /** How the source determines if an existing user should be authenticated or a new user enrolled. */
    public var userMatchingMode: UserMatchingModeEnum?
    /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
    public var managed: String?
    public var userPathTemplate: String?
    public var icon: String
    public var serverUri: String
    /** Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair. */
    public var peerCertificate: UUID?
    /** Client certificate to authenticate against the LDAP Server's Certificate. */
    public var clientCertificate: UUID?
    public var bindCn: String?
    public var startTls: Bool?
    public var sni: Bool?
    public var baseDn: String
    /** Prepended to Base DN for User-queries. */
    public var additionalUserDn: String?
    /** Prepended to Base DN for Group-queries. */
    public var additionalGroupDn: String?
    /** Consider Objects matching this filter to be Users. */
    public var userObjectFilter: String?
    /** Consider Objects matching this filter to be Groups. */
    public var groupObjectFilter: String?
    /** Field which contains members of a group. */
    public var groupMembershipField: String?
    /** Attribute which matches the value of `group_membership_field`. */
    public var userMembershipAttribute: String?
    /** Field which contains a unique Identifier. */
    public var objectUniquenessField: String?
    /** Update internal authentik password when login succeeds with LDAP */
    public var passwordLoginUpdateInternalPassword: Bool?
    public var syncUsers: Bool?
    /** When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source. */
    public var syncUsersPassword: Bool?
    public var syncGroups: Bool?
    public var syncParentGroup: UUID?
    /** Get cached source connectivity */
    public var connectivity: [String: [String: String]]?
    /** Lookup group membership based on a user attribute instead of a group attribute. This allows nested group resolution on systems like FreeIPA and Active Directory */
    public var lookupGroupsFromUser: Bool?
    /** Delete authentik users and groups which were previously supplied by this source, but are now missing from it. */
    public var deleteNotFoundObjects: Bool?

    public init(pk: UUID, name: String, slug: String, enabled: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, userPropertyMappings: [UUID]? = nil, groupPropertyMappings: [UUID]? = nil, component: String, verboseName: String, verboseNamePlural: String, metaModelName: String, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, managed: String?, userPathTemplate: String? = nil, icon: String, serverUri: String, peerCertificate: UUID? = nil, clientCertificate: UUID? = nil, bindCn: String? = nil, startTls: Bool? = nil, sni: Bool? = nil, baseDn: String, additionalUserDn: String? = nil, additionalGroupDn: String? = nil, userObjectFilter: String? = nil, groupObjectFilter: String? = nil, groupMembershipField: String? = nil, userMembershipAttribute: String? = nil, objectUniquenessField: String? = nil, passwordLoginUpdateInternalPassword: Bool? = nil, syncUsers: Bool? = nil, syncUsersPassword: Bool? = nil, syncGroups: Bool? = nil, syncParentGroup: UUID? = nil, connectivity: [String: [String: String]]?, lookupGroupsFromUser: Bool? = nil, deleteNotFoundObjects: Bool? = nil) {
        self.pk = pk
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.userPropertyMappings = userPropertyMappings
        self.groupPropertyMappings = groupPropertyMappings
        self.component = component
        self.verboseName = verboseName
        self.verboseNamePlural = verboseNamePlural
        self.metaModelName = metaModelName
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.managed = managed
        self.userPathTemplate = userPathTemplate
        self.icon = icon
        self.serverUri = serverUri
        self.peerCertificate = peerCertificate
        self.clientCertificate = clientCertificate
        self.bindCn = bindCn
        self.startTls = startTls
        self.sni = sni
        self.baseDn = baseDn
        self.additionalUserDn = additionalUserDn
        self.additionalGroupDn = additionalGroupDn
        self.userObjectFilter = userObjectFilter
        self.groupObjectFilter = groupObjectFilter
        self.groupMembershipField = groupMembershipField
        self.userMembershipAttribute = userMembershipAttribute
        self.objectUniquenessField = objectUniquenessField
        self.passwordLoginUpdateInternalPassword = passwordLoginUpdateInternalPassword
        self.syncUsers = syncUsers
        self.syncUsersPassword = syncUsersPassword
        self.syncGroups = syncGroups
        self.syncParentGroup = syncParentGroup
        self.connectivity = connectivity
        self.lookupGroupsFromUser = lookupGroupsFromUser
        self.deleteNotFoundObjects = deleteNotFoundObjects
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case slug
        case enabled
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case userPropertyMappings = "user_property_mappings"
        case groupPropertyMappings = "group_property_mappings"
        case component
        case verboseName = "verbose_name"
        case verboseNamePlural = "verbose_name_plural"
        case metaModelName = "meta_model_name"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case managed
        case userPathTemplate = "user_path_template"
        case icon
        case serverUri = "server_uri"
        case peerCertificate = "peer_certificate"
        case clientCertificate = "client_certificate"
        case bindCn = "bind_cn"
        case startTls = "start_tls"
        case sni
        case baseDn = "base_dn"
        case additionalUserDn = "additional_user_dn"
        case additionalGroupDn = "additional_group_dn"
        case userObjectFilter = "user_object_filter"
        case groupObjectFilter = "group_object_filter"
        case groupMembershipField = "group_membership_field"
        case userMembershipAttribute = "user_membership_attribute"
        case objectUniquenessField = "object_uniqueness_field"
        case passwordLoginUpdateInternalPassword = "password_login_update_internal_password"
        case syncUsers = "sync_users"
        case syncUsersPassword = "sync_users_password"
        case syncGroups = "sync_groups"
        case syncParentGroup = "sync_parent_group"
        case connectivity
        case lookupGroupsFromUser = "lookup_groups_from_user"
        case deleteNotFoundObjects = "delete_not_found_objects"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encodeIfPresent(userPropertyMappings, forKey: .userPropertyMappings)
        try container.encodeIfPresent(groupPropertyMappings, forKey: .groupPropertyMappings)
        try container.encode(component, forKey: .component)
        try container.encode(verboseName, forKey: .verboseName)
        try container.encode(verboseNamePlural, forKey: .verboseNamePlural)
        try container.encode(metaModelName, forKey: .metaModelName)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encode(managed, forKey: .managed)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encode(icon, forKey: .icon)
        try container.encode(serverUri, forKey: .serverUri)
        try container.encodeIfPresent(peerCertificate, forKey: .peerCertificate)
        try container.encodeIfPresent(clientCertificate, forKey: .clientCertificate)
        try container.encodeIfPresent(bindCn, forKey: .bindCn)
        try container.encodeIfPresent(startTls, forKey: .startTls)
        try container.encodeIfPresent(sni, forKey: .sni)
        try container.encode(baseDn, forKey: .baseDn)
        try container.encodeIfPresent(additionalUserDn, forKey: .additionalUserDn)
        try container.encodeIfPresent(additionalGroupDn, forKey: .additionalGroupDn)
        try container.encodeIfPresent(userObjectFilter, forKey: .userObjectFilter)
        try container.encodeIfPresent(groupObjectFilter, forKey: .groupObjectFilter)
        try container.encodeIfPresent(groupMembershipField, forKey: .groupMembershipField)
        try container.encodeIfPresent(userMembershipAttribute, forKey: .userMembershipAttribute)
        try container.encodeIfPresent(objectUniquenessField, forKey: .objectUniquenessField)
        try container.encodeIfPresent(passwordLoginUpdateInternalPassword, forKey: .passwordLoginUpdateInternalPassword)
        try container.encodeIfPresent(syncUsers, forKey: .syncUsers)
        try container.encodeIfPresent(syncUsersPassword, forKey: .syncUsersPassword)
        try container.encodeIfPresent(syncGroups, forKey: .syncGroups)
        try container.encodeIfPresent(syncParentGroup, forKey: .syncParentGroup)
        try container.encode(connectivity, forKey: .connectivity)
        try container.encodeIfPresent(lookupGroupsFromUser, forKey: .lookupGroupsFromUser)
        try container.encodeIfPresent(deleteNotFoundObjects, forKey: .deleteNotFoundObjects)
    }
}

