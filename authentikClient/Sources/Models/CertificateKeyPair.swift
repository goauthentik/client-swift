//
// CertificateKeyPair.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/// CertificateKeyPair Serializer 
public struct CertificateKeyPair: Codable {
    public var pk: UUID
    public var name: String
    /// Get certificate Hash (SHA256)
    public var fingerprintSha256: String?
    /// Get certificate Hash (SHA1)
    public var fingerprintSha1: String?
    /// Get certificate expiry
    public var certExpiry: Date?
    /// Get certificate subject as full rfc4514
    public var certSubject: String?
    /// Show if this keypair has a private key configured or not
    public var privateKeyAvailable: Bool
    /// Get the private key's type, if set
    public var privateKeyType: String?
    /// Get URL to download certificate
    public var certificateDownloadUrl: String
    /// Get URL to download private key
    public var privateKeyDownloadUrl: String
    /// Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
    public var managed: String?

    public init(pk: UUID, name: String, fingerprintSha256: String?, fingerprintSha1: String?, certExpiry: Date?, certSubject: String?, privateKeyAvailable: Bool, privateKeyType: String?, certificateDownloadUrl: String, privateKeyDownloadUrl: String, managed: String?) {
        self.pk = pk
        self.name = name
        self.fingerprintSha256 = fingerprintSha256
        self.fingerprintSha1 = fingerprintSha1
        self.certExpiry = certExpiry
        self.certSubject = certSubject
        self.privateKeyAvailable = privateKeyAvailable
        self.privateKeyType = privateKeyType
        self.certificateDownloadUrl = certificateDownloadUrl
        self.privateKeyDownloadUrl = privateKeyDownloadUrl
        self.managed = managed
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case fingerprintSha256 = "fingerprint_sha256"
        case fingerprintSha1 = "fingerprint_sha1"
        case certExpiry = "cert_expiry"
        case certSubject = "cert_subject"
        case privateKeyAvailable = "private_key_available"
        case privateKeyType = "private_key_type"
        case certificateDownloadUrl = "certificate_download_url"
        case privateKeyDownloadUrl = "private_key_download_url"
        case managed
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        pk = try container.decode(UUID.self, forKey: .pk)
        name = try container.decode(String.self, forKey: .name)
        fingerprintSha256 = try container.decode(String.self, forKey: .fingerprintSha256)
        fingerprintSha1 = try container.decode(String.self, forKey: .fingerprintSha1)
        certExpiry = try container.decode(Date.self, forKey: .certExpiry)
        certSubject = try container.decode(String.self, forKey: .certSubject)
        privateKeyAvailable = try container.decode(Bool.self, forKey: .privateKeyAvailable)
        privateKeyType = try container.decode(String.self, forKey: .privateKeyType)
        certificateDownloadUrl = try container.decode(String.self, forKey: .certificateDownloadUrl)
        privateKeyDownloadUrl = try container.decode(String.self, forKey: .privateKeyDownloadUrl)
        managed = try container.decode(String.self, forKey: .managed)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encode(fingerprintSha256, forKey: .fingerprintSha256)
        try container.encode(fingerprintSha1, forKey: .fingerprintSha1)
        try container.encode(certExpiry, forKey: .certExpiry)
        try container.encode(certSubject, forKey: .certSubject)
        try container.encode(privateKeyAvailable, forKey: .privateKeyAvailable)
        try container.encode(privateKeyType, forKey: .privateKeyType)
        try container.encode(certificateDownloadUrl, forKey: .certificateDownloadUrl)
        try container.encode(privateKeyDownloadUrl, forKey: .privateKeyDownloadUrl)
        try container.encode(managed, forKey: .managed)
    }
}
