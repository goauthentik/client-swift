//
// PlexSource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/// Plex Source Serializer 
public struct PlexSource: Codable {
    public var pk: UUID
    /// Source's display Name.
    public var name: String
    /// Internal source name, used in URLs.
    public var slug: String
    public var enabled: Bool?
    /// Flow to use when authenticating existing users.
    public var authenticationFlow: UUID?
    /// Flow to use when enrolling new users.
    public var enrollmentFlow: UUID?
    /// Get object component so that we know how to edit the object
    public var component: String
    /// Return object's verbose_name
    public var verboseName: String
    /// Return object's plural verbose_name
    public var verboseNamePlural: String
    /// Return internal model name
    public var metaModelName: String
    public var policyEngineMode: PolicyEngineMode?
    public var userMatchingMode: UserMatchingModeEnum?
    /// Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
    public var managed: String?
    public var userPathTemplate: String?
    /// Get the URL to the Icon. If the name is /static or starts with http it is returned as-is
    public var icon: String?
    /// Client identifier used to talk to Plex.
    public var clientId: String?
    /// Which servers a user has to be a member of to be granted access. Empty list allows every server.
    public var allowedServers: [String]?
    /// Allow friends to authenticate, even if you don't share a server.
    public var allowFriends: Bool?
    /// Plex token used to check friends
    public var plexToken: String

    public init(pk: UUID, name: String, slug: String, enabled: Bool? = nil, authenticationFlow: UUID? = nil, enrollmentFlow: UUID? = nil, component: String, verboseName: String, verboseNamePlural: String, metaModelName: String, policyEngineMode: PolicyEngineMode? = nil, userMatchingMode: UserMatchingModeEnum? = nil, managed: String?, userPathTemplate: String? = nil, icon: String?, clientId: String? = nil, allowedServers: [String]? = nil, allowFriends: Bool? = nil, plexToken: String) {
        self.pk = pk
        self.name = name
        self.slug = slug
        self.enabled = enabled
        self.authenticationFlow = authenticationFlow
        self.enrollmentFlow = enrollmentFlow
        self.component = component
        self.verboseName = verboseName
        self.verboseNamePlural = verboseNamePlural
        self.metaModelName = metaModelName
        self.policyEngineMode = policyEngineMode
        self.userMatchingMode = userMatchingMode
        self.managed = managed
        self.userPathTemplate = userPathTemplate
        self.icon = icon
        self.clientId = clientId
        self.allowedServers = allowedServers
        self.allowFriends = allowFriends
        self.plexToken = plexToken
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case slug
        case enabled
        case authenticationFlow = "authentication_flow"
        case enrollmentFlow = "enrollment_flow"
        case component
        case verboseName = "verbose_name"
        case verboseNamePlural = "verbose_name_plural"
        case metaModelName = "meta_model_name"
        case policyEngineMode = "policy_engine_mode"
        case userMatchingMode = "user_matching_mode"
        case managed
        case userPathTemplate = "user_path_template"
        case icon
        case clientId = "client_id"
        case allowedServers = "allowed_servers"
        case allowFriends = "allow_friends"
        case plexToken = "plex_token"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        pk = try container.decode(UUID.self, forKey: .pk)
        name = try container.decode(String.self, forKey: .name)
        slug = try container.decode(String.self, forKey: .slug)
        enabled = try container.decodeIfPresent(Bool.self, forKey: .enabled)
        authenticationFlow = try container.decodeIfPresent(UUID.self, forKey: .authenticationFlow)
        enrollmentFlow = try container.decodeIfPresent(UUID.self, forKey: .enrollmentFlow)
        component = try container.decode(String.self, forKey: .component)
        verboseName = try container.decode(String.self, forKey: .verboseName)
        verboseNamePlural = try container.decode(String.self, forKey: .verboseNamePlural)
        metaModelName = try container.decode(String.self, forKey: .metaModelName)
        policyEngineMode = try container.decodeIfPresent(PolicyEngineMode.self, forKey: .policyEngineMode)
        userMatchingMode = try container.decodeIfPresent(UserMatchingModeEnum.self, forKey: .userMatchingMode)
        managed = try container.decode(String.self, forKey: .managed)
        userPathTemplate = try container.decodeIfPresent(String.self, forKey: .userPathTemplate)
        icon = try container.decode(String.self, forKey: .icon)
        clientId = try container.decodeIfPresent(String.self, forKey: .clientId)
        allowedServers = try container.decodeIfPresent([String].self, forKey: .allowedServers)
        allowFriends = try container.decodeIfPresent(Bool.self, forKey: .allowFriends)
        plexToken = try container.decode(String.self, forKey: .plexToken)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(enabled, forKey: .enabled)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encodeIfPresent(enrollmentFlow, forKey: .enrollmentFlow)
        try container.encode(component, forKey: .component)
        try container.encode(verboseName, forKey: .verboseName)
        try container.encode(verboseNamePlural, forKey: .verboseNamePlural)
        try container.encode(metaModelName, forKey: .metaModelName)
        try container.encodeIfPresent(policyEngineMode, forKey: .policyEngineMode)
        try container.encodeIfPresent(userMatchingMode, forKey: .userMatchingMode)
        try container.encode(managed, forKey: .managed)
        try container.encodeIfPresent(userPathTemplate, forKey: .userPathTemplate)
        try container.encode(icon, forKey: .icon)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(allowedServers, forKey: .allowedServers)
        try container.encodeIfPresent(allowFriends, forKey: .allowFriends)
        try container.encode(plexToken, forKey: .plexToken)
    }
}
