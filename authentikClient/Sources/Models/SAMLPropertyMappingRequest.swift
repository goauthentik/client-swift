//
// SAMLPropertyMappingRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/// SAMLPropertyMapping Serializer 
public struct SAMLPropertyMappingRequest: Codable {
    /// Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
    public var managed: String?
    public var name: String
    public var expression: String
    public var samlName: String
    public var friendlyName: String?

    public init(managed: String? = nil, name: String, expression: String, samlName: String, friendlyName: String? = nil) {
        self.managed = managed
        self.name = name
        self.expression = expression
        self.samlName = samlName
        self.friendlyName = friendlyName
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case managed
        case name
        case expression
        case samlName = "saml_name"
        case friendlyName = "friendly_name"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        managed = try container.decodeIfPresent(String.self, forKey: .managed)
        name = try container.decode(String.self, forKey: .name)
        expression = try container.decode(String.self, forKey: .expression)
        samlName = try container.decode(String.self, forKey: .samlName)
        friendlyName = try container.decodeIfPresent(String.self, forKey: .friendlyName)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(managed, forKey: .managed)
        try container.encode(name, forKey: .name)
        try container.encode(expression, forKey: .expression)
        try container.encode(samlName, forKey: .samlName)
        try container.encodeIfPresent(friendlyName, forKey: .friendlyName)
    }
}
