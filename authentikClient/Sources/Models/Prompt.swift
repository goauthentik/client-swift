//
// Prompt.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/// Prompt Serializer 
public struct Prompt: Codable {
    public var pk: UUID
    public var name: String
    /// Name of the form field, also used to store the value
    public var fieldKey: String
    public var label: String
    public var type: PromptTypeEnum
    public var _required: Bool?
    /// Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.
    public var placeholder: String?
    /// Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.
    public var initialValue: String?
    public var order: Int?
    public var promptstageSet: [Stage]?
    public var subText: String?
    public var placeholderExpression: Bool?
    public var initialValueExpression: Bool?

    public init(pk: UUID, name: String, fieldKey: String, label: String, type: PromptTypeEnum, _required: Bool? = nil, placeholder: String? = nil, initialValue: String? = nil, order: Int? = nil, promptstageSet: [Stage]? = nil, subText: String? = nil, placeholderExpression: Bool? = nil, initialValueExpression: Bool? = nil) {
        self.pk = pk
        self.name = name
        self.fieldKey = fieldKey
        self.label = label
        self.type = type
        self._required = _required
        self.placeholder = placeholder
        self.initialValue = initialValue
        self.order = order
        self.promptstageSet = promptstageSet
        self.subText = subText
        self.placeholderExpression = placeholderExpression
        self.initialValueExpression = initialValueExpression
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case fieldKey = "field_key"
        case label
        case type
        case _required = "required"
        case placeholder
        case initialValue = "initial_value"
        case order
        case promptstageSet = "promptstage_set"
        case subText = "sub_text"
        case placeholderExpression = "placeholder_expression"
        case initialValueExpression = "initial_value_expression"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        pk = try container.decode(UUID.self, forKey: .pk)
        name = try container.decode(String.self, forKey: .name)
        fieldKey = try container.decode(String.self, forKey: .fieldKey)
        label = try container.decode(String.self, forKey: .label)
        type = try container.decode(PromptTypeEnum.self, forKey: .type)
        _required = try container.decodeIfPresent(Bool.self, forKey: ._required)
        placeholder = try container.decodeIfPresent(String.self, forKey: .placeholder)
        initialValue = try container.decodeIfPresent(String.self, forKey: .initialValue)
        order = try container.decodeIfPresent(Int.self, forKey: .order)
        promptstageSet = try container.decodeIfPresent([Stage].self, forKey: .promptstageSet)
        subText = try container.decodeIfPresent(String.self, forKey: .subText)
        placeholderExpression = try container.decodeIfPresent(Bool.self, forKey: .placeholderExpression)
        initialValueExpression = try container.decodeIfPresent(Bool.self, forKey: .initialValueExpression)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encode(fieldKey, forKey: .fieldKey)
        try container.encode(label, forKey: .label)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(_required, forKey: ._required)
        try container.encodeIfPresent(placeholder, forKey: .placeholder)
        try container.encodeIfPresent(initialValue, forKey: .initialValue)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(promptstageSet, forKey: .promptstageSet)
        try container.encodeIfPresent(subText, forKey: .subText)
        try container.encodeIfPresent(placeholderExpression, forKey: .placeholderExpression)
        try container.encodeIfPresent(initialValueExpression, forKey: .initialValueExpression)
    }
}
