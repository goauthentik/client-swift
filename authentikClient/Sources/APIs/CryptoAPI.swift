//
// CryptoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class CryptoAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum CryptoCertificatekeypairsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsCreateError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsCreateError: : \(object)"
            }
        }
    }

    /// - POST /crypto/certificatekeypairs/
    /// - CertificateKeyPair Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter certificateKeyPairRequest: (body)  
    /// - returns: AnyPublisher<CertificateKeyPair, Error> 
    open func cryptoCertificatekeypairsCreate(certificateKeyPairRequest: CertificateKeyPairRequest) -> AnyPublisher<CertificateKeyPair, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/crypto/certificatekeypairs/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(certificateKeyPairRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateKeyPair, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateKeyPair.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsDestroyError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /crypto/certificatekeypairs/{kp_uuid}/
    /// - CertificateKeyPair Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - returns: AnyPublisher<Void, Error> 
    open func cryptoCertificatekeypairsDestroy(kpUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsGenerateCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "CryptoCertificatekeypairsGenerateCreateError: Bad request"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsGenerateCreateError: : \(object)"
            }
        }
    }

    /// - POST /crypto/certificatekeypairs/generate/
    /// - Generate a new, self-signed certificate-key pair
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter certificateGenerationRequest: (body)  
    /// - returns: AnyPublisher<CertificateKeyPair, Error> 
    open func cryptoCertificatekeypairsGenerateCreate(certificateGenerationRequest: CertificateGenerationRequest) -> AnyPublisher<CertificateKeyPair, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/crypto/certificatekeypairs/generate/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(certificateGenerationRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateKeyPair, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return CryptoCertificatekeypairsGenerateCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsGenerateCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateKeyPair.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsListError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsListError: : \(object)"
            }
        }
    }

    /// - GET /crypto/certificatekeypairs/
    /// - CertificateKeyPair Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter hasKey: (query) Only return certificate-key pairs with keys (optional)
    /// - parameter includeDetails: (query)  (optional, default to true)
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedCertificateKeyPairList, Error> 
    open func cryptoCertificatekeypairsList(hasKey: Bool? = nil, includeDetails: Bool? = nil, managed: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedCertificateKeyPairList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/crypto/certificatekeypairs/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let hasKey = hasKey { queryItems.append(URLQueryItem(name: "has_key", value: hasKey ? "true" : "false")) } 
                if let includeDetails = includeDetails { queryItems.append(URLQueryItem(name: "include_details", value: includeDetails ? "true" : "false")) } 
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedCertificateKeyPairList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedCertificateKeyPairList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /crypto/certificatekeypairs/{kp_uuid}/
    /// - CertificateKeyPair Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - parameter patchedCertificateKeyPairRequest: (body)  (optional)
    /// - returns: AnyPublisher<CertificateKeyPair, Error> 
    open func cryptoCertificatekeypairsPartialUpdate(kpUuid: UUID, patchedCertificateKeyPairRequest: PatchedCertificateKeyPairRequest? = nil) -> AnyPublisher<CertificateKeyPair, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedCertificateKeyPairRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateKeyPair, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateKeyPair.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /crypto/certificatekeypairs/{kp_uuid}/
    /// - CertificateKeyPair Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - returns: AnyPublisher<CertificateKeyPair, Error> 
    open func cryptoCertificatekeypairsRetrieve(kpUuid: UUID) -> AnyPublisher<CertificateKeyPair, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateKeyPair, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateKeyPair.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsUpdateError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /crypto/certificatekeypairs/{kp_uuid}/
    /// - CertificateKeyPair Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - parameter certificateKeyPairRequest: (body)  
    /// - returns: AnyPublisher<CertificateKeyPair, Error> 
    open func cryptoCertificatekeypairsUpdate(kpUuid: UUID, certificateKeyPairRequest: CertificateKeyPairRequest) -> AnyPublisher<CertificateKeyPair, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(certificateKeyPairRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateKeyPair, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateKeyPair.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /crypto/certificatekeypairs/{kp_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func cryptoCertificatekeypairsUsedByList(kpUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsViewCertificateRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsViewCertificateRetrieveError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsViewCertificateRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /crypto/certificatekeypairs/{kp_uuid}/view_certificate/
    /// - Return certificate-key pairs certificate and log access
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - parameter download: (query)  (optional)
    /// - returns: AnyPublisher<CertificateData, Error> 
    open func cryptoCertificatekeypairsViewCertificateRetrieve(kpUuid: UUID, download: Bool? = nil) -> AnyPublisher<CertificateData, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/view_certificate/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let download = download { queryItems.append(URLQueryItem(name: "download", value: download ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateData, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsViewCertificateRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsViewCertificateRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateData.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum CryptoCertificatekeypairsViewPrivateKeyRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CryptoCertificatekeypairsViewPrivateKeyRetrieveError: : \(object)"
            case .code403Error(let object):
                return "CryptoCertificatekeypairsViewPrivateKeyRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /crypto/certificatekeypairs/{kp_uuid}/view_private_key/
    /// - Return certificate-key pairs private key and log access
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kpUuid: (path) A UUID string identifying this Certificate-Key Pair. 
    /// - parameter download: (query)  (optional)
    /// - returns: AnyPublisher<CertificateData, Error> 
    open func cryptoCertificatekeypairsViewPrivateKeyRetrieve(kpUuid: UUID, download: Bool? = nil) -> AnyPublisher<CertificateData, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/crypto/certificatekeypairs/{kp_uuid}/view_private_key/"
                path = path.replacingOccurrences(of: "{kp_uuid}", with: kpUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let download = download { queryItems.append(URLQueryItem(name: "download", value: download ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CertificateData, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return CryptoCertificatekeypairsViewPrivateKeyRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return CryptoCertificatekeypairsViewPrivateKeyRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CertificateData.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
