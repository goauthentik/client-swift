//
// ProvidersAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ProvidersAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum ProvidersAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/all/{id}/
    /// - Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersAllDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/all/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersAllListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersAllListError: : \(object)"
            }
        }
    }

    /// - GET /providers/all/
    /// - Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter applicationIsnull: (query)  (optional)
    /// - parameter backchannelOnly: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedProviderList, Error> 
    open func providersAllList(applicationIsnull: Bool? = nil, backchannelOnly: Bool? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let applicationIsnull = applicationIsnull { queryItems.append(URLQueryItem(name: "application__isnull", value: applicationIsnull ? "true" : "false")) } 
                if let backchannelOnly = backchannelOnly { queryItems.append(URLQueryItem(name: "backchannel_only", value: backchannelOnly ? "true" : "false")) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/all/{id}/
    /// - Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this provider. 
    /// - returns: AnyPublisher<Provider, Error> 
    open func providersAllRetrieve(id: Int) -> AnyPublisher<Provider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/all/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Provider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Provider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersAllTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersAllTypesListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersAllTypesListError: : \(object)"
            }
        }
    }

    /// - GET /providers/all/types/
    /// - Get all creatable provider types
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func providersAllTypesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/all/types/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersAllTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersAllTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/all/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersAllUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/all/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapCreateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapCreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/ldap/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter lDAPProviderRequest: (body)  
    /// - returns: AnyPublisher<LDAPProvider, Error> 
    open func providersLdapCreate(lDAPProviderRequest: LDAPProviderRequest) -> AnyPublisher<LDAPProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/ldap/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(lDAPProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapDestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/ldap/{id}/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this LDAP Provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersLdapDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/ldap/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapListError: : \(object)"
            }
        }
    }

    /// - GET /providers/ldap/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter applicationIsnull: (query)  (optional)
    /// - parameter authorizationFlowSlugIexact: (query)  (optional)
    /// - parameter baseDnIexact: (query)  (optional)
    /// - parameter certificateKpUuidIexact: (query)  (optional)
    /// - parameter certificateNameIexact: (query)  (optional)
    /// - parameter gidStartNumberIexact: (query)  (optional)
    /// - parameter nameIexact: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter searchGroupGroupUuidIexact: (query)  (optional)
    /// - parameter searchGroupNameIexact: (query)  (optional)
    /// - parameter tlsServerNameIexact: (query)  (optional)
    /// - parameter uidStartNumberIexact: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedLDAPProviderList, Error> 
    open func providersLdapList(applicationIsnull: Bool? = nil, authorizationFlowSlugIexact: String? = nil, baseDnIexact: String? = nil, certificateKpUuidIexact: UUID? = nil, certificateNameIexact: String? = nil, gidStartNumberIexact: Int? = nil, nameIexact: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, searchGroupGroupUuidIexact: UUID? = nil, searchGroupNameIexact: String? = nil, tlsServerNameIexact: String? = nil, uidStartNumberIexact: Int? = nil) -> AnyPublisher<PaginatedLDAPProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/ldap/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let applicationIsnull = applicationIsnull { queryItems.append(URLQueryItem(name: "application__isnull", value: applicationIsnull ? "true" : "false")) } 
                if let authorizationFlowSlugIexact = authorizationFlowSlugIexact { queryItems.append(URLQueryItem(name: "authorization_flow__slug__iexact", value: authorizationFlowSlugIexact)) } 
                if let baseDnIexact = baseDnIexact { queryItems.append(URLQueryItem(name: "base_dn__iexact", value: baseDnIexact)) } 
                if let certificateKpUuidIexact = certificateKpUuidIexact { queryItems.append(URLQueryItem(name: "certificate__kp_uuid__iexact", value: certificateKpUuidIexact.uuidString)) } 
                if let certificateNameIexact = certificateNameIexact { queryItems.append(URLQueryItem(name: "certificate__name__iexact", value: certificateNameIexact)) } 
                if let gidStartNumberIexact = gidStartNumberIexact { queryItems.append(URLQueryItem(name: "gid_start_number__iexact", value: "\(gidStartNumberIexact)")) } 
                if let nameIexact = nameIexact { queryItems.append(URLQueryItem(name: "name__iexact", value: nameIexact)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let searchGroupGroupUuidIexact = searchGroupGroupUuidIexact { queryItems.append(URLQueryItem(name: "search_group__group_uuid__iexact", value: searchGroupGroupUuidIexact.uuidString)) } 
                if let searchGroupNameIexact = searchGroupNameIexact { queryItems.append(URLQueryItem(name: "search_group__name__iexact", value: searchGroupNameIexact)) } 
                if let tlsServerNameIexact = tlsServerNameIexact { queryItems.append(URLQueryItem(name: "tls_server_name__iexact", value: tlsServerNameIexact)) } 
                if let uidStartNumberIexact = uidStartNumberIexact { queryItems.append(URLQueryItem(name: "uid_start_number__iexact", value: "\(uidStartNumberIexact)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedLDAPProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedLDAPProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /providers/ldap/{id}/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this LDAP Provider. 
    /// - parameter patchedLDAPProviderRequest: (body)  (optional)
    /// - returns: AnyPublisher<LDAPProvider, Error> 
    open func providersLdapPartialUpdate(id: Int, patchedLDAPProviderRequest: PatchedLDAPProviderRequest? = nil) -> AnyPublisher<LDAPProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/ldap/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedLDAPProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/ldap/{id}/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this LDAP Provider. 
    /// - returns: AnyPublisher<LDAPProvider, Error> 
    open func providersLdapRetrieve(id: Int) -> AnyPublisher<LDAPProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/ldap/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /providers/ldap/{id}/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this LDAP Provider. 
    /// - parameter lDAPProviderRequest: (body)  
    /// - returns: AnyPublisher<LDAPProvider, Error> 
    open func providersLdapUpdate(id: Int, lDAPProviderRequest: LDAPProviderRequest) -> AnyPublisher<LDAPProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/ldap/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(lDAPProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersLdapUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersLdapUsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersLdapUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/ldap/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this LDAP Provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersLdapUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/ldap/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersLdapUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersLdapUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2CreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2CreateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2CreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/oauth2/
    /// - OAuth2Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter oAuth2ProviderRequest: (body)  
    /// - returns: AnyPublisher<OAuth2Provider, Error> 
    open func providersOauth2Create(oAuth2ProviderRequest: OAuth2ProviderRequest) -> AnyPublisher<OAuth2Provider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/oauth2/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(oAuth2ProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuth2Provider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2CreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2CreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuth2Provider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2DestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2DestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2DestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/oauth2/{id}/
    /// - OAuth2Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersOauth2Destroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2DestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2DestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter clientType
    ///
    public enum ProvidersOauth2ListClientType: String, Codable, CaseIterable {
        case confidential = "confidential"
        case _public = "public"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter issuerMode
    ///
    public enum ProvidersOauth2ListIssuerMode: String, Codable, CaseIterable {
        case global = "global"
        case perProvider = "per_provider"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter subMode
    ///
    public enum ProvidersOauth2ListSubMode: String, Codable, CaseIterable {
        case hashedUserId = "hashed_user_id"
        case userEmail = "user_email"
        case userId = "user_id"
        case userUpn = "user_upn"
        case userUsername = "user_username"
        case userUuid = "user_uuid"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum ProvidersOauth2ListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2ListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2ListError: : \(object)"
            }
        }
    }

    /// - GET /providers/oauth2/
    /// - OAuth2Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter accessCodeValidity: (query)  (optional)
    /// - parameter accessTokenValidity: (query)  (optional)
    /// - parameter application: (query)  (optional)
    /// - parameter authorizationFlow: (query)  (optional)
    /// - parameter clientId: (query)  (optional)
    /// - parameter clientType: (query) Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * &#x60;confidential&#x60; - Confidential * &#x60;public&#x60; - Public (optional)
    /// - parameter includeClaimsInIdToken: (query)  (optional)
    /// - parameter issuerMode: (query) Configure how the issuer field of the ID Token should be filled.  * &#x60;global&#x60; - Same identifier is used for all providers * &#x60;per_provider&#x60; - Each provider has a different issuer, based on the application slug. (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter propertyMappings: (query)  (optional)
    /// - parameter redirectUris: (query)  (optional)
    /// - parameter refreshTokenValidity: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter signingKey: (query)  (optional)
    /// - parameter subMode: (query) Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * &#x60;hashed_user_id&#x60; - Based on the Hashed User ID * &#x60;user_id&#x60; - Based on user ID * &#x60;user_uuid&#x60; - Based on user UUID * &#x60;user_username&#x60; - Based on the username * &#x60;user_email&#x60; - Based on the User&#39;s Email. This is recommended over the UPN method. * &#x60;user_upn&#x60; - Based on the User&#39;s UPN, only works if user has a &#39;upn&#39; attribute set. Use this method only if you have different UPN and Mail domains. (optional)
    /// - returns: AnyPublisher<PaginatedOAuth2ProviderList, Error> 
    open func providersOauth2List(accessCodeValidity: String? = nil, accessTokenValidity: String? = nil, application: UUID? = nil, authorizationFlow: UUID? = nil, clientId: String? = nil, clientType: ProvidersOauth2ListClientType? = nil, includeClaimsInIdToken: Bool? = nil, issuerMode: ProvidersOauth2ListIssuerMode? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, propertyMappings: [UUID]? = nil, redirectUris: String? = nil, refreshTokenValidity: String? = nil, search: String? = nil, signingKey: UUID? = nil, subMode: ProvidersOauth2ListSubMode? = nil) -> AnyPublisher<PaginatedOAuth2ProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/oauth2/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accessCodeValidity = accessCodeValidity { queryItems.append(URLQueryItem(name: "access_code_validity", value: accessCodeValidity)) } 
                if let accessTokenValidity = accessTokenValidity { queryItems.append(URLQueryItem(name: "access_token_validity", value: accessTokenValidity)) } 
                if let application = application { queryItems.append(URLQueryItem(name: "application", value: application.uuidString)) } 
                if let authorizationFlow = authorizationFlow { queryItems.append(URLQueryItem(name: "authorization_flow", value: authorizationFlow.uuidString)) } 
                if let clientId = clientId { queryItems.append(URLQueryItem(name: "client_id", value: clientId)) } 
                if let clientType = clientType { queryItems.append(URLQueryItem(name: "client_type", value: clientType.rawValue)) } 
                if let includeClaimsInIdToken = includeClaimsInIdToken { queryItems.append(URLQueryItem(name: "include_claims_in_id_token", value: includeClaimsInIdToken ? "true" : "false")) } 
                if let issuerMode = issuerMode { queryItems.append(URLQueryItem(name: "issuer_mode", value: issuerMode.rawValue)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let propertyMappings = propertyMappings { queryItems.append(URLQueryItem(name: "property_mappings", value: propertyMappings.map { $0.uuidString }.joined(separator: ","))) } 
                if let redirectUris = redirectUris { queryItems.append(URLQueryItem(name: "redirect_uris", value: redirectUris)) } 
                if let refreshTokenValidity = refreshTokenValidity { queryItems.append(URLQueryItem(name: "refresh_token_validity", value: refreshTokenValidity)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let signingKey = signingKey { queryItems.append(URLQueryItem(name: "signing_key", value: signingKey.uuidString)) } 
                if let subMode = subMode { queryItems.append(URLQueryItem(name: "sub_mode", value: subMode.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedOAuth2ProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2ListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2ListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedOAuth2ProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2PartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2PartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2PartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /providers/oauth2/{id}/
    /// - OAuth2Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - parameter patchedOAuth2ProviderRequest: (body)  (optional)
    /// - returns: AnyPublisher<OAuth2Provider, Error> 
    open func providersOauth2PartialUpdate(id: Int, patchedOAuth2ProviderRequest: PatchedOAuth2ProviderRequest? = nil) -> AnyPublisher<OAuth2Provider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedOAuth2ProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuth2Provider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2PartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2PartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuth2Provider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2PreviewUserRetrieveError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "ProvidersOauth2PreviewUserRetrieveError: Bad request"
            case .code403Error(let object):
                return "ProvidersOauth2PreviewUserRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/oauth2/{id}/preview_user/
    /// - Preview user data for provider
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - returns: AnyPublisher<PropertyMappingPreview, Error> 
    open func providersOauth2PreviewUserRetrieve(id: Int) -> AnyPublisher<PropertyMappingPreview, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/preview_user/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PropertyMappingPreview, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return ProvidersOauth2PreviewUserRetrieveError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2PreviewUserRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PropertyMappingPreview.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2RetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2RetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2RetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/oauth2/{id}/
    /// - OAuth2Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - returns: AnyPublisher<OAuth2Provider, Error> 
    open func providersOauth2Retrieve(id: Int) -> AnyPublisher<OAuth2Provider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuth2Provider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2RetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2RetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuth2Provider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2SetupUrlsRetrieveError: Error, CustomStringConvertible {
        // Provider has no application assigned
        case code404Error
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code404Error:
                return "ProvidersOauth2SetupUrlsRetrieveError: Provider has no application assigned"
            case .code400Error(let object):
                return "ProvidersOauth2SetupUrlsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2SetupUrlsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/oauth2/{id}/setup_urls/
    /// - Get Providers setup URLs
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - returns: AnyPublisher<OAuth2ProviderSetupURLs, Error> 
    open func providersOauth2SetupUrlsRetrieve(id: Int) -> AnyPublisher<OAuth2ProviderSetupURLs, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/setup_urls/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuth2ProviderSetupURLs, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 404 {
                        return ProvidersOauth2SetupUrlsRetrieveError.code404Error
                    }
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2SetupUrlsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2SetupUrlsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuth2ProviderSetupURLs.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2UpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2UpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2UpdateError: : \(object)"
            }
        }
    }

    /// - PUT /providers/oauth2/{id}/
    /// - OAuth2Provider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - parameter oAuth2ProviderRequest: (body)  
    /// - returns: AnyPublisher<OAuth2Provider, Error> 
    open func providersOauth2Update(id: Int, oAuth2ProviderRequest: OAuth2ProviderRequest) -> AnyPublisher<OAuth2Provider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(oAuth2ProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuth2Provider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2UpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2UpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuth2Provider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersOauth2UsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersOauth2UsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersOauth2UsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/oauth2/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this OAuth2/OpenID Provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersOauth2UsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/oauth2/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersOauth2UsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersOauth2UsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyCreateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyCreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/proxy/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter proxyProviderRequest: (body)  
    /// - returns: AnyPublisher<ProxyProvider, Error> 
    open func providersProxyCreate(proxyProviderRequest: ProxyProviderRequest) -> AnyPublisher<ProxyProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/proxy/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(proxyProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProxyProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ProxyProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyDestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/proxy/{id}/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Proxy Provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersProxyDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/proxy/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyListError: : \(object)"
            }
        }
    }

    /// - GET /providers/proxy/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter applicationIsnull: (query)  (optional)
    /// - parameter authorizationFlowSlugIexact: (query)  (optional)
    /// - parameter basicAuthEnabledIexact: (query)  (optional)
    /// - parameter basicAuthPasswordAttributeIexact: (query)  (optional)
    /// - parameter basicAuthUserAttributeIexact: (query)  (optional)
    /// - parameter certificateKpUuidIexact: (query)  (optional)
    /// - parameter certificateNameIexact: (query)  (optional)
    /// - parameter cookieDomainIexact: (query)  (optional)
    /// - parameter externalHostIexact: (query)  (optional)
    /// - parameter internalHostIexact: (query)  (optional)
    /// - parameter internalHostSslValidationIexact: (query)  (optional)
    /// - parameter modeIexact: (query)  (optional)
    /// - parameter nameIexact: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter propertyMappingsIexact: (query)  (optional)
    /// - parameter redirectUrisIexact: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter skipPathRegexIexact: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedProxyProviderList, Error> 
    open func providersProxyList(applicationIsnull: Bool? = nil, authorizationFlowSlugIexact: String? = nil, basicAuthEnabledIexact: Bool? = nil, basicAuthPasswordAttributeIexact: String? = nil, basicAuthUserAttributeIexact: String? = nil, certificateKpUuidIexact: UUID? = nil, certificateNameIexact: String? = nil, cookieDomainIexact: String? = nil, externalHostIexact: String? = nil, internalHostIexact: String? = nil, internalHostSslValidationIexact: Bool? = nil, modeIexact: String? = nil, nameIexact: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, propertyMappingsIexact: [UUID]? = nil, redirectUrisIexact: String? = nil, search: String? = nil, skipPathRegexIexact: String? = nil) -> AnyPublisher<PaginatedProxyProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/proxy/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let applicationIsnull = applicationIsnull { queryItems.append(URLQueryItem(name: "application__isnull", value: applicationIsnull ? "true" : "false")) } 
                if let authorizationFlowSlugIexact = authorizationFlowSlugIexact { queryItems.append(URLQueryItem(name: "authorization_flow__slug__iexact", value: authorizationFlowSlugIexact)) } 
                if let basicAuthEnabledIexact = basicAuthEnabledIexact { queryItems.append(URLQueryItem(name: "basic_auth_enabled__iexact", value: basicAuthEnabledIexact ? "true" : "false")) } 
                if let basicAuthPasswordAttributeIexact = basicAuthPasswordAttributeIexact { queryItems.append(URLQueryItem(name: "basic_auth_password_attribute__iexact", value: basicAuthPasswordAttributeIexact)) } 
                if let basicAuthUserAttributeIexact = basicAuthUserAttributeIexact { queryItems.append(URLQueryItem(name: "basic_auth_user_attribute__iexact", value: basicAuthUserAttributeIexact)) } 
                if let certificateKpUuidIexact = certificateKpUuidIexact { queryItems.append(URLQueryItem(name: "certificate__kp_uuid__iexact", value: certificateKpUuidIexact.uuidString)) } 
                if let certificateNameIexact = certificateNameIexact { queryItems.append(URLQueryItem(name: "certificate__name__iexact", value: certificateNameIexact)) } 
                if let cookieDomainIexact = cookieDomainIexact { queryItems.append(URLQueryItem(name: "cookie_domain__iexact", value: cookieDomainIexact)) } 
                if let externalHostIexact = externalHostIexact { queryItems.append(URLQueryItem(name: "external_host__iexact", value: externalHostIexact)) } 
                if let internalHostIexact = internalHostIexact { queryItems.append(URLQueryItem(name: "internal_host__iexact", value: internalHostIexact)) } 
                if let internalHostSslValidationIexact = internalHostSslValidationIexact { queryItems.append(URLQueryItem(name: "internal_host_ssl_validation__iexact", value: internalHostSslValidationIexact ? "true" : "false")) } 
                if let modeIexact = modeIexact { queryItems.append(URLQueryItem(name: "mode__iexact", value: modeIexact)) } 
                if let nameIexact = nameIexact { queryItems.append(URLQueryItem(name: "name__iexact", value: nameIexact)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let propertyMappingsIexact = propertyMappingsIexact { queryItems.append(URLQueryItem(name: "property_mappings__iexact", value: propertyMappingsIexact.map { $0.uuidString }.joined(separator: ","))) } 
                if let redirectUrisIexact = redirectUrisIexact { queryItems.append(URLQueryItem(name: "redirect_uris__iexact", value: redirectUrisIexact)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let skipPathRegexIexact = skipPathRegexIexact { queryItems.append(URLQueryItem(name: "skip_path_regex__iexact", value: skipPathRegexIexact)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedProxyProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedProxyProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /providers/proxy/{id}/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Proxy Provider. 
    /// - parameter patchedProxyProviderRequest: (body)  (optional)
    /// - returns: AnyPublisher<ProxyProvider, Error> 
    open func providersProxyPartialUpdate(id: Int, patchedProxyProviderRequest: PatchedProxyProviderRequest? = nil) -> AnyPublisher<ProxyProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/proxy/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedProxyProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProxyProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ProxyProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/proxy/{id}/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Proxy Provider. 
    /// - returns: AnyPublisher<ProxyProvider, Error> 
    open func providersProxyRetrieve(id: Int) -> AnyPublisher<ProxyProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/proxy/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProxyProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ProxyProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /providers/proxy/{id}/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Proxy Provider. 
    /// - parameter proxyProviderRequest: (body)  
    /// - returns: AnyPublisher<ProxyProvider, Error> 
    open func providersProxyUpdate(id: Int, proxyProviderRequest: ProxyProviderRequest) -> AnyPublisher<ProxyProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/proxy/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(proxyProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProxyProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ProxyProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersProxyUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersProxyUsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersProxyUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/proxy/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Proxy Provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersProxyUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/proxy/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersProxyUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersProxyUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusCreateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusCreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/radius/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter radiusProviderRequest: (body)  
    /// - returns: AnyPublisher<RadiusProvider, Error> 
    open func providersRadiusCreate(radiusProviderRequest: RadiusProviderRequest) -> AnyPublisher<RadiusProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/radius/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(radiusProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RadiusProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RadiusProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusDestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/radius/{id}/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Radius Provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersRadiusDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/radius/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusListError: : \(object)"
            }
        }
    }

    /// - GET /providers/radius/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter applicationIsnull: (query)  (optional)
    /// - parameter authorizationFlowSlugIexact: (query)  (optional)
    /// - parameter clientNetworksIexact: (query)  (optional)
    /// - parameter nameIexact: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedRadiusProviderList, Error> 
    open func providersRadiusList(applicationIsnull: Bool? = nil, authorizationFlowSlugIexact: String? = nil, clientNetworksIexact: String? = nil, nameIexact: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedRadiusProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/radius/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let applicationIsnull = applicationIsnull { queryItems.append(URLQueryItem(name: "application__isnull", value: applicationIsnull ? "true" : "false")) } 
                if let authorizationFlowSlugIexact = authorizationFlowSlugIexact { queryItems.append(URLQueryItem(name: "authorization_flow__slug__iexact", value: authorizationFlowSlugIexact)) } 
                if let clientNetworksIexact = clientNetworksIexact { queryItems.append(URLQueryItem(name: "client_networks__iexact", value: clientNetworksIexact)) } 
                if let nameIexact = nameIexact { queryItems.append(URLQueryItem(name: "name__iexact", value: nameIexact)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedRadiusProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedRadiusProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /providers/radius/{id}/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Radius Provider. 
    /// - parameter patchedRadiusProviderRequest: (body)  (optional)
    /// - returns: AnyPublisher<RadiusProvider, Error> 
    open func providersRadiusPartialUpdate(id: Int, patchedRadiusProviderRequest: PatchedRadiusProviderRequest? = nil) -> AnyPublisher<RadiusProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/radius/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedRadiusProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RadiusProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RadiusProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/radius/{id}/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Radius Provider. 
    /// - returns: AnyPublisher<RadiusProvider, Error> 
    open func providersRadiusRetrieve(id: Int) -> AnyPublisher<RadiusProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/radius/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RadiusProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RadiusProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /providers/radius/{id}/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Radius Provider. 
    /// - parameter radiusProviderRequest: (body)  
    /// - returns: AnyPublisher<RadiusProvider, Error> 
    open func providersRadiusUpdate(id: Int, radiusProviderRequest: RadiusProviderRequest) -> AnyPublisher<RadiusProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/radius/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(radiusProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RadiusProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RadiusProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersRadiusUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersRadiusUsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersRadiusUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/radius/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Radius Provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersRadiusUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/radius/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersRadiusUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersRadiusUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlCreateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlCreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/saml/
    /// - SAMLProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter sAMLProviderRequest: (body)  
    /// - returns: AnyPublisher<SAMLProvider, Error> 
    open func providersSamlCreate(sAMLProviderRequest: SAMLProviderRequest) -> AnyPublisher<SAMLProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/saml/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(sAMLProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlDestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/saml/{id}/
    /// - SAMLProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersSamlDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlImportMetadataCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "ProvidersSamlImportMetadataCreateError: Bad request"
            case .code403Error(let object):
                return "ProvidersSamlImportMetadataCreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/saml/import_metadata/
    /// - Create provider from SAML Metadata
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (form)  
    /// - parameter authorizationFlow: (form)  
    /// - parameter file: (form)  
    /// - returns: AnyPublisher<Void, Error> 
    open func providersSamlImportMetadataCreate(name: String, authorizationFlow: UUID, file: Data) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/saml/import_metadata/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                let multipartBoundary = String(format: "Boundary+%08X%08X", arc4random(), arc4random())
                var multipartData = Data()
				let nameHeader = "--\(multipartBoundary)\r\n"
				    .appending("Content-Disposition:form-data; name=\"name\"\r\n")
				    .appending("\r\n")
				multipartData.append(nameHeader.data(using: .utf8) ?? Data())
				multipartData.append(name.data(using: .utf8) ?? Data())
				multipartData.append("\r\n".data(using: .utf8) ?? Data())

				let authorizationFlowHeader = "--\(multipartBoundary)\r\n"
				    .appending("Content-Disposition:form-data; name=\"authorizationFlow\"\r\n")
				    .appending("\r\n")
				multipartData.append(authorizationFlowHeader.data(using: .utf8) ?? Data())
				multipartData.append(authorizationFlow.data(using: .utf8) ?? Data())
				multipartData.append("\r\n".data(using: .utf8) ?? Data())

				let fileHeader = "--\(multipartBoundary)\r\n"
				    .appending("Content-Disposition:form-data; name=\"file\"; filename=\"file\"\r\n")
				    .appending("\r\n")
				multipartData.append(fileHeader.data(using: .utf8) ?? Data())
				multipartData.append(file)

                multipartData.append("\r\n--\(multipartBoundary)--\r\n".data(using: .utf8) ?? Data())
                request.httpBody = multipartData
                request.setValue("\(multipartData.count)", forHTTPHeaderField: "Content-Length")
                request.setValue("multipart/form-data; boundary=\(multipartBoundary)", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return ProvidersSamlImportMetadataCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlImportMetadataCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter digestAlgorithm
    ///
    public enum ProvidersSamlListDigestAlgorithm: String, Codable, CaseIterable {
        case _2000_09_xmldsig_sha1 = "http://www.w3.org/2000/09/xmldsig#sha1"
        case _2001_04_xmldsig_more_sha384 = "http://www.w3.org/2001/04/xmldsig-more#sha384"
        case _2001_04_xmlenc_sha256 = "http://www.w3.org/2001/04/xmlenc#sha256"
        case _2001_04_xmlenc_sha512 = "http://www.w3.org/2001/04/xmlenc#sha512"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter signatureAlgorithm
    ///
    public enum ProvidersSamlListSignatureAlgorithm: String, Codable, CaseIterable {
        case _2000_09_xmldsig_dsa_sha1 = "http://www.w3.org/2000/09/xmldsig#dsa-sha1"
        case _2000_09_xmldsig_rsa_sha1 = "http://www.w3.org/2000/09/xmldsig#rsa-sha1"
        case _2001_04_xmldsig_more_rsa_sha256 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"
        case _2001_04_xmldsig_more_rsa_sha384 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384"
        case _2001_04_xmldsig_more_rsa_sha512 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter spBinding
    ///
    public enum ProvidersSamlListSpBinding: String, Codable, CaseIterable {
        case post = "post"
        case redirect = "redirect"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum ProvidersSamlListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlListError: : \(object)"
            }
        }
    }

    /// - GET /providers/saml/
    /// - SAMLProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter acsUrl: (query)  (optional)
    /// - parameter assertionValidNotBefore: (query)  (optional)
    /// - parameter assertionValidNotOnOrAfter: (query)  (optional)
    /// - parameter audience: (query)  (optional)
    /// - parameter authenticationFlow: (query)  (optional)
    /// - parameter authorizationFlow: (query)  (optional)
    /// - parameter backchannelApplication: (query)  (optional)
    /// - parameter defaultRelayState: (query)  (optional)
    /// - parameter digestAlgorithm: (query) * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
    /// - parameter isBackchannel: (query)  (optional)
    /// - parameter issuer: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter nameIdMapping: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter propertyMappings: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter sessionValidNotOnOrAfter: (query)  (optional)
    /// - parameter signatureAlgorithm: (query) * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
    /// - parameter signingKp: (query)  (optional)
    /// - parameter spBinding: (query) This determines how authentik sends the response back to the Service Provider.  * &#x60;redirect&#x60; - Redirect * &#x60;post&#x60; - Post (optional)
    /// - parameter verificationKp: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedSAMLProviderList, Error> 
    open func providersSamlList(acsUrl: String? = nil, assertionValidNotBefore: String? = nil, assertionValidNotOnOrAfter: String? = nil, audience: String? = nil, authenticationFlow: UUID? = nil, authorizationFlow: UUID? = nil, backchannelApplication: UUID? = nil, defaultRelayState: String? = nil, digestAlgorithm: ProvidersSamlListDigestAlgorithm? = nil, isBackchannel: Bool? = nil, issuer: String? = nil, name: String? = nil, nameIdMapping: UUID? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, propertyMappings: [UUID]? = nil, search: String? = nil, sessionValidNotOnOrAfter: String? = nil, signatureAlgorithm: ProvidersSamlListSignatureAlgorithm? = nil, signingKp: UUID? = nil, spBinding: ProvidersSamlListSpBinding? = nil, verificationKp: UUID? = nil) -> AnyPublisher<PaginatedSAMLProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/saml/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let acsUrl = acsUrl { queryItems.append(URLQueryItem(name: "acs_url", value: acsUrl)) } 
                if let assertionValidNotBefore = assertionValidNotBefore { queryItems.append(URLQueryItem(name: "assertion_valid_not_before", value: assertionValidNotBefore)) } 
                if let assertionValidNotOnOrAfter = assertionValidNotOnOrAfter { queryItems.append(URLQueryItem(name: "assertion_valid_not_on_or_after", value: assertionValidNotOnOrAfter)) } 
                if let audience = audience { queryItems.append(URLQueryItem(name: "audience", value: audience)) } 
                if let authenticationFlow = authenticationFlow { queryItems.append(URLQueryItem(name: "authentication_flow", value: authenticationFlow.uuidString)) } 
                if let authorizationFlow = authorizationFlow { queryItems.append(URLQueryItem(name: "authorization_flow", value: authorizationFlow.uuidString)) } 
                if let backchannelApplication = backchannelApplication { queryItems.append(URLQueryItem(name: "backchannel_application", value: backchannelApplication.uuidString)) } 
                if let defaultRelayState = defaultRelayState { queryItems.append(URLQueryItem(name: "default_relay_state", value: defaultRelayState)) } 
                if let digestAlgorithm = digestAlgorithm { queryItems.append(URLQueryItem(name: "digest_algorithm", value: digestAlgorithm.rawValue)) } 
                if let isBackchannel = isBackchannel { queryItems.append(URLQueryItem(name: "is_backchannel", value: isBackchannel ? "true" : "false")) } 
                if let issuer = issuer { queryItems.append(URLQueryItem(name: "issuer", value: issuer)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let nameIdMapping = nameIdMapping { queryItems.append(URLQueryItem(name: "name_id_mapping", value: nameIdMapping.uuidString)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let propertyMappings = propertyMappings { queryItems.append(URLQueryItem(name: "property_mappings", value: propertyMappings.map { $0.uuidString }.joined(separator: ","))) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let sessionValidNotOnOrAfter = sessionValidNotOnOrAfter { queryItems.append(URLQueryItem(name: "session_valid_not_on_or_after", value: sessionValidNotOnOrAfter)) } 
                if let signatureAlgorithm = signatureAlgorithm { queryItems.append(URLQueryItem(name: "signature_algorithm", value: signatureAlgorithm.rawValue)) } 
                if let signingKp = signingKp { queryItems.append(URLQueryItem(name: "signing_kp", value: signingKp.uuidString)) } 
                if let spBinding = spBinding { queryItems.append(URLQueryItem(name: "sp_binding", value: spBinding.rawValue)) } 
                if let verificationKp = verificationKp { queryItems.append(URLQueryItem(name: "verification_kp", value: verificationKp.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSAMLProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSAMLProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter forceBinding
    ///
    public enum ProvidersSamlMetadataRetrieveForceBinding: String, Codable, CaseIterable {
        case post = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
        case redirect = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum ProvidersSamlMetadataRetrieveError: Error, CustomStringConvertible {
        // Provider has no application assigned
        case code404Error
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code404Error:
                return "ProvidersSamlMetadataRetrieveError: Provider has no application assigned"
            case .code400Error(let object):
                return "ProvidersSamlMetadataRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlMetadataRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/saml/{id}/metadata/
    /// - Return metadata as XML string
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - parameter download: (query)  (optional)
    /// - parameter forceBinding: (query) Optionally force the metadata to only include one binding. (optional)
    /// - returns: AnyPublisher<SAMLMetadata, Error> 
    open func providersSamlMetadataRetrieve(id: Int, download: Bool? = nil, forceBinding: ProvidersSamlMetadataRetrieveForceBinding? = nil) -> AnyPublisher<SAMLMetadata, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/metadata/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let download = download { queryItems.append(URLQueryItem(name: "download", value: download ? "true" : "false")) } 
                if let forceBinding = forceBinding { queryItems.append(URLQueryItem(name: "force_binding", value: forceBinding.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLMetadata, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 404 {
                        return ProvidersSamlMetadataRetrieveError.code404Error
                    }
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlMetadataRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlMetadataRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLMetadata.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /providers/saml/{id}/
    /// - SAMLProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - parameter patchedSAMLProviderRequest: (body)  (optional)
    /// - returns: AnyPublisher<SAMLProvider, Error> 
    open func providersSamlPartialUpdate(id: Int, patchedSAMLProviderRequest: PatchedSAMLProviderRequest? = nil) -> AnyPublisher<SAMLProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSAMLProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlPreviewUserRetrieveError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "ProvidersSamlPreviewUserRetrieveError: Bad request"
            case .code403Error(let object):
                return "ProvidersSamlPreviewUserRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/saml/{id}/preview_user/
    /// - Preview user data for provider
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - returns: AnyPublisher<PropertyMappingPreview, Error> 
    open func providersSamlPreviewUserRetrieve(id: Int) -> AnyPublisher<PropertyMappingPreview, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/preview_user/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PropertyMappingPreview, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return ProvidersSamlPreviewUserRetrieveError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlPreviewUserRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PropertyMappingPreview.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/saml/{id}/
    /// - SAMLProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - returns: AnyPublisher<SAMLProvider, Error> 
    open func providersSamlRetrieve(id: Int) -> AnyPublisher<SAMLProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /providers/saml/{id}/
    /// - SAMLProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - parameter sAMLProviderRequest: (body)  
    /// - returns: AnyPublisher<SAMLProvider, Error> 
    open func providersSamlUpdate(id: Int, sAMLProviderRequest: SAMLProviderRequest) -> AnyPublisher<SAMLProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sAMLProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersSamlUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersSamlUsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersSamlUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/saml/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SAML Provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersSamlUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/saml/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersSamlUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersSamlUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimCreateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimCreateError: : \(object)"
            }
        }
    }

    /// - POST /providers/scim/
    /// - SCIMProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter sCIMProviderRequest: (body)  
    /// - returns: AnyPublisher<SCIMProvider, Error> 
    open func providersScimCreate(sCIMProviderRequest: SCIMProviderRequest) -> AnyPublisher<SCIMProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/scim/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(sCIMProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimDestroyError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /providers/scim/{id}/
    /// - SCIMProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SCIM Provider. 
    /// - returns: AnyPublisher<Void, Error> 
    open func providersScimDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/scim/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimListError: : \(object)"
            }
        }
    }

    /// - GET /providers/scim/
    /// - SCIMProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter excludeUsersServiceAccount: (query)  (optional)
    /// - parameter filterGroup: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter url: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedSCIMProviderList, Error> 
    open func providersScimList(excludeUsersServiceAccount: Bool? = nil, filterGroup: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, url: String? = nil) -> AnyPublisher<PaginatedSCIMProviderList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/providers/scim/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let excludeUsersServiceAccount = excludeUsersServiceAccount { queryItems.append(URLQueryItem(name: "exclude_users_service_account", value: excludeUsersServiceAccount ? "true" : "false")) } 
                if let filterGroup = filterGroup { queryItems.append(URLQueryItem(name: "filter_group", value: filterGroup.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSCIMProviderList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSCIMProviderList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /providers/scim/{id}/
    /// - SCIMProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SCIM Provider. 
    /// - parameter patchedSCIMProviderRequest: (body)  (optional)
    /// - returns: AnyPublisher<SCIMProvider, Error> 
    open func providersScimPartialUpdate(id: Int, patchedSCIMProviderRequest: PatchedSCIMProviderRequest? = nil) -> AnyPublisher<SCIMProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/scim/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSCIMProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/scim/{id}/
    /// - SCIMProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SCIM Provider. 
    /// - returns: AnyPublisher<SCIMProvider, Error> 
    open func providersScimRetrieve(id: Int) -> AnyPublisher<SCIMProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/scim/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimSyncStatusRetrieveError: Error, CustomStringConvertible {
        // Task not found
        case code404Error
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code404Error:
                return "ProvidersScimSyncStatusRetrieveError: Task not found"
            case .code400Error(let object):
                return "ProvidersScimSyncStatusRetrieveError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimSyncStatusRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /providers/scim/{id}/sync_status/
    /// - Get provider's sync status
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SCIM Provider. 
    /// - returns: AnyPublisher<Task, Error> 
    open func providersScimSyncStatusRetrieve(id: Int) -> AnyPublisher<Task, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/scim/{id}/sync_status/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Task, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 404 {
                        return ProvidersScimSyncStatusRetrieveError.code404Error
                    }
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimSyncStatusRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimSyncStatusRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Task.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimUpdateError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /providers/scim/{id}/
    /// - SCIMProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SCIM Provider. 
    /// - parameter sCIMProviderRequest: (body)  
    /// - returns: AnyPublisher<SCIMProvider, Error> 
    open func providersScimUpdate(id: Int, sCIMProviderRequest: SCIMProviderRequest) -> AnyPublisher<SCIMProvider, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/scim/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sCIMProviderRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMProvider, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMProvider.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ProvidersScimUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "ProvidersScimUsedByListError: : \(object)"
            case .code403Error(let object):
                return "ProvidersScimUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /providers/scim/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SCIM Provider. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func providersScimUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/providers/scim/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return ProvidersScimUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return ProvidersScimUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
