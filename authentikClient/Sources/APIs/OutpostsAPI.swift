//
// OutpostsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class OutpostsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum OutpostsInstancesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesCreateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesCreateError: : \(object)"
            }
        }
    }

    /// - POST /outposts/instances/
    /// - Outpost Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter outpostRequest: (body)  
    /// - returns: AnyPublisher<Outpost, Error> 
    open func outpostsInstancesCreate(outpostRequest: OutpostRequest) -> AnyPublisher<Outpost, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/instances/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(outpostRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Outpost, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Outpost.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesDefaultSettingsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesDefaultSettingsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesDefaultSettingsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/instances/default_settings/
    /// - Global default outpost config
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<OutpostDefaultConfig, Error> 
    open func outpostsInstancesDefaultSettingsRetrieve() -> AnyPublisher<OutpostDefaultConfig, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/instances/default_settings/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OutpostDefaultConfig, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesDefaultSettingsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesDefaultSettingsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OutpostDefaultConfig.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesDestroyError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /outposts/instances/{uuid}/
    /// - Outpost Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost. 
    /// - returns: AnyPublisher<Void, Error> 
    open func outpostsInstancesDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/instances/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesHealthListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesHealthListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesHealthListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/instances/{uuid}/health/
    /// - Get outposts current health
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost. 
    /// - parameter managedIcontains: (query)  (optional)
    /// - parameter managedIexact: (query)  (optional)
    /// - parameter nameIcontains: (query)  (optional)
    /// - parameter nameIexact: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter providersIsnull: (query)  (optional)
    /// - parameter providersByPk: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter serviceConnectionNameIcontains: (query)  (optional)
    /// - parameter serviceConnectionNameIexact: (query)  (optional)
    /// - returns: AnyPublisher<[OutpostHealth], Error> 
    open func outpostsInstancesHealthList(uuid: UUID, managedIcontains: String? = nil, managedIexact: String? = nil, nameIcontains: String? = nil, nameIexact: String? = nil, ordering: String? = nil, providersIsnull: Bool? = nil, providersByPk: [Int]? = nil, search: String? = nil, serviceConnectionNameIcontains: String? = nil, serviceConnectionNameIexact: String? = nil) -> AnyPublisher<[OutpostHealth], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/instances/{uuid}/health/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let managedIcontains = managedIcontains { queryItems.append(URLQueryItem(name: "managed__icontains", value: managedIcontains)) } 
                if let managedIexact = managedIexact { queryItems.append(URLQueryItem(name: "managed__iexact", value: managedIexact)) } 
                if let nameIcontains = nameIcontains { queryItems.append(URLQueryItem(name: "name__icontains", value: nameIcontains)) } 
                if let nameIexact = nameIexact { queryItems.append(URLQueryItem(name: "name__iexact", value: nameIexact)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let providersIsnull = providersIsnull { queryItems.append(URLQueryItem(name: "providers__isnull", value: providersIsnull ? "true" : "false")) } 
                if let providersByPk = providersByPk { queryItems.append(URLQueryItem(name: "providers_by_pk", value: String(data: try self.encoder.encode(providersByPk), encoding: .utf8) ?? "")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let serviceConnectionNameIcontains = serviceConnectionNameIcontains { queryItems.append(URLQueryItem(name: "service_connection__name__icontains", value: serviceConnectionNameIcontains)) } 
                if let serviceConnectionNameIexact = serviceConnectionNameIexact { queryItems.append(URLQueryItem(name: "service_connection__name__iexact", value: serviceConnectionNameIexact)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OutpostHealth], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesHealthListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesHealthListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([OutpostHealth].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/instances/
    /// - Outpost Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter managedIcontains: (query)  (optional)
    /// - parameter managedIexact: (query)  (optional)
    /// - parameter nameIcontains: (query)  (optional)
    /// - parameter nameIexact: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter providersIsnull: (query)  (optional)
    /// - parameter providersByPk: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter serviceConnectionNameIcontains: (query)  (optional)
    /// - parameter serviceConnectionNameIexact: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedOutpostList, Error> 
    open func outpostsInstancesList(managedIcontains: String? = nil, managedIexact: String? = nil, nameIcontains: String? = nil, nameIexact: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, providersIsnull: Bool? = nil, providersByPk: [Int]? = nil, search: String? = nil, serviceConnectionNameIcontains: String? = nil, serviceConnectionNameIexact: String? = nil) -> AnyPublisher<PaginatedOutpostList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/instances/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let managedIcontains = managedIcontains { queryItems.append(URLQueryItem(name: "managed__icontains", value: managedIcontains)) } 
                if let managedIexact = managedIexact { queryItems.append(URLQueryItem(name: "managed__iexact", value: managedIexact)) } 
                if let nameIcontains = nameIcontains { queryItems.append(URLQueryItem(name: "name__icontains", value: nameIcontains)) } 
                if let nameIexact = nameIexact { queryItems.append(URLQueryItem(name: "name__iexact", value: nameIexact)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let providersIsnull = providersIsnull { queryItems.append(URLQueryItem(name: "providers__isnull", value: providersIsnull ? "true" : "false")) } 
                if let providersByPk = providersByPk { queryItems.append(URLQueryItem(name: "providers_by_pk", value: String(data: try self.encoder.encode(providersByPk), encoding: .utf8) ?? "")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let serviceConnectionNameIcontains = serviceConnectionNameIcontains { queryItems.append(URLQueryItem(name: "service_connection__name__icontains", value: serviceConnectionNameIcontains)) } 
                if let serviceConnectionNameIexact = serviceConnectionNameIexact { queryItems.append(URLQueryItem(name: "service_connection__name__iexact", value: serviceConnectionNameIexact)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedOutpostList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedOutpostList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /outposts/instances/{uuid}/
    /// - Outpost Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost. 
    /// - parameter patchedOutpostRequest: (body)  (optional)
    /// - returns: AnyPublisher<Outpost, Error> 
    open func outpostsInstancesPartialUpdate(uuid: UUID, patchedOutpostRequest: PatchedOutpostRequest? = nil) -> AnyPublisher<Outpost, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/instances/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedOutpostRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Outpost, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Outpost.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/instances/{uuid}/
    /// - Outpost Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost. 
    /// - returns: AnyPublisher<Outpost, Error> 
    open func outpostsInstancesRetrieve(uuid: UUID) -> AnyPublisher<Outpost, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/instances/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Outpost, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Outpost.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesUpdateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /outposts/instances/{uuid}/
    /// - Outpost Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost. 
    /// - parameter outpostRequest: (body)  
    /// - returns: AnyPublisher<Outpost, Error> 
    open func outpostsInstancesUpdate(uuid: UUID, outpostRequest: OutpostRequest) -> AnyPublisher<Outpost, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/instances/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(outpostRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Outpost, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Outpost.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsInstancesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsInstancesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsInstancesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/instances/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func outpostsInstancesUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/instances/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsInstancesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsInstancesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsLdapListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsLdapListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsLdapListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/ldap/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedLDAPOutpostConfigList, Error> 
    open func outpostsLdapList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedLDAPOutpostConfigList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/ldap/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedLDAPOutpostConfigList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsLdapListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsLdapListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedLDAPOutpostConfigList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsLdapRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsLdapRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsLdapRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/ldap/{id}/
    /// - LDAPProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this LDAP Provider. 
    /// - returns: AnyPublisher<LDAPOutpostConfig, Error> 
    open func outpostsLdapRetrieve(id: Int) -> AnyPublisher<LDAPOutpostConfig, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/ldap/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPOutpostConfig, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsLdapRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsLdapRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPOutpostConfig.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsProxyListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsProxyListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsProxyListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/proxy/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedProxyOutpostConfigList, Error> 
    open func outpostsProxyList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedProxyOutpostConfigList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/proxy/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedProxyOutpostConfigList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsProxyListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsProxyListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedProxyOutpostConfigList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsProxyRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsProxyRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsProxyRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/proxy/{id}/
    /// - ProxyProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Proxy Provider. 
    /// - returns: AnyPublisher<ProxyOutpostConfig, Error> 
    open func outpostsProxyRetrieve(id: Int) -> AnyPublisher<ProxyOutpostConfig, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/proxy/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProxyOutpostConfig, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsProxyRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsProxyRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ProxyOutpostConfig.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsRadiusListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsRadiusListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsRadiusListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/radius/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedRadiusOutpostConfigList, Error> 
    open func outpostsRadiusList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedRadiusOutpostConfigList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/radius/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedRadiusOutpostConfigList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsRadiusListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsRadiusListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedRadiusOutpostConfigList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsRadiusRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsRadiusRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsRadiusRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/radius/{id}/
    /// - RadiusProvider Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Radius Provider. 
    /// - returns: AnyPublisher<RadiusOutpostConfig, Error> 
    open func outpostsRadiusRetrieve(id: Int) -> AnyPublisher<RadiusOutpostConfig, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/radius/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RadiusOutpostConfig, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsRadiusRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsRadiusRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RadiusOutpostConfig.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /outposts/service_connections/all/{uuid}/
    /// - ServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost Service-Connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func outpostsServiceConnectionsAllDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/all/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsAllListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsAllListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/all/
    /// - ServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedServiceConnectionList, Error> 
    open func outpostsServiceConnectionsAllList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedServiceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/service_connections/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedServiceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedServiceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/all/{uuid}/
    /// - ServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost Service-Connection. 
    /// - returns: AnyPublisher<ServiceConnection, Error> 
    open func outpostsServiceConnectionsAllRetrieve(uuid: UUID) -> AnyPublisher<ServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/all/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsAllStateRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsAllStateRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsAllStateRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/all/{uuid}/state/
    /// - Get the service connection's state
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost Service-Connection. 
    /// - returns: AnyPublisher<ServiceConnectionState, Error> 
    open func outpostsServiceConnectionsAllStateRetrieve(uuid: UUID) -> AnyPublisher<ServiceConnectionState, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/all/{uuid}/state/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ServiceConnectionState, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllStateRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllStateRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ServiceConnectionState.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsAllTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsAllTypesListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsAllTypesListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/all/types/
    /// - Get all creatable service connection types
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func outpostsServiceConnectionsAllTypesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/service_connections/all/types/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/all/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Outpost Service-Connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func outpostsServiceConnectionsAllUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/all/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerCreateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerCreateError: : \(object)"
            }
        }
    }

    /// - POST /outposts/service_connections/docker/
    /// - DockerServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter dockerServiceConnectionRequest: (body)  
    /// - returns: AnyPublisher<DockerServiceConnection, Error> 
    open func outpostsServiceConnectionsDockerCreate(dockerServiceConnectionRequest: DockerServiceConnectionRequest) -> AnyPublisher<DockerServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/service_connections/docker/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(dockerServiceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DockerServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DockerServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerDestroyError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /outposts/service_connections/docker/{uuid}/
    /// - DockerServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Docker Service-Connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func outpostsServiceConnectionsDockerDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/docker/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/docker/
    /// - DockerServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter local: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter tlsAuthentication: (query)  (optional)
    /// - parameter tlsVerification: (query)  (optional)
    /// - parameter url: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedDockerServiceConnectionList, Error> 
    open func outpostsServiceConnectionsDockerList(local: Bool? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, tlsAuthentication: UUID? = nil, tlsVerification: UUID? = nil, url: String? = nil) -> AnyPublisher<PaginatedDockerServiceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/service_connections/docker/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let local = local { queryItems.append(URLQueryItem(name: "local", value: local ? "true" : "false")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let tlsAuthentication = tlsAuthentication { queryItems.append(URLQueryItem(name: "tls_authentication", value: tlsAuthentication.uuidString)) } 
                if let tlsVerification = tlsVerification { queryItems.append(URLQueryItem(name: "tls_verification", value: tlsVerification.uuidString)) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedDockerServiceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedDockerServiceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /outposts/service_connections/docker/{uuid}/
    /// - DockerServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Docker Service-Connection. 
    /// - parameter patchedDockerServiceConnectionRequest: (body)  (optional)
    /// - returns: AnyPublisher<DockerServiceConnection, Error> 
    open func outpostsServiceConnectionsDockerPartialUpdate(uuid: UUID, patchedDockerServiceConnectionRequest: PatchedDockerServiceConnectionRequest? = nil) -> AnyPublisher<DockerServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/docker/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedDockerServiceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DockerServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DockerServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/docker/{uuid}/
    /// - DockerServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Docker Service-Connection. 
    /// - returns: AnyPublisher<DockerServiceConnection, Error> 
    open func outpostsServiceConnectionsDockerRetrieve(uuid: UUID) -> AnyPublisher<DockerServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/docker/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DockerServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DockerServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerUpdateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /outposts/service_connections/docker/{uuid}/
    /// - DockerServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Docker Service-Connection. 
    /// - parameter dockerServiceConnectionRequest: (body)  
    /// - returns: AnyPublisher<DockerServiceConnection, Error> 
    open func outpostsServiceConnectionsDockerUpdate(uuid: UUID, dockerServiceConnectionRequest: DockerServiceConnectionRequest) -> AnyPublisher<DockerServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/docker/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(dockerServiceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DockerServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DockerServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsDockerUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsDockerUsedByListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsDockerUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/docker/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Docker Service-Connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func outpostsServiceConnectionsDockerUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/docker/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsDockerUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesCreateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesCreateError: : \(object)"
            }
        }
    }

    /// - POST /outposts/service_connections/kubernetes/
    /// - KubernetesServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter kubernetesServiceConnectionRequest: (body)  
    /// - returns: AnyPublisher<KubernetesServiceConnection, Error> 
    open func outpostsServiceConnectionsKubernetesCreate(kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) -> AnyPublisher<KubernetesServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/service_connections/kubernetes/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(kubernetesServiceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<KubernetesServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(KubernetesServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesDestroyError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /outposts/service_connections/kubernetes/{uuid}/
    /// - KubernetesServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Kubernetes Service-Connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func outpostsServiceConnectionsKubernetesDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/kubernetes/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/kubernetes/
    /// - KubernetesServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter local: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedKubernetesServiceConnectionList, Error> 
    open func outpostsServiceConnectionsKubernetesList(local: Bool? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedKubernetesServiceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/outposts/service_connections/kubernetes/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let local = local { queryItems.append(URLQueryItem(name: "local", value: local ? "true" : "false")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedKubernetesServiceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedKubernetesServiceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /outposts/service_connections/kubernetes/{uuid}/
    /// - KubernetesServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Kubernetes Service-Connection. 
    /// - parameter patchedKubernetesServiceConnectionRequest: (body)  (optional)
    /// - returns: AnyPublisher<KubernetesServiceConnection, Error> 
    open func outpostsServiceConnectionsKubernetesPartialUpdate(uuid: UUID, patchedKubernetesServiceConnectionRequest: PatchedKubernetesServiceConnectionRequest? = nil) -> AnyPublisher<KubernetesServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/kubernetes/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedKubernetesServiceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<KubernetesServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(KubernetesServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/kubernetes/{uuid}/
    /// - KubernetesServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Kubernetes Service-Connection. 
    /// - returns: AnyPublisher<KubernetesServiceConnection, Error> 
    open func outpostsServiceConnectionsKubernetesRetrieve(uuid: UUID) -> AnyPublisher<KubernetesServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/kubernetes/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<KubernetesServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(KubernetesServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesUpdateError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /outposts/service_connections/kubernetes/{uuid}/
    /// - KubernetesServiceConnection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Kubernetes Service-Connection. 
    /// - parameter kubernetesServiceConnectionRequest: (body)  
    /// - returns: AnyPublisher<KubernetesServiceConnection, Error> 
    open func outpostsServiceConnectionsKubernetesUpdate(uuid: UUID, kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) -> AnyPublisher<KubernetesServiceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/kubernetes/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(kubernetesServiceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<KubernetesServiceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(KubernetesServiceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum OutpostsServiceConnectionsKubernetesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "OutpostsServiceConnectionsKubernetesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "OutpostsServiceConnectionsKubernetesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /outposts/service_connections/kubernetes/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Kubernetes Service-Connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func outpostsServiceConnectionsKubernetesUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/outposts/service_connections/kubernetes/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return OutpostsServiceConnectionsKubernetesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
