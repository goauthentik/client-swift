//
// PoliciesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class PoliciesAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum PoliciesAllCacheClearCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "PoliciesAllCacheClearCreateError: Bad request"
            case .code403Error(let object):
                return "PoliciesAllCacheClearCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/all/cache_clear/
    /// - Clear policy cache
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesAllCacheClearCreate() -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/all/cache_clear/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return PoliciesAllCacheClearCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllCacheClearCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllCacheInfoRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesAllCacheInfoRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesAllCacheInfoRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/all/cache_info/
    /// - Info about cached policies
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<Cache, Error> 
    open func policiesAllCacheInfoRetrieve() -> AnyPublisher<Cache, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/all/cache_info/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Cache, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesAllCacheInfoRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllCacheInfoRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Cache.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/all/{policy_uuid}/
    /// - Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesAllDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/all/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesAllListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesAllListError: : \(object)"
            }
        }
    }

    /// - GET /policies/all/
    /// - Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter bindingsIsnull: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter promptstageIsnull: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedPolicyList, Error> 
    open func policiesAllList(bindingsIsnull: Bool? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, promptstageIsnull: Bool? = nil, search: String? = nil) -> AnyPublisher<PaginatedPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let bindingsIsnull = bindingsIsnull { queryItems.append(URLQueryItem(name: "bindings__isnull", value: bindingsIsnull ? "true" : "false")) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let promptstageIsnull = promptstageIsnull { queryItems.append(URLQueryItem(name: "promptstage__isnull", value: promptstageIsnull ? "true" : "false")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/all/{policy_uuid}/
    /// - Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Policy. 
    /// - returns: AnyPublisher<Policy, Error> 
    open func policiesAllRetrieve(policyUuid: UUID) -> AnyPublisher<Policy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/all/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Policy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Policy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllTestCreateError: Error, CustomStringConvertible {
        // Invalid parameters
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "PoliciesAllTestCreateError: Invalid parameters"
            case .code403Error(let object):
                return "PoliciesAllTestCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/all/{policy_uuid}/test/
    /// - Test policy
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Policy. 
    /// - parameter policyTestRequest: (body)  
    /// - returns: AnyPublisher<PolicyTestResult, Error> 
    open func policiesAllTestCreate(policyUuid: UUID, policyTestRequest: PolicyTestRequest) -> AnyPublisher<PolicyTestResult, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/all/{policy_uuid}/test/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(policyTestRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PolicyTestResult, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return PoliciesAllTestCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllTestCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PolicyTestResult.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesAllTypesListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesAllTypesListError: : \(object)"
            }
        }
    }

    /// - GET /policies/all/types/
    /// - Get all creatable policy types
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func policiesAllTypesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/all/types/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesAllTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/all/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesAllUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/all/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/bindings/
    /// - PolicyBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyBindingRequest: (body)  
    /// - returns: AnyPublisher<PolicyBinding, Error> 
    open func policiesBindingsCreate(policyBindingRequest: PolicyBindingRequest) -> AnyPublisher<PolicyBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/bindings/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(policyBindingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PolicyBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PolicyBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/bindings/{policy_binding_uuid}/
    /// - PolicyBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyBindingUuid: (path) A UUID string identifying this Policy Binding. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesBindingsDestroy(policyBindingUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/bindings/{policy_binding_uuid}/"
                path = path.replacingOccurrences(of: "{policy_binding_uuid}", with: policyBindingUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsListError: : \(object)"
            }
        }
    }

    /// - GET /policies/bindings/
    /// - PolicyBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter enabled: (query)  (optional)
    /// - parameter order: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policy: (query)  (optional)
    /// - parameter policyIsnull: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter target: (query)  (optional)
    /// - parameter targetIn: (query)  (optional)
    /// - parameter timeout: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedPolicyBindingList, Error> 
    open func policiesBindingsList(enabled: Bool? = nil, order: Int? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policy: UUID? = nil, policyIsnull: Bool? = nil, search: String? = nil, target: UUID? = nil, targetIn: [UUID]? = nil, timeout: Int? = nil) -> AnyPublisher<PaginatedPolicyBindingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/bindings/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let enabled = enabled { queryItems.append(URLQueryItem(name: "enabled", value: enabled ? "true" : "false")) } 
                if let order = order { queryItems.append(URLQueryItem(name: "order", value: "\(order)")) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policy = policy { queryItems.append(URLQueryItem(name: "policy", value: policy.uuidString)) } 
                if let policyIsnull = policyIsnull { queryItems.append(URLQueryItem(name: "policy__isnull", value: policyIsnull ? "true" : "false")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let target = target { queryItems.append(URLQueryItem(name: "target", value: target.uuidString)) } 
                if let targetIn = targetIn { queryItems.append(URLQueryItem(name: "target_in", value: targetIn.map { $0.uuidString }.joined(separator: ","))) } 
                if let timeout = timeout { queryItems.append(URLQueryItem(name: "timeout", value: "\(timeout)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPolicyBindingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPolicyBindingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/bindings/{policy_binding_uuid}/
    /// - PolicyBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyBindingUuid: (path) A UUID string identifying this Policy Binding. 
    /// - parameter patchedPolicyBindingRequest: (body)  (optional)
    /// - returns: AnyPublisher<PolicyBinding, Error> 
    open func policiesBindingsPartialUpdate(policyBindingUuid: UUID, patchedPolicyBindingRequest: PatchedPolicyBindingRequest? = nil) -> AnyPublisher<PolicyBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/bindings/{policy_binding_uuid}/"
                path = path.replacingOccurrences(of: "{policy_binding_uuid}", with: policyBindingUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPolicyBindingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PolicyBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PolicyBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/bindings/{policy_binding_uuid}/
    /// - PolicyBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyBindingUuid: (path) A UUID string identifying this Policy Binding. 
    /// - returns: AnyPublisher<PolicyBinding, Error> 
    open func policiesBindingsRetrieve(policyBindingUuid: UUID) -> AnyPublisher<PolicyBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/bindings/{policy_binding_uuid}/"
                path = path.replacingOccurrences(of: "{policy_binding_uuid}", with: policyBindingUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PolicyBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PolicyBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/bindings/{policy_binding_uuid}/
    /// - PolicyBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyBindingUuid: (path) A UUID string identifying this Policy Binding. 
    /// - parameter policyBindingRequest: (body)  
    /// - returns: AnyPublisher<PolicyBinding, Error> 
    open func policiesBindingsUpdate(policyBindingUuid: UUID, policyBindingRequest: PolicyBindingRequest) -> AnyPublisher<PolicyBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/bindings/{policy_binding_uuid}/"
                path = path.replacingOccurrences(of: "{policy_binding_uuid}", with: policyBindingUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(policyBindingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PolicyBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PolicyBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesBindingsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesBindingsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesBindingsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/bindings/{policy_binding_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyBindingUuid: (path) A UUID string identifying this Policy Binding. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesBindingsUsedByList(policyBindingUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/bindings/{policy_binding_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_binding_uuid}", with: policyBindingUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesBindingsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesBindingsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/dummy/
    /// - Dummy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter dummyPolicyRequest: (body)  
    /// - returns: AnyPublisher<DummyPolicy, Error> 
    open func policiesDummyCreate(dummyPolicyRequest: DummyPolicyRequest) -> AnyPublisher<DummyPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/dummy/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(dummyPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/dummy/{policy_uuid}/
    /// - Dummy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Dummy Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesDummyDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/dummy/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyListError: : \(object)"
            }
        }
    }

    /// - GET /policies/dummy/
    /// - Dummy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter created: (query)  (optional)
    /// - parameter executionLogging: (query)  (optional)
    /// - parameter lastUpdated: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyUuid: (query)  (optional)
    /// - parameter result: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter waitMax: (query)  (optional)
    /// - parameter waitMin: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedDummyPolicyList, Error> 
    open func policiesDummyList(created: Date? = nil, executionLogging: Bool? = nil, lastUpdated: Date? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyUuid: UUID? = nil, result: Bool? = nil, search: String? = nil, waitMax: Int? = nil, waitMin: Int? = nil) -> AnyPublisher<PaginatedDummyPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/dummy/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let executionLogging = executionLogging { queryItems.append(URLQueryItem(name: "execution_logging", value: executionLogging ? "true" : "false")) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "last_updated", value: OpenISO8601DateFormatter.shared.string(from: lastUpdated))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyUuid = policyUuid { queryItems.append(URLQueryItem(name: "policy_uuid", value: policyUuid.uuidString)) } 
                if let result = result { queryItems.append(URLQueryItem(name: "result", value: result ? "true" : "false")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let waitMax = waitMax { queryItems.append(URLQueryItem(name: "wait_max", value: "\(waitMax)")) } 
                if let waitMin = waitMin { queryItems.append(URLQueryItem(name: "wait_min", value: "\(waitMin)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedDummyPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedDummyPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/dummy/{policy_uuid}/
    /// - Dummy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Dummy Policy. 
    /// - parameter patchedDummyPolicyRequest: (body)  (optional)
    /// - returns: AnyPublisher<DummyPolicy, Error> 
    open func policiesDummyPartialUpdate(policyUuid: UUID, patchedDummyPolicyRequest: PatchedDummyPolicyRequest? = nil) -> AnyPublisher<DummyPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/dummy/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedDummyPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/dummy/{policy_uuid}/
    /// - Dummy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Dummy Policy. 
    /// - returns: AnyPublisher<DummyPolicy, Error> 
    open func policiesDummyRetrieve(policyUuid: UUID) -> AnyPublisher<DummyPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/dummy/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/dummy/{policy_uuid}/
    /// - Dummy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Dummy Policy. 
    /// - parameter dummyPolicyRequest: (body)  
    /// - returns: AnyPublisher<DummyPolicy, Error> 
    open func policiesDummyUpdate(policyUuid: UUID, dummyPolicyRequest: DummyPolicyRequest) -> AnyPublisher<DummyPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/dummy/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(dummyPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesDummyUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesDummyUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesDummyUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/dummy/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Dummy Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesDummyUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/dummy/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesDummyUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesDummyUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesEventMatcherCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/event_matcher/
    /// - Event Matcher Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter eventMatcherPolicyRequest: (body)  
    /// - returns: AnyPublisher<EventMatcherPolicy, Error> 
    open func policiesEventMatcherCreate(eventMatcherPolicyRequest: EventMatcherPolicyRequest) -> AnyPublisher<EventMatcherPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/event_matcher/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(eventMatcherPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EventMatcherPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EventMatcherPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesEventMatcherDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/event_matcher/{policy_uuid}/
    /// - Event Matcher Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Event Matcher Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesEventMatcherDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/event_matcher/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter action
    ///
    public enum PoliciesEventMatcherListAction: String, Codable, CaseIterable {
        case authorizeApplication = "authorize_application"
        case configurationError = "configuration_error"
        case custom = "custom_"
        case emailSent = "email_sent"
        case flowExecution = "flow_execution"
        case impersonationEnded = "impersonation_ended"
        case impersonationStarted = "impersonation_started"
        case invitationUsed = "invitation_used"
        case login = "login"
        case loginFailed = "login_failed"
        case logout = "logout"
        case modelCreated = "model_created"
        case modelDeleted = "model_deleted"
        case modelUpdated = "model_updated"
        case passwordSet = "password_set"
        case policyException = "policy_exception"
        case policyExecution = "policy_execution"
        case propertyMappingException = "property_mapping_exception"
        case secretRotate = "secret_rotate"
        case secretView = "secret_view"
        case sourceLinked = "source_linked"
        case suspiciousRequest = "suspicious_request"
        case systemException = "system_exception"
        case systemTaskException = "system_task_exception"
        case systemTaskExecution = "system_task_execution"
        case updateAvailable = "update_available"
        case userWrite = "user_write"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum PoliciesEventMatcherListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherListError: : \(object)"
            }
        }
    }

    /// - GET /policies/event_matcher/
    /// - Event Matcher Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter action: (query) Match created events with this action type. When left empty, all action types will be matched.  * &#x60;login&#x60; - Login * &#x60;login_failed&#x60; - Login Failed * &#x60;logout&#x60; - Logout * &#x60;user_write&#x60; - User Write * &#x60;suspicious_request&#x60; - Suspicious Request * &#x60;password_set&#x60; - Password Set * &#x60;secret_view&#x60; - Secret View * &#x60;secret_rotate&#x60; - Secret Rotate * &#x60;invitation_used&#x60; - Invite Used * &#x60;authorize_application&#x60; - Authorize Application * &#x60;source_linked&#x60; - Source Linked * &#x60;impersonation_started&#x60; - Impersonation Started * &#x60;impersonation_ended&#x60; - Impersonation Ended * &#x60;flow_execution&#x60; - Flow Execution * &#x60;policy_execution&#x60; - Policy Execution * &#x60;policy_exception&#x60; - Policy Exception * &#x60;property_mapping_exception&#x60; - Property Mapping Exception * &#x60;system_task_execution&#x60; - System Task Execution * &#x60;system_task_exception&#x60; - System Task Exception * &#x60;system_exception&#x60; - System Exception * &#x60;configuration_error&#x60; - Configuration Error * &#x60;model_created&#x60; - Model Created * &#x60;model_updated&#x60; - Model Updated * &#x60;model_deleted&#x60; - Model Deleted * &#x60;email_sent&#x60; - Email Sent * &#x60;update_available&#x60; - Update Available * &#x60;custom_&#x60; - Custom Prefix (optional)
    /// - parameter app: (query)  (optional)
    /// - parameter clientIp: (query)  (optional)
    /// - parameter created: (query)  (optional)
    /// - parameter executionLogging: (query)  (optional)
    /// - parameter lastUpdated: (query)  (optional)
    /// - parameter model: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedEventMatcherPolicyList, Error> 
    open func policiesEventMatcherList(action: PoliciesEventMatcherListAction? = nil, app: String? = nil, clientIp: String? = nil, created: Date? = nil, executionLogging: Bool? = nil, lastUpdated: Date? = nil, model: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyUuid: UUID? = nil, search: String? = nil) -> AnyPublisher<PaginatedEventMatcherPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/event_matcher/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action.rawValue)) } 
                if let app = app { queryItems.append(URLQueryItem(name: "app", value: app)) } 
                if let clientIp = clientIp { queryItems.append(URLQueryItem(name: "client_ip", value: clientIp)) } 
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let executionLogging = executionLogging { queryItems.append(URLQueryItem(name: "execution_logging", value: executionLogging ? "true" : "false")) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "last_updated", value: OpenISO8601DateFormatter.shared.string(from: lastUpdated))) } 
                if let model = model { queryItems.append(URLQueryItem(name: "model", value: model)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyUuid = policyUuid { queryItems.append(URLQueryItem(name: "policy_uuid", value: policyUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedEventMatcherPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedEventMatcherPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesEventMatcherPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/event_matcher/{policy_uuid}/
    /// - Event Matcher Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Event Matcher Policy. 
    /// - parameter patchedEventMatcherPolicyRequest: (body)  (optional)
    /// - returns: AnyPublisher<EventMatcherPolicy, Error> 
    open func policiesEventMatcherPartialUpdate(policyUuid: UUID, patchedEventMatcherPolicyRequest: PatchedEventMatcherPolicyRequest? = nil) -> AnyPublisher<EventMatcherPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/event_matcher/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedEventMatcherPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EventMatcherPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EventMatcherPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesEventMatcherRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/event_matcher/{policy_uuid}/
    /// - Event Matcher Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Event Matcher Policy. 
    /// - returns: AnyPublisher<EventMatcherPolicy, Error> 
    open func policiesEventMatcherRetrieve(policyUuid: UUID) -> AnyPublisher<EventMatcherPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/event_matcher/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EventMatcherPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EventMatcherPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesEventMatcherUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/event_matcher/{policy_uuid}/
    /// - Event Matcher Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Event Matcher Policy. 
    /// - parameter eventMatcherPolicyRequest: (body)  
    /// - returns: AnyPublisher<EventMatcherPolicy, Error> 
    open func policiesEventMatcherUpdate(policyUuid: UUID, eventMatcherPolicyRequest: EventMatcherPolicyRequest) -> AnyPublisher<EventMatcherPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/event_matcher/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(eventMatcherPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EventMatcherPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EventMatcherPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesEventMatcherUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesEventMatcherUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesEventMatcherUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/event_matcher/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Event Matcher Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesEventMatcherUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/event_matcher/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesEventMatcherUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesEventMatcherUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/expression/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter expressionPolicyRequest: (body)  
    /// - returns: AnyPublisher<ExpressionPolicy, Error> 
    open func policiesExpressionCreate(expressionPolicyRequest: ExpressionPolicyRequest) -> AnyPublisher<ExpressionPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/expression/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(expressionPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ExpressionPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ExpressionPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/expression/{policy_uuid}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Expression Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesExpressionDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/expression/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionListError: : \(object)"
            }
        }
    }

    /// - GET /policies/expression/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter created: (query)  (optional)
    /// - parameter executionLogging: (query)  (optional)
    /// - parameter expression: (query)  (optional)
    /// - parameter lastUpdated: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedExpressionPolicyList, Error> 
    open func policiesExpressionList(created: Date? = nil, executionLogging: Bool? = nil, expression: String? = nil, lastUpdated: Date? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyUuid: UUID? = nil, search: String? = nil) -> AnyPublisher<PaginatedExpressionPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/expression/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let executionLogging = executionLogging { queryItems.append(URLQueryItem(name: "execution_logging", value: executionLogging ? "true" : "false")) } 
                if let expression = expression { queryItems.append(URLQueryItem(name: "expression", value: expression)) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "last_updated", value: OpenISO8601DateFormatter.shared.string(from: lastUpdated))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyUuid = policyUuid { queryItems.append(URLQueryItem(name: "policy_uuid", value: policyUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedExpressionPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedExpressionPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/expression/{policy_uuid}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Expression Policy. 
    /// - parameter patchedExpressionPolicyRequest: (body)  (optional)
    /// - returns: AnyPublisher<ExpressionPolicy, Error> 
    open func policiesExpressionPartialUpdate(policyUuid: UUID, patchedExpressionPolicyRequest: PatchedExpressionPolicyRequest? = nil) -> AnyPublisher<ExpressionPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/expression/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedExpressionPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ExpressionPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ExpressionPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/expression/{policy_uuid}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Expression Policy. 
    /// - returns: AnyPublisher<ExpressionPolicy, Error> 
    open func policiesExpressionRetrieve(policyUuid: UUID) -> AnyPublisher<ExpressionPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/expression/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ExpressionPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ExpressionPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/expression/{policy_uuid}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Expression Policy. 
    /// - parameter expressionPolicyRequest: (body)  
    /// - returns: AnyPublisher<ExpressionPolicy, Error> 
    open func policiesExpressionUpdate(policyUuid: UUID, expressionPolicyRequest: ExpressionPolicyRequest) -> AnyPublisher<ExpressionPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/expression/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(expressionPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ExpressionPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ExpressionPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesExpressionUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesExpressionUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesExpressionUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/expression/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Expression Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesExpressionUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/expression/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesExpressionUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesExpressionUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/password/
    /// - Password Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter passwordPolicyRequest: (body)  
    /// - returns: AnyPublisher<PasswordPolicy, Error> 
    open func policiesPasswordCreate(passwordPolicyRequest: PasswordPolicyRequest) -> AnyPublisher<PasswordPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/password/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(passwordPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/password/{policy_uuid}/
    /// - Password Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesPasswordDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/password_expiry/
    /// - Password Expiry Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter passwordExpiryPolicyRequest: (body)  
    /// - returns: AnyPublisher<PasswordExpiryPolicy, Error> 
    open func policiesPasswordExpiryCreate(passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) -> AnyPublisher<PasswordExpiryPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/password_expiry/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(passwordExpiryPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordExpiryPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordExpiryPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/password_expiry/{policy_uuid}/
    /// - Password Expiry Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Expiry Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesPasswordExpiryDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password_expiry/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryListError: : \(object)"
            }
        }
    }

    /// - GET /policies/password_expiry/
    /// - Password Expiry Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter created: (query)  (optional)
    /// - parameter days: (query)  (optional)
    /// - parameter denyOnly: (query)  (optional)
    /// - parameter executionLogging: (query)  (optional)
    /// - parameter lastUpdated: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedPasswordExpiryPolicyList, Error> 
    open func policiesPasswordExpiryList(created: Date? = nil, days: Int? = nil, denyOnly: Bool? = nil, executionLogging: Bool? = nil, lastUpdated: Date? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyUuid: UUID? = nil, search: String? = nil) -> AnyPublisher<PaginatedPasswordExpiryPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/password_expiry/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let days = days { queryItems.append(URLQueryItem(name: "days", value: "\(days)")) } 
                if let denyOnly = denyOnly { queryItems.append(URLQueryItem(name: "deny_only", value: denyOnly ? "true" : "false")) } 
                if let executionLogging = executionLogging { queryItems.append(URLQueryItem(name: "execution_logging", value: executionLogging ? "true" : "false")) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "last_updated", value: OpenISO8601DateFormatter.shared.string(from: lastUpdated))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyUuid = policyUuid { queryItems.append(URLQueryItem(name: "policy_uuid", value: policyUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPasswordExpiryPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPasswordExpiryPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/password_expiry/{policy_uuid}/
    /// - Password Expiry Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Expiry Policy. 
    /// - parameter patchedPasswordExpiryPolicyRequest: (body)  (optional)
    /// - returns: AnyPublisher<PasswordExpiryPolicy, Error> 
    open func policiesPasswordExpiryPartialUpdate(policyUuid: UUID, patchedPasswordExpiryPolicyRequest: PatchedPasswordExpiryPolicyRequest? = nil) -> AnyPublisher<PasswordExpiryPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password_expiry/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPasswordExpiryPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordExpiryPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordExpiryPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/password_expiry/{policy_uuid}/
    /// - Password Expiry Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Expiry Policy. 
    /// - returns: AnyPublisher<PasswordExpiryPolicy, Error> 
    open func policiesPasswordExpiryRetrieve(policyUuid: UUID) -> AnyPublisher<PasswordExpiryPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password_expiry/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordExpiryPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordExpiryPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/password_expiry/{policy_uuid}/
    /// - Password Expiry Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Expiry Policy. 
    /// - parameter passwordExpiryPolicyRequest: (body)  
    /// - returns: AnyPublisher<PasswordExpiryPolicy, Error> 
    open func policiesPasswordExpiryUpdate(policyUuid: UUID, passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) -> AnyPublisher<PasswordExpiryPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password_expiry/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(passwordExpiryPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordExpiryPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordExpiryPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordExpiryUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordExpiryUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordExpiryUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/password_expiry/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Expiry Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesPasswordExpiryUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password_expiry/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordExpiryUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordExpiryUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordListError: : \(object)"
            }
        }
    }

    /// - GET /policies/password/
    /// - Password Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter amountDigits: (query)  (optional)
    /// - parameter amountLowercase: (query)  (optional)
    /// - parameter amountSymbols: (query)  (optional)
    /// - parameter amountUppercase: (query)  (optional)
    /// - parameter checkHaveIBeenPwned: (query)  (optional)
    /// - parameter checkStaticRules: (query)  (optional)
    /// - parameter checkZxcvbn: (query)  (optional)
    /// - parameter created: (query)  (optional)
    /// - parameter errorMessage: (query)  (optional)
    /// - parameter executionLogging: (query)  (optional)
    /// - parameter hibpAllowedCount: (query)  (optional)
    /// - parameter lastUpdated: (query)  (optional)
    /// - parameter lengthMin: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter passwordField: (query)  (optional)
    /// - parameter policyUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter symbolCharset: (query)  (optional)
    /// - parameter zxcvbnScoreThreshold: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedPasswordPolicyList, Error> 
    open func policiesPasswordList(amountDigits: Int? = nil, amountLowercase: Int? = nil, amountSymbols: Int? = nil, amountUppercase: Int? = nil, checkHaveIBeenPwned: Bool? = nil, checkStaticRules: Bool? = nil, checkZxcvbn: Bool? = nil, created: Date? = nil, errorMessage: String? = nil, executionLogging: Bool? = nil, hibpAllowedCount: Int? = nil, lastUpdated: Date? = nil, lengthMin: Int? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, passwordField: String? = nil, policyUuid: UUID? = nil, search: String? = nil, symbolCharset: String? = nil, zxcvbnScoreThreshold: Int? = nil) -> AnyPublisher<PaginatedPasswordPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/password/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let amountDigits = amountDigits { queryItems.append(URLQueryItem(name: "amount_digits", value: "\(amountDigits)")) } 
                if let amountLowercase = amountLowercase { queryItems.append(URLQueryItem(name: "amount_lowercase", value: "\(amountLowercase)")) } 
                if let amountSymbols = amountSymbols { queryItems.append(URLQueryItem(name: "amount_symbols", value: "\(amountSymbols)")) } 
                if let amountUppercase = amountUppercase { queryItems.append(URLQueryItem(name: "amount_uppercase", value: "\(amountUppercase)")) } 
                if let checkHaveIBeenPwned = checkHaveIBeenPwned { queryItems.append(URLQueryItem(name: "check_have_i_been_pwned", value: checkHaveIBeenPwned ? "true" : "false")) } 
                if let checkStaticRules = checkStaticRules { queryItems.append(URLQueryItem(name: "check_static_rules", value: checkStaticRules ? "true" : "false")) } 
                if let checkZxcvbn = checkZxcvbn { queryItems.append(URLQueryItem(name: "check_zxcvbn", value: checkZxcvbn ? "true" : "false")) } 
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let errorMessage = errorMessage { queryItems.append(URLQueryItem(name: "error_message", value: errorMessage)) } 
                if let executionLogging = executionLogging { queryItems.append(URLQueryItem(name: "execution_logging", value: executionLogging ? "true" : "false")) } 
                if let hibpAllowedCount = hibpAllowedCount { queryItems.append(URLQueryItem(name: "hibp_allowed_count", value: "\(hibpAllowedCount)")) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "last_updated", value: OpenISO8601DateFormatter.shared.string(from: lastUpdated))) } 
                if let lengthMin = lengthMin { queryItems.append(URLQueryItem(name: "length_min", value: "\(lengthMin)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let passwordField = passwordField { queryItems.append(URLQueryItem(name: "password_field", value: passwordField)) } 
                if let policyUuid = policyUuid { queryItems.append(URLQueryItem(name: "policy_uuid", value: policyUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let symbolCharset = symbolCharset { queryItems.append(URLQueryItem(name: "symbol_charset", value: symbolCharset)) } 
                if let zxcvbnScoreThreshold = zxcvbnScoreThreshold { queryItems.append(URLQueryItem(name: "zxcvbn_score_threshold", value: "\(zxcvbnScoreThreshold)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPasswordPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPasswordPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/password/{policy_uuid}/
    /// - Password Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Policy. 
    /// - parameter patchedPasswordPolicyRequest: (body)  (optional)
    /// - returns: AnyPublisher<PasswordPolicy, Error> 
    open func policiesPasswordPartialUpdate(policyUuid: UUID, patchedPasswordPolicyRequest: PatchedPasswordPolicyRequest? = nil) -> AnyPublisher<PasswordPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPasswordPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/password/{policy_uuid}/
    /// - Password Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Policy. 
    /// - returns: AnyPublisher<PasswordPolicy, Error> 
    open func policiesPasswordRetrieve(policyUuid: UUID) -> AnyPublisher<PasswordPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/password/{policy_uuid}/
    /// - Password Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Policy. 
    /// - parameter passwordPolicyRequest: (body)  
    /// - returns: AnyPublisher<PasswordPolicy, Error> 
    open func policiesPasswordUpdate(policyUuid: UUID, passwordPolicyRequest: PasswordPolicyRequest) -> AnyPublisher<PasswordPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(passwordPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesPasswordUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesPasswordUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesPasswordUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/password/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Password Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesPasswordUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/password/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesPasswordUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesPasswordUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationCreateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationCreateError: : \(object)"
            }
        }
    }

    /// - POST /policies/reputation/
    /// - Reputation Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter reputationPolicyRequest: (body)  
    /// - returns: AnyPublisher<ReputationPolicy, Error> 
    open func policiesReputationCreate(reputationPolicyRequest: ReputationPolicyRequest) -> AnyPublisher<ReputationPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/reputation/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(reputationPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ReputationPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ReputationPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/reputation/{policy_uuid}/
    /// - Reputation Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Reputation Policy. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesReputationDestroy(policyUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationListError: : \(object)"
            }
        }
    }

    /// - GET /policies/reputation/
    /// - Reputation Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter checkIp: (query)  (optional)
    /// - parameter checkUsername: (query)  (optional)
    /// - parameter created: (query)  (optional)
    /// - parameter executionLogging: (query)  (optional)
    /// - parameter lastUpdated: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter threshold: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedReputationPolicyList, Error> 
    open func policiesReputationList(checkIp: Bool? = nil, checkUsername: Bool? = nil, created: Date? = nil, executionLogging: Bool? = nil, lastUpdated: Date? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyUuid: UUID? = nil, search: String? = nil, threshold: Int? = nil) -> AnyPublisher<PaginatedReputationPolicyList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/reputation/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let checkIp = checkIp { queryItems.append(URLQueryItem(name: "check_ip", value: checkIp ? "true" : "false")) } 
                if let checkUsername = checkUsername { queryItems.append(URLQueryItem(name: "check_username", value: checkUsername ? "true" : "false")) } 
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let executionLogging = executionLogging { queryItems.append(URLQueryItem(name: "execution_logging", value: executionLogging ? "true" : "false")) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "last_updated", value: OpenISO8601DateFormatter.shared.string(from: lastUpdated))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyUuid = policyUuid { queryItems.append(URLQueryItem(name: "policy_uuid", value: policyUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let threshold = threshold { queryItems.append(URLQueryItem(name: "threshold", value: "\(threshold)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedReputationPolicyList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedReputationPolicyList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /policies/reputation/{policy_uuid}/
    /// - Reputation Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Reputation Policy. 
    /// - parameter patchedReputationPolicyRequest: (body)  (optional)
    /// - returns: AnyPublisher<ReputationPolicy, Error> 
    open func policiesReputationPartialUpdate(policyUuid: UUID, patchedReputationPolicyRequest: PatchedReputationPolicyRequest? = nil) -> AnyPublisher<ReputationPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedReputationPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ReputationPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ReputationPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/reputation/{policy_uuid}/
    /// - Reputation Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Reputation Policy. 
    /// - returns: AnyPublisher<ReputationPolicy, Error> 
    open func policiesReputationRetrieve(policyUuid: UUID) -> AnyPublisher<ReputationPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ReputationPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ReputationPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationScoresDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationScoresDestroyError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationScoresDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /policies/reputation/scores/{reputation_uuid}/
    /// - Reputation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter reputationUuid: (path) A UUID string identifying this Reputation Score. 
    /// - returns: AnyPublisher<Void, Error> 
    open func policiesReputationScoresDestroy(reputationUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/scores/{reputation_uuid}/"
                path = path.replacingOccurrences(of: "{reputation_uuid}", with: reputationUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationScoresDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationScoresDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationScoresListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationScoresListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationScoresListError: : \(object)"
            }
        }
    }

    /// - GET /policies/reputation/scores/
    /// - Reputation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter identifier: (query)  (optional)
    /// - parameter ip: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter score: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedReputationList, Error> 
    open func policiesReputationScoresList(identifier: String? = nil, ip: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, score: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedReputationList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/policies/reputation/scores/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let identifier = identifier { queryItems.append(URLQueryItem(name: "identifier", value: identifier)) } 
                if let ip = ip { queryItems.append(URLQueryItem(name: "ip", value: ip)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let score = score { queryItems.append(URLQueryItem(name: "score", value: "\(score)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedReputationList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationScoresListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationScoresListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedReputationList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationScoresRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationScoresRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationScoresRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /policies/reputation/scores/{reputation_uuid}/
    /// - Reputation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter reputationUuid: (path) A UUID string identifying this Reputation Score. 
    /// - returns: AnyPublisher<Reputation, Error> 
    open func policiesReputationScoresRetrieve(reputationUuid: UUID) -> AnyPublisher<Reputation, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/scores/{reputation_uuid}/"
                path = path.replacingOccurrences(of: "{reputation_uuid}", with: reputationUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Reputation, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationScoresRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationScoresRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Reputation.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationScoresUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationScoresUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationScoresUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/reputation/scores/{reputation_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter reputationUuid: (path) A UUID string identifying this Reputation Score. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesReputationScoresUsedByList(reputationUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/scores/{reputation_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{reputation_uuid}", with: reputationUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationScoresUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationScoresUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationUpdateError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /policies/reputation/{policy_uuid}/
    /// - Reputation Policy Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Reputation Policy. 
    /// - parameter reputationPolicyRequest: (body)  
    /// - returns: AnyPublisher<ReputationPolicy, Error> 
    open func policiesReputationUpdate(policyUuid: UUID, reputationPolicyRequest: ReputationPolicyRequest) -> AnyPublisher<ReputationPolicy, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/{policy_uuid}/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(reputationPolicyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ReputationPolicy, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ReputationPolicy.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PoliciesReputationUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PoliciesReputationUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PoliciesReputationUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /policies/reputation/{policy_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter policyUuid: (path) A UUID string identifying this Reputation Policy. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func policiesReputationUsedByList(policyUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/policies/reputation/{policy_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{policy_uuid}", with: policyUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PoliciesReputationUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PoliciesReputationUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
