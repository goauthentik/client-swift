//
// PropertymappingsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class PropertymappingsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum PropertymappingsAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /propertymappings/all/{pm_uuid}/
    /// - PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Property Mapping. 
    /// - returns: AnyPublisher<Void, Error> 
    open func propertymappingsAllDestroy(pmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/all/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsAllListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsAllListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/all/
    /// - PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter managedIsnull: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedPropertyMappingList, Error> 
    open func propertymappingsAllList(managedIsnull: Bool? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedPropertyMappingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let managedIsnull = managedIsnull { queryItems.append(URLQueryItem(name: "managed__isnull", value: managedIsnull ? "true" : "false")) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPropertyMappingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPropertyMappingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/all/{pm_uuid}/
    /// - PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Property Mapping. 
    /// - returns: AnyPublisher<PropertyMapping, Error> 
    open func propertymappingsAllRetrieve(pmUuid: UUID) -> AnyPublisher<PropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/all/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsAllTestCreateError: Error, CustomStringConvertible {
        // Invalid parameters
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "PropertymappingsAllTestCreateError: Invalid parameters"
            case .code403Error(let object):
                return "PropertymappingsAllTestCreateError: : \(object)"
            }
        }
    }

    /// - POST /propertymappings/all/{pm_uuid}/test/
    /// - Test Property Mapping
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Property Mapping. 
    /// - parameter policyTestRequest: (body)  
    /// - parameter formatResult: (query)  (optional)
    /// - returns: AnyPublisher<PropertyMappingTestResult, Error> 
    open func propertymappingsAllTestCreate(pmUuid: UUID, policyTestRequest: PolicyTestRequest, formatResult: Bool? = nil) -> AnyPublisher<PropertyMappingTestResult, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/all/{pm_uuid}/test/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let formatResult = formatResult { queryItems.append(URLQueryItem(name: "format_result", value: formatResult ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(policyTestRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PropertyMappingTestResult, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return PropertymappingsAllTestCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsAllTestCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PropertyMappingTestResult.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsAllTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsAllTypesListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsAllTypesListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/all/types/
    /// - Get all creatable property-mapping types
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func propertymappingsAllTypesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/all/types/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsAllTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsAllTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/all/{pm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Property Mapping. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func propertymappingsAllUsedByList(pmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/all/{pm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapCreateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapCreateError: : \(object)"
            }
        }
    }

    /// - POST /propertymappings/ldap/
    /// - LDAP PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter lDAPPropertyMappingRequest: (body)  
    /// - returns: AnyPublisher<LDAPPropertyMapping, Error> 
    open func propertymappingsLdapCreate(lDAPPropertyMappingRequest: LDAPPropertyMappingRequest) -> AnyPublisher<LDAPPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/ldap/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(lDAPPropertyMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapDestroyError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /propertymappings/ldap/{pm_uuid}/
    /// - LDAP PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this LDAP Property Mapping. 
    /// - returns: AnyPublisher<Void, Error> 
    open func propertymappingsLdapDestroy(pmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/ldap/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/ldap/
    /// - LDAP PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter expression: (query)  (optional)
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter objectField: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter pmUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedLDAPPropertyMappingList, Error> 
    open func propertymappingsLdapList(expression: String? = nil, managed: [String]? = nil, name: String? = nil, objectField: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, pmUuid: UUID? = nil, search: String? = nil) -> AnyPublisher<PaginatedLDAPPropertyMappingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/ldap/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let expression = expression { queryItems.append(URLQueryItem(name: "expression", value: expression)) } 
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed.joined(separator: ","))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let objectField = objectField { queryItems.append(URLQueryItem(name: "object_field", value: objectField)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let pmUuid = pmUuid { queryItems.append(URLQueryItem(name: "pm_uuid", value: pmUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedLDAPPropertyMappingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedLDAPPropertyMappingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /propertymappings/ldap/{pm_uuid}/
    /// - LDAP PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this LDAP Property Mapping. 
    /// - parameter patchedLDAPPropertyMappingRequest: (body)  (optional)
    /// - returns: AnyPublisher<LDAPPropertyMapping, Error> 
    open func propertymappingsLdapPartialUpdate(pmUuid: UUID, patchedLDAPPropertyMappingRequest: PatchedLDAPPropertyMappingRequest? = nil) -> AnyPublisher<LDAPPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/ldap/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedLDAPPropertyMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/ldap/{pm_uuid}/
    /// - LDAP PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this LDAP Property Mapping. 
    /// - returns: AnyPublisher<LDAPPropertyMapping, Error> 
    open func propertymappingsLdapRetrieve(pmUuid: UUID) -> AnyPublisher<LDAPPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/ldap/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /propertymappings/ldap/{pm_uuid}/
    /// - LDAP PropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this LDAP Property Mapping. 
    /// - parameter lDAPPropertyMappingRequest: (body)  
    /// - returns: AnyPublisher<LDAPPropertyMapping, Error> 
    open func propertymappingsLdapUpdate(pmUuid: UUID, lDAPPropertyMappingRequest: LDAPPropertyMappingRequest) -> AnyPublisher<LDAPPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/ldap/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(lDAPPropertyMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsLdapUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsLdapUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsLdapUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/ldap/{pm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this LDAP Property Mapping. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func propertymappingsLdapUsedByList(pmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/ldap/{pm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsLdapUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsLdapUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationCreateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationCreateError: : \(object)"
            }
        }
    }

    /// - POST /propertymappings/notification/
    /// - NotificationWebhookMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter notificationWebhookMappingRequest: (body)  
    /// - returns: AnyPublisher<NotificationWebhookMapping, Error> 
    open func propertymappingsNotificationCreate(notificationWebhookMappingRequest: NotificationWebhookMappingRequest) -> AnyPublisher<NotificationWebhookMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/notification/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(notificationWebhookMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationWebhookMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationWebhookMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationDestroyError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /propertymappings/notification/{pm_uuid}/
    /// - NotificationWebhookMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Webhook Mapping. 
    /// - returns: AnyPublisher<Void, Error> 
    open func propertymappingsNotificationDestroy(pmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/notification/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/notification/
    /// - NotificationWebhookMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedNotificationWebhookMappingList, Error> 
    open func propertymappingsNotificationList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedNotificationWebhookMappingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/notification/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedNotificationWebhookMappingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedNotificationWebhookMappingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /propertymappings/notification/{pm_uuid}/
    /// - NotificationWebhookMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Webhook Mapping. 
    /// - parameter patchedNotificationWebhookMappingRequest: (body)  (optional)
    /// - returns: AnyPublisher<NotificationWebhookMapping, Error> 
    open func propertymappingsNotificationPartialUpdate(pmUuid: UUID, patchedNotificationWebhookMappingRequest: PatchedNotificationWebhookMappingRequest? = nil) -> AnyPublisher<NotificationWebhookMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/notification/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedNotificationWebhookMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationWebhookMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationWebhookMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/notification/{pm_uuid}/
    /// - NotificationWebhookMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Webhook Mapping. 
    /// - returns: AnyPublisher<NotificationWebhookMapping, Error> 
    open func propertymappingsNotificationRetrieve(pmUuid: UUID) -> AnyPublisher<NotificationWebhookMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/notification/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationWebhookMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationWebhookMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /propertymappings/notification/{pm_uuid}/
    /// - NotificationWebhookMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Webhook Mapping. 
    /// - parameter notificationWebhookMappingRequest: (body)  
    /// - returns: AnyPublisher<NotificationWebhookMapping, Error> 
    open func propertymappingsNotificationUpdate(pmUuid: UUID, notificationWebhookMappingRequest: NotificationWebhookMappingRequest) -> AnyPublisher<NotificationWebhookMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/notification/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(notificationWebhookMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationWebhookMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationWebhookMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsNotificationUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsNotificationUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsNotificationUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/notification/{pm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Webhook Mapping. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func propertymappingsNotificationUsedByList(pmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/notification/{pm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsNotificationUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsNotificationUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlCreateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlCreateError: : \(object)"
            }
        }
    }

    /// - POST /propertymappings/saml/
    /// - SAMLPropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter sAMLPropertyMappingRequest: (body)  
    /// - returns: AnyPublisher<SAMLPropertyMapping, Error> 
    open func propertymappingsSamlCreate(sAMLPropertyMappingRequest: SAMLPropertyMappingRequest) -> AnyPublisher<SAMLPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/saml/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(sAMLPropertyMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlDestroyError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /propertymappings/saml/{pm_uuid}/
    /// - SAMLPropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SAML Property Mapping. 
    /// - returns: AnyPublisher<Void, Error> 
    open func propertymappingsSamlDestroy(pmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/saml/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/saml/
    /// - SAMLPropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter expression: (query)  (optional)
    /// - parameter friendlyName: (query)  (optional)
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter pmUuid: (query)  (optional)
    /// - parameter samlName: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedSAMLPropertyMappingList, Error> 
    open func propertymappingsSamlList(expression: String? = nil, friendlyName: String? = nil, managed: [String]? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, pmUuid: UUID? = nil, samlName: String? = nil, search: String? = nil) -> AnyPublisher<PaginatedSAMLPropertyMappingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/saml/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let expression = expression { queryItems.append(URLQueryItem(name: "expression", value: expression)) } 
                if let friendlyName = friendlyName { queryItems.append(URLQueryItem(name: "friendly_name", value: friendlyName)) } 
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed.joined(separator: ","))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let pmUuid = pmUuid { queryItems.append(URLQueryItem(name: "pm_uuid", value: pmUuid.uuidString)) } 
                if let samlName = samlName { queryItems.append(URLQueryItem(name: "saml_name", value: samlName)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSAMLPropertyMappingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSAMLPropertyMappingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /propertymappings/saml/{pm_uuid}/
    /// - SAMLPropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SAML Property Mapping. 
    /// - parameter patchedSAMLPropertyMappingRequest: (body)  (optional)
    /// - returns: AnyPublisher<SAMLPropertyMapping, Error> 
    open func propertymappingsSamlPartialUpdate(pmUuid: UUID, patchedSAMLPropertyMappingRequest: PatchedSAMLPropertyMappingRequest? = nil) -> AnyPublisher<SAMLPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/saml/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSAMLPropertyMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/saml/{pm_uuid}/
    /// - SAMLPropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SAML Property Mapping. 
    /// - returns: AnyPublisher<SAMLPropertyMapping, Error> 
    open func propertymappingsSamlRetrieve(pmUuid: UUID) -> AnyPublisher<SAMLPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/saml/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /propertymappings/saml/{pm_uuid}/
    /// - SAMLPropertyMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SAML Property Mapping. 
    /// - parameter sAMLPropertyMappingRequest: (body)  
    /// - returns: AnyPublisher<SAMLPropertyMapping, Error> 
    open func propertymappingsSamlUpdate(pmUuid: UUID, sAMLPropertyMappingRequest: SAMLPropertyMappingRequest) -> AnyPublisher<SAMLPropertyMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/saml/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sAMLPropertyMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLPropertyMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLPropertyMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsSamlUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsSamlUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsSamlUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/saml/{pm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SAML Property Mapping. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func propertymappingsSamlUsedByList(pmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/saml/{pm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsSamlUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsSamlUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimCreateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimCreateError: : \(object)"
            }
        }
    }

    /// - POST /propertymappings/scim/
    /// - SCIMMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter sCIMMappingRequest: (body)  
    /// - returns: AnyPublisher<SCIMMapping, Error> 
    open func propertymappingsScimCreate(sCIMMappingRequest: SCIMMappingRequest) -> AnyPublisher<SCIMMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/scim/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(sCIMMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimDestroyError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /propertymappings/scim/{pm_uuid}/
    /// - SCIMMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SCIM Mapping. 
    /// - returns: AnyPublisher<Void, Error> 
    open func propertymappingsScimDestroy(pmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scim/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/scim/
    /// - SCIMMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter expression: (query)  (optional)
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter pmUuid: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedSCIMMappingList, Error> 
    open func propertymappingsScimList(expression: String? = nil, managed: [String]? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, pmUuid: UUID? = nil, search: String? = nil) -> AnyPublisher<PaginatedSCIMMappingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/scim/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let expression = expression { queryItems.append(URLQueryItem(name: "expression", value: expression)) } 
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed.joined(separator: ","))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let pmUuid = pmUuid { queryItems.append(URLQueryItem(name: "pm_uuid", value: pmUuid.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSCIMMappingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSCIMMappingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /propertymappings/scim/{pm_uuid}/
    /// - SCIMMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SCIM Mapping. 
    /// - parameter patchedSCIMMappingRequest: (body)  (optional)
    /// - returns: AnyPublisher<SCIMMapping, Error> 
    open func propertymappingsScimPartialUpdate(pmUuid: UUID, patchedSCIMMappingRequest: PatchedSCIMMappingRequest? = nil) -> AnyPublisher<SCIMMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scim/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSCIMMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/scim/{pm_uuid}/
    /// - SCIMMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SCIM Mapping. 
    /// - returns: AnyPublisher<SCIMMapping, Error> 
    open func propertymappingsScimRetrieve(pmUuid: UUID) -> AnyPublisher<SCIMMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scim/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /propertymappings/scim/{pm_uuid}/
    /// - SCIMMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SCIM Mapping. 
    /// - parameter sCIMMappingRequest: (body)  
    /// - returns: AnyPublisher<SCIMMapping, Error> 
    open func propertymappingsScimUpdate(pmUuid: UUID, sCIMMappingRequest: SCIMMappingRequest) -> AnyPublisher<SCIMMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scim/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sCIMMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SCIMMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SCIMMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScimUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScimUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScimUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/scim/{pm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this SCIM Mapping. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func propertymappingsScimUsedByList(pmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scim/{pm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScimUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScimUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopeCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopeCreateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopeCreateError: : \(object)"
            }
        }
    }

    /// - POST /propertymappings/scope/
    /// - ScopeMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter scopeMappingRequest: (body)  
    /// - returns: AnyPublisher<ScopeMapping, Error> 
    open func propertymappingsScopeCreate(scopeMappingRequest: ScopeMappingRequest) -> AnyPublisher<ScopeMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/scope/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(scopeMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScopeMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopeCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopeCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ScopeMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopeDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopeDestroyError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopeDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /propertymappings/scope/{pm_uuid}/
    /// - ScopeMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Scope Mapping. 
    /// - returns: AnyPublisher<Void, Error> 
    open func propertymappingsScopeDestroy(pmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scope/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopeDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopeDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopeListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopeListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopeListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/scope/
    /// - ScopeMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter scopeName: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedScopeMappingList, Error> 
    open func propertymappingsScopeList(managed: [String]? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, scopeName: String? = nil, search: String? = nil) -> AnyPublisher<PaginatedScopeMappingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/propertymappings/scope/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed.joined(separator: ","))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let scopeName = scopeName { queryItems.append(URLQueryItem(name: "scope_name", value: scopeName)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedScopeMappingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopeListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopeListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedScopeMappingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /propertymappings/scope/{pm_uuid}/
    /// - ScopeMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Scope Mapping. 
    /// - parameter patchedScopeMappingRequest: (body)  (optional)
    /// - returns: AnyPublisher<ScopeMapping, Error> 
    open func propertymappingsScopePartialUpdate(pmUuid: UUID, patchedScopeMappingRequest: PatchedScopeMappingRequest? = nil) -> AnyPublisher<ScopeMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scope/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedScopeMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScopeMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ScopeMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopeRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopeRetrieveError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopeRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/scope/{pm_uuid}/
    /// - ScopeMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Scope Mapping. 
    /// - returns: AnyPublisher<ScopeMapping, Error> 
    open func propertymappingsScopeRetrieve(pmUuid: UUID) -> AnyPublisher<ScopeMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scope/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScopeMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopeRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopeRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ScopeMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopeUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopeUpdateError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopeUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /propertymappings/scope/{pm_uuid}/
    /// - ScopeMapping Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Scope Mapping. 
    /// - parameter scopeMappingRequest: (body)  
    /// - returns: AnyPublisher<ScopeMapping, Error> 
    open func propertymappingsScopeUpdate(pmUuid: UUID, scopeMappingRequest: ScopeMappingRequest) -> AnyPublisher<ScopeMapping, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scope/{pm_uuid}/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(scopeMappingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScopeMapping, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopeUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopeUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ScopeMapping.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PropertymappingsScopeUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PropertymappingsScopeUsedByListError: : \(object)"
            case .code403Error(let object):
                return "PropertymappingsScopeUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /propertymappings/scope/{pm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pmUuid: (path) A UUID string identifying this Scope Mapping. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func propertymappingsScopeUsedByList(pmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/propertymappings/scope/{pm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pm_uuid}", with: pmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return PropertymappingsScopeUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return PropertymappingsScopeUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
