//
// EventsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class EventsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum EventsEventsActionsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsActionsListError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsActionsListError: : \(object)"
            }
        }
    }

    /// - GET /events/events/actions/
    /// - Get all actions
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func eventsEventsActionsList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/events/actions/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsActionsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsActionsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsCreateError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsCreateError: : \(object)"
            }
        }
    }

    /// - POST /events/events/
    /// - Event Read-Only Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter eventRequest: (body)  
    /// - returns: AnyPublisher<Event, Error> 
    open func eventsEventsCreate(eventRequest: EventRequest) -> AnyPublisher<Event, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/events/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(eventRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Event, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Event.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsDestroyError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /events/events/{event_uuid}/
    /// - Event Read-Only Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter eventUuid: (path) A UUID string identifying this Event. 
    /// - returns: AnyPublisher<Void, Error> 
    open func eventsEventsDestroy(eventUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/events/{event_uuid}/"
                path = path.replacingOccurrences(of: "{event_uuid}", with: eventUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsListError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsListError: : \(object)"
            }
        }
    }

    /// - GET /events/events/
    /// - Event Read-Only Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter action: (query)  (optional)
    /// - parameter clientIp: (query)  (optional)
    /// - parameter contextAuthorizedApp: (query) Context Authorized application (optional)
    /// - parameter contextModelApp: (query) Context Model App (optional)
    /// - parameter contextModelName: (query) Context Model Name (optional)
    /// - parameter contextModelPk: (query) Context Model Primary Key (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter tenantName: (query) Tenant name (optional)
    /// - parameter username: (query) Username (optional)
    /// - returns: AnyPublisher<PaginatedEventList, Error> 
    open func eventsEventsList(action: String? = nil, clientIp: String? = nil, contextAuthorizedApp: String? = nil, contextModelApp: String? = nil, contextModelName: String? = nil, contextModelPk: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, tenantName: String? = nil, username: String? = nil) -> AnyPublisher<PaginatedEventList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/events/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action)) } 
                if let clientIp = clientIp { queryItems.append(URLQueryItem(name: "client_ip", value: clientIp)) } 
                if let contextAuthorizedApp = contextAuthorizedApp { queryItems.append(URLQueryItem(name: "context_authorized_app", value: contextAuthorizedApp)) } 
                if let contextModelApp = contextModelApp { queryItems.append(URLQueryItem(name: "context_model_app", value: contextModelApp)) } 
                if let contextModelName = contextModelName { queryItems.append(URLQueryItem(name: "context_model_name", value: contextModelName)) } 
                if let contextModelPk = contextModelPk { queryItems.append(URLQueryItem(name: "context_model_pk", value: contextModelPk)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let tenantName = tenantName { queryItems.append(URLQueryItem(name: "tenant_name", value: tenantName)) } 
                if let username = username { queryItems.append(URLQueryItem(name: "username", value: username)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedEventList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedEventList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /events/events/{event_uuid}/
    /// - Event Read-Only Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter eventUuid: (path) A UUID string identifying this Event. 
    /// - parameter patchedEventRequest: (body)  (optional)
    /// - returns: AnyPublisher<Event, Error> 
    open func eventsEventsPartialUpdate(eventUuid: UUID, patchedEventRequest: PatchedEventRequest? = nil) -> AnyPublisher<Event, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/events/{event_uuid}/"
                path = path.replacingOccurrences(of: "{event_uuid}", with: eventUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedEventRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Event, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Event.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsPerMonthListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsPerMonthListError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsPerMonthListError: : \(object)"
            }
        }
    }

    /// - GET /events/events/per_month/
    /// - Get the count of events per month
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter action: (query)  (optional)
    /// - parameter query: (query)  (optional)
    /// - returns: AnyPublisher<[Coordinate], Error> 
    open func eventsEventsPerMonthList(action: String? = nil, query: String? = nil) -> AnyPublisher<[Coordinate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/events/per_month/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action)) } 
                if let query = query { queryItems.append(URLQueryItem(name: "query", value: query)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Coordinate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsPerMonthListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsPerMonthListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([Coordinate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /events/events/{event_uuid}/
    /// - Event Read-Only Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter eventUuid: (path) A UUID string identifying this Event. 
    /// - returns: AnyPublisher<Event, Error> 
    open func eventsEventsRetrieve(eventUuid: UUID) -> AnyPublisher<Event, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/events/{event_uuid}/"
                path = path.replacingOccurrences(of: "{event_uuid}", with: eventUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Event, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Event.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsTopPerUserListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsTopPerUserListError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsTopPerUserListError: : \(object)"
            }
        }
    }

    /// - GET /events/events/top_per_user/
    /// - Get the top_n events grouped by user count
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter action: (query)  (optional)
    /// - parameter topN: (query)  (optional)
    /// - returns: AnyPublisher<[EventTopPerUser], Error> 
    open func eventsEventsTopPerUserList(action: String? = nil, topN: Int? = nil) -> AnyPublisher<[EventTopPerUser], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/events/top_per_user/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action)) } 
                if let topN = topN { queryItems.append(URLQueryItem(name: "top_n", value: "\(topN)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[EventTopPerUser], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsTopPerUserListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsTopPerUserListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([EventTopPerUser].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /events/events/{event_uuid}/
    /// - Event Read-Only Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter eventUuid: (path) A UUID string identifying this Event. 
    /// - parameter eventRequest: (body)  
    /// - returns: AnyPublisher<Event, Error> 
    open func eventsEventsUpdate(eventUuid: UUID, eventRequest: EventRequest) -> AnyPublisher<Event, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/events/{event_uuid}/"
                path = path.replacingOccurrences(of: "{event_uuid}", with: eventUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(eventRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Event, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Event.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsEventsVolumeListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsEventsVolumeListError: : \(object)"
            case .code403Error(let object):
                return "EventsEventsVolumeListError: : \(object)"
            }
        }
    }

    /// - GET /events/events/volume/
    /// - Get event volume for specified filters and timeframe
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter action: (query)  (optional)
    /// - parameter clientIp: (query)  (optional)
    /// - parameter contextAuthorizedApp: (query) Context Authorized application (optional)
    /// - parameter contextModelApp: (query) Context Model App (optional)
    /// - parameter contextModelName: (query) Context Model Name (optional)
    /// - parameter contextModelPk: (query) Context Model Primary Key (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter tenantName: (query) Tenant name (optional)
    /// - parameter username: (query) Username (optional)
    /// - returns: AnyPublisher<[Coordinate], Error> 
    open func eventsEventsVolumeList(action: String? = nil, clientIp: String? = nil, contextAuthorizedApp: String? = nil, contextModelApp: String? = nil, contextModelName: String? = nil, contextModelPk: String? = nil, ordering: String? = nil, search: String? = nil, tenantName: String? = nil, username: String? = nil) -> AnyPublisher<[Coordinate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/events/volume/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action)) } 
                if let clientIp = clientIp { queryItems.append(URLQueryItem(name: "client_ip", value: clientIp)) } 
                if let contextAuthorizedApp = contextAuthorizedApp { queryItems.append(URLQueryItem(name: "context_authorized_app", value: contextAuthorizedApp)) } 
                if let contextModelApp = contextModelApp { queryItems.append(URLQueryItem(name: "context_model_app", value: contextModelApp)) } 
                if let contextModelName = contextModelName { queryItems.append(URLQueryItem(name: "context_model_name", value: contextModelName)) } 
                if let contextModelPk = contextModelPk { queryItems.append(URLQueryItem(name: "context_model_pk", value: contextModelPk)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let tenantName = tenantName { queryItems.append(URLQueryItem(name: "tenant_name", value: tenantName)) } 
                if let username = username { queryItems.append(URLQueryItem(name: "username", value: username)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Coordinate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsEventsVolumeListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsEventsVolumeListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([Coordinate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsNotificationsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsDestroyError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /events/notifications/{uuid}/
    /// - Notification Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification. 
    /// - returns: AnyPublisher<Void, Error> 
    open func eventsNotificationsDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/notifications/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter severity
    ///
    public enum EventsNotificationsListSeverity: String, Codable, CaseIterable {
        case alert = "alert"
        case notice = "notice"
        case warning = "warning"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum EventsNotificationsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsListError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsListError: : \(object)"
            }
        }
    }

    /// - GET /events/notifications/
    /// - Notification Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter body: (query)  (optional)
    /// - parameter created: (query)  (optional)
    /// - parameter event: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter seen: (query)  (optional)
    /// - parameter severity: (query) * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
    /// - parameter user: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedNotificationList, Error> 
    open func eventsNotificationsList(body: String? = nil, created: Date? = nil, event: UUID? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, seen: Bool? = nil, severity: EventsNotificationsListSeverity? = nil, user: Int? = nil) -> AnyPublisher<PaginatedNotificationList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/notifications/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let body = body { queryItems.append(URLQueryItem(name: "body", value: body)) } 
                if let created = created { queryItems.append(URLQueryItem(name: "created", value: OpenISO8601DateFormatter.shared.string(from: created))) } 
                if let event = event { queryItems.append(URLQueryItem(name: "event", value: event.uuidString)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let seen = seen { queryItems.append(URLQueryItem(name: "seen", value: seen ? "true" : "false")) } 
                if let severity = severity { queryItems.append(URLQueryItem(name: "severity", value: severity.rawValue)) } 
                if let user = user { queryItems.append(URLQueryItem(name: "user", value: "\(user)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedNotificationList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedNotificationList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsNotificationsMarkAllSeenCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsMarkAllSeenCreateError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsMarkAllSeenCreateError: : \(object)"
            }
        }
    }

    /// - POST /events/notifications/mark_all_seen/
    /// - Mark all the user's notifications as seen
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<Void, Error> 
    open func eventsNotificationsMarkAllSeenCreate() -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/notifications/mark_all_seen/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsMarkAllSeenCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsMarkAllSeenCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsNotificationsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /events/notifications/{uuid}/
    /// - Notification Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification. 
    /// - parameter patchedNotificationRequest: (body)  (optional)
    /// - returns: AnyPublisher<Notification, Error> 
    open func eventsNotificationsPartialUpdate(uuid: UUID, patchedNotificationRequest: PatchedNotificationRequest? = nil) -> AnyPublisher<Notification, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/notifications/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedNotificationRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Notification, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Notification.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsNotificationsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /events/notifications/{uuid}/
    /// - Notification Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification. 
    /// - returns: AnyPublisher<Notification, Error> 
    open func eventsNotificationsRetrieve(uuid: UUID) -> AnyPublisher<Notification, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/notifications/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Notification, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Notification.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsNotificationsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /events/notifications/{uuid}/
    /// - Notification Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification. 
    /// - parameter notificationRequest: (body)  (optional)
    /// - returns: AnyPublisher<Notification, Error> 
    open func eventsNotificationsUpdate(uuid: UUID, notificationRequest: NotificationRequest? = nil) -> AnyPublisher<Notification, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/notifications/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(notificationRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Notification, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Notification.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsNotificationsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsNotificationsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "EventsNotificationsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /events/notifications/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func eventsNotificationsUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/notifications/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsNotificationsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsNotificationsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsRulesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesCreateError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesCreateError: : \(object)"
            }
        }
    }

    /// - POST /events/rules/
    /// - NotificationRule Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter notificationRuleRequest: (body)  
    /// - returns: AnyPublisher<NotificationRule, Error> 
    open func eventsRulesCreate(notificationRuleRequest: NotificationRuleRequest) -> AnyPublisher<NotificationRule, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/rules/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(notificationRuleRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationRule, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationRule.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsRulesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesDestroyError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /events/rules/{pbm_uuid}/
    /// - NotificationRule Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pbmUuid: (path) A UUID string identifying this Notification Rule. 
    /// - returns: AnyPublisher<Void, Error> 
    open func eventsRulesDestroy(pbmUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/rules/{pbm_uuid}/"
                path = path.replacingOccurrences(of: "{pbm_uuid}", with: pbmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter severity
    ///
    public enum EventsRulesListSeverity: String, Codable, CaseIterable {
        case alert = "alert"
        case notice = "notice"
        case warning = "warning"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum EventsRulesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesListError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesListError: : \(object)"
            }
        }
    }

    /// - GET /events/rules/
    /// - NotificationRule Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter groupName: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter severity: (query) Controls which severity level the created notifications will have.  * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
    /// - returns: AnyPublisher<PaginatedNotificationRuleList, Error> 
    open func eventsRulesList(groupName: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, severity: EventsRulesListSeverity? = nil) -> AnyPublisher<PaginatedNotificationRuleList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/rules/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let groupName = groupName { queryItems.append(URLQueryItem(name: "group__name", value: groupName)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let severity = severity { queryItems.append(URLQueryItem(name: "severity", value: severity.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedNotificationRuleList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedNotificationRuleList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsRulesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /events/rules/{pbm_uuid}/
    /// - NotificationRule Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pbmUuid: (path) A UUID string identifying this Notification Rule. 
    /// - parameter patchedNotificationRuleRequest: (body)  (optional)
    /// - returns: AnyPublisher<NotificationRule, Error> 
    open func eventsRulesPartialUpdate(pbmUuid: UUID, patchedNotificationRuleRequest: PatchedNotificationRuleRequest? = nil) -> AnyPublisher<NotificationRule, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/rules/{pbm_uuid}/"
                path = path.replacingOccurrences(of: "{pbm_uuid}", with: pbmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedNotificationRuleRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationRule, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationRule.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsRulesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /events/rules/{pbm_uuid}/
    /// - NotificationRule Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pbmUuid: (path) A UUID string identifying this Notification Rule. 
    /// - returns: AnyPublisher<NotificationRule, Error> 
    open func eventsRulesRetrieve(pbmUuid: UUID) -> AnyPublisher<NotificationRule, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/rules/{pbm_uuid}/"
                path = path.replacingOccurrences(of: "{pbm_uuid}", with: pbmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationRule, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationRule.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsRulesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /events/rules/{pbm_uuid}/
    /// - NotificationRule Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pbmUuid: (path) A UUID string identifying this Notification Rule. 
    /// - parameter notificationRuleRequest: (body)  
    /// - returns: AnyPublisher<NotificationRule, Error> 
    open func eventsRulesUpdate(pbmUuid: UUID, notificationRuleRequest: NotificationRuleRequest) -> AnyPublisher<NotificationRule, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/rules/{pbm_uuid}/"
                path = path.replacingOccurrences(of: "{pbm_uuid}", with: pbmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(notificationRuleRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationRule, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationRule.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsRulesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsRulesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "EventsRulesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /events/rules/{pbm_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter pbmUuid: (path) A UUID string identifying this Notification Rule. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func eventsRulesUsedByList(pbmUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/rules/{pbm_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{pbm_uuid}", with: pbmUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsRulesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsRulesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsCreateError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsCreateError: : \(object)"
            }
        }
    }

    /// - POST /events/transports/
    /// - NotificationTransport Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter notificationTransportRequest: (body)  
    /// - returns: AnyPublisher<NotificationTransport, Error> 
    open func eventsTransportsCreate(notificationTransportRequest: NotificationTransportRequest) -> AnyPublisher<NotificationTransport, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/transports/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(notificationTransportRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTransport, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationTransport.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsDestroyError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /events/transports/{uuid}/
    /// - NotificationTransport Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification Transport. 
    /// - returns: AnyPublisher<Void, Error> 
    open func eventsTransportsDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/transports/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter mode
    ///
    public enum EventsTransportsListMode: String, Codable, CaseIterable {
        case email = "email"
        case local = "local"
        case webhook = "webhook"
        case webhookSlack = "webhook_slack"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum EventsTransportsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsListError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsListError: : \(object)"
            }
        }
    }

    /// - GET /events/transports/
    /// - NotificationTransport Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter mode: (query) * &#x60;local&#x60; - authentik inbuilt notifications * &#x60;webhook&#x60; - Generic Webhook * &#x60;webhook_slack&#x60; - Slack Webhook (Slack/Discord) * &#x60;email&#x60; - Email (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter sendOnce: (query)  (optional)
    /// - parameter webhookUrl: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedNotificationTransportList, Error> 
    open func eventsTransportsList(mode: EventsTransportsListMode? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, sendOnce: Bool? = nil, webhookUrl: String? = nil) -> AnyPublisher<PaginatedNotificationTransportList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/events/transports/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let mode = mode { queryItems.append(URLQueryItem(name: "mode", value: mode.rawValue)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let sendOnce = sendOnce { queryItems.append(URLQueryItem(name: "send_once", value: sendOnce ? "true" : "false")) } 
                if let webhookUrl = webhookUrl { queryItems.append(URLQueryItem(name: "webhook_url", value: webhookUrl)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedNotificationTransportList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedNotificationTransportList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /events/transports/{uuid}/
    /// - NotificationTransport Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification Transport. 
    /// - parameter patchedNotificationTransportRequest: (body)  (optional)
    /// - returns: AnyPublisher<NotificationTransport, Error> 
    open func eventsTransportsPartialUpdate(uuid: UUID, patchedNotificationTransportRequest: PatchedNotificationTransportRequest? = nil) -> AnyPublisher<NotificationTransport, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/transports/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedNotificationTransportRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTransport, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationTransport.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /events/transports/{uuid}/
    /// - NotificationTransport Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification Transport. 
    /// - returns: AnyPublisher<NotificationTransport, Error> 
    open func eventsTransportsRetrieve(uuid: UUID) -> AnyPublisher<NotificationTransport, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/transports/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTransport, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationTransport.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsTestCreateError: Error, CustomStringConvertible {
        // Failed to test transport
        case code500Error
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code500Error:
                return "EventsTransportsTestCreateError: Failed to test transport"
            case .code400Error(let object):
                return "EventsTransportsTestCreateError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsTestCreateError: : \(object)"
            }
        }
    }

    /// - POST /events/transports/{uuid}/test/
    /// - Send example notification using selected transport. Requires Modify permissions.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification Transport. 
    /// - returns: AnyPublisher<NotificationTransportTest, Error> 
    open func eventsTransportsTestCreate(uuid: UUID) -> AnyPublisher<NotificationTransportTest, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/transports/{uuid}/test/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTransportTest, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 500 {
                        return EventsTransportsTestCreateError.code500Error
                    }
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsTestCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsTestCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationTransportTest.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsUpdateError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /events/transports/{uuid}/
    /// - NotificationTransport Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification Transport. 
    /// - parameter notificationTransportRequest: (body)  
    /// - returns: AnyPublisher<NotificationTransport, Error> 
    open func eventsTransportsUpdate(uuid: UUID, notificationTransportRequest: NotificationTransportRequest) -> AnyPublisher<NotificationTransport, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/transports/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(notificationTransportRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTransport, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(NotificationTransport.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum EventsTransportsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "EventsTransportsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "EventsTransportsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /events/transports/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Notification Transport. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func eventsTransportsUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/events/transports/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return EventsTransportsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return EventsTransportsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
