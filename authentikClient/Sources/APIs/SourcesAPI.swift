//
// SourcesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class SourcesAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum SourcesAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/all/{slug}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesAllDestroy(slug: String) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/all/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesAllListError: : \(object)"
            case .code403Error(let object):
                return "SourcesAllListError: : \(object)"
            }
        }
    }

    /// - GET /sources/all/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter slug: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedSourceList, Error> 
    open func sourcesAllList(managed: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, slug: String? = nil) -> AnyPublisher<PaginatedSourceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSourceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSourceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/all/{slug}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Source, Error> 
    open func sourcesAllRetrieve(slug: String) -> AnyPublisher<Source, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/all/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Source, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Source.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllSetIconCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "SourcesAllSetIconCreateError: Bad request"
            case .code403Error(let object):
                return "SourcesAllSetIconCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/all/{slug}/set_icon/
    /// - Set source icon
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter file: (form)  (optional)
    /// - parameter clear: (form)  (optional, default to false)
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesAllSetIconCreate(slug: String, file: Data? = nil, clear: Bool? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/all/{slug}/set_icon/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                let multipartBoundary = String(format: "Boundary+%08X%08X", arc4random(), arc4random())
                var multipartData = Data()
				if let file = file {
					let fileHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"file\"; filename=\"file\"\r\n")
					    .appending("\r\n")
					multipartData.append(fileHeader.data(using: .utf8) ?? Data())
					multipartData.append(file)
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let clear = clear {
					let clearHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"clear\"\r\n")
					    .appending("\r\n")
					multipartData.append(clearHeader.data(using: .utf8) ?? Data())
					multipartData.append()
				}

                multipartData.append("\r\n--\(multipartBoundary)--\r\n".data(using: .utf8) ?? Data())
                request.httpBody = multipartData
                request.setValue("\(multipartData.count)", forHTTPHeaderField: "Content-Length")
                request.setValue("multipart/form-data; boundary=\(multipartBoundary)", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return SourcesAllSetIconCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllSetIconCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllSetIconUrlCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "SourcesAllSetIconUrlCreateError: Bad request"
            case .code403Error(let object):
                return "SourcesAllSetIconUrlCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/all/{slug}/set_icon_url/
    /// - Set source icon (as URL)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter filePathRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesAllSetIconUrlCreate(slug: String, filePathRequest: FilePathRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/all/{slug}/set_icon_url/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(filePathRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return SourcesAllSetIconUrlCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllSetIconUrlCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesAllTypesListError: : \(object)"
            case .code403Error(let object):
                return "SourcesAllTypesListError: : \(object)"
            }
        }
    }

    /// - GET /sources/all/types/
    /// - Get all creatable source types
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func sourcesAllTypesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/all/types/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesAllTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/all/{slug}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesAllUsedByList(slug: String) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/all/{slug}/used_by/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesAllUserSettingsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesAllUserSettingsListError: : \(object)"
            case .code403Error(let object):
                return "SourcesAllUserSettingsListError: : \(object)"
            }
        }
    }

    /// - GET /sources/all/user_settings/
    /// - Get all sources the user can configure
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[UserSetting], Error> 
    open func sourcesAllUserSettingsList() -> AnyPublisher<[UserSetting], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/all/user_settings/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UserSetting], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesAllUserSettingsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesAllUserSettingsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UserSetting].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/ldap/
    /// - LDAP Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter lDAPSourceRequest: (body)  
    /// - returns: AnyPublisher<LDAPSource, Error> 
    open func sourcesLdapCreate(lDAPSourceRequest: LDAPSourceRequest) -> AnyPublisher<LDAPSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/ldap/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(lDAPSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapDebugRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapDebugRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapDebugRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/ldap/{slug}/debug/
    /// - Get raw LDAP data to debug
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<LDAPDebug, Error> 
    open func sourcesLdapDebugRetrieve(slug: String) -> AnyPublisher<LDAPDebug, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/debug/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPDebug, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapDebugRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapDebugRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPDebug.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/ldap/{slug}/
    /// - LDAP Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesLdapDestroy(slug: String) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapListError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapListError: : \(object)"
            }
        }
    }

    /// - GET /sources/ldap/
    /// - LDAP Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter additionalGroupDn: (query)  (optional)
    /// - parameter additionalUserDn: (query)  (optional)
    /// - parameter baseDn: (query)  (optional)
    /// - parameter bindCn: (query)  (optional)
    /// - parameter clientCertificate: (query)  (optional)
    /// - parameter enabled: (query)  (optional)
    /// - parameter groupMembershipField: (query)  (optional)
    /// - parameter groupObjectFilter: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter objectUniquenessField: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter peerCertificate: (query)  (optional)
    /// - parameter propertyMappings: (query)  (optional)
    /// - parameter propertyMappingsGroup: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter serverUri: (query)  (optional)
    /// - parameter slug: (query)  (optional)
    /// - parameter sni: (query)  (optional)
    /// - parameter startTls: (query)  (optional)
    /// - parameter syncGroups: (query)  (optional)
    /// - parameter syncParentGroup: (query)  (optional)
    /// - parameter syncUsers: (query)  (optional)
    /// - parameter syncUsersPassword: (query)  (optional)
    /// - parameter userObjectFilter: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedLDAPSourceList, Error> 
    open func sourcesLdapList(additionalGroupDn: String? = nil, additionalUserDn: String? = nil, baseDn: String? = nil, bindCn: String? = nil, clientCertificate: UUID? = nil, enabled: Bool? = nil, groupMembershipField: String? = nil, groupObjectFilter: String? = nil, name: String? = nil, objectUniquenessField: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, peerCertificate: UUID? = nil, propertyMappings: [UUID]? = nil, propertyMappingsGroup: [UUID]? = nil, search: String? = nil, serverUri: String? = nil, slug: String? = nil, sni: Bool? = nil, startTls: Bool? = nil, syncGroups: Bool? = nil, syncParentGroup: UUID? = nil, syncUsers: Bool? = nil, syncUsersPassword: Bool? = nil, userObjectFilter: String? = nil) -> AnyPublisher<PaginatedLDAPSourceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/ldap/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let additionalGroupDn = additionalGroupDn { queryItems.append(URLQueryItem(name: "additional_group_dn", value: additionalGroupDn)) } 
                if let additionalUserDn = additionalUserDn { queryItems.append(URLQueryItem(name: "additional_user_dn", value: additionalUserDn)) } 
                if let baseDn = baseDn { queryItems.append(URLQueryItem(name: "base_dn", value: baseDn)) } 
                if let bindCn = bindCn { queryItems.append(URLQueryItem(name: "bind_cn", value: bindCn)) } 
                if let clientCertificate = clientCertificate { queryItems.append(URLQueryItem(name: "client_certificate", value: clientCertificate.uuidString)) } 
                if let enabled = enabled { queryItems.append(URLQueryItem(name: "enabled", value: enabled ? "true" : "false")) } 
                if let groupMembershipField = groupMembershipField { queryItems.append(URLQueryItem(name: "group_membership_field", value: groupMembershipField)) } 
                if let groupObjectFilter = groupObjectFilter { queryItems.append(URLQueryItem(name: "group_object_filter", value: groupObjectFilter)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let objectUniquenessField = objectUniquenessField { queryItems.append(URLQueryItem(name: "object_uniqueness_field", value: objectUniquenessField)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let peerCertificate = peerCertificate { queryItems.append(URLQueryItem(name: "peer_certificate", value: peerCertificate.uuidString)) } 
                if let propertyMappings = propertyMappings { queryItems.append(URLQueryItem(name: "property_mappings", value: propertyMappings.map { $0.uuidString }.joined(separator: ","))) } 
                if let propertyMappingsGroup = propertyMappingsGroup { queryItems.append(URLQueryItem(name: "property_mappings_group", value: propertyMappingsGroup.map { $0.uuidString }.joined(separator: ","))) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let serverUri = serverUri { queryItems.append(URLQueryItem(name: "server_uri", value: serverUri)) } 
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                if let sni = sni { queryItems.append(URLQueryItem(name: "sni", value: sni ? "true" : "false")) } 
                if let startTls = startTls { queryItems.append(URLQueryItem(name: "start_tls", value: startTls ? "true" : "false")) } 
                if let syncGroups = syncGroups { queryItems.append(URLQueryItem(name: "sync_groups", value: syncGroups ? "true" : "false")) } 
                if let syncParentGroup = syncParentGroup { queryItems.append(URLQueryItem(name: "sync_parent_group", value: syncParentGroup.uuidString)) } 
                if let syncUsers = syncUsers { queryItems.append(URLQueryItem(name: "sync_users", value: syncUsers ? "true" : "false")) } 
                if let syncUsersPassword = syncUsersPassword { queryItems.append(URLQueryItem(name: "sync_users_password", value: syncUsersPassword ? "true" : "false")) } 
                if let userObjectFilter = userObjectFilter { queryItems.append(URLQueryItem(name: "user_object_filter", value: userObjectFilter)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedLDAPSourceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedLDAPSourceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/ldap/{slug}/
    /// - LDAP Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter patchedLDAPSourceRequest: (body)  (optional)
    /// - returns: AnyPublisher<LDAPSource, Error> 
    open func sourcesLdapPartialUpdate(slug: String, patchedLDAPSourceRequest: PatchedLDAPSourceRequest? = nil) -> AnyPublisher<LDAPSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedLDAPSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/ldap/{slug}/
    /// - LDAP Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<LDAPSource, Error> 
    open func sourcesLdapRetrieve(slug: String) -> AnyPublisher<LDAPSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapSyncStatusRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapSyncStatusRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapSyncStatusRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/ldap/{slug}/sync_status/
    /// - Get source's sync status
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<LDAPSyncStatus, Error> 
    open func sourcesLdapSyncStatusRetrieve(slug: String) -> AnyPublisher<LDAPSyncStatus, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/sync_status/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPSyncStatus, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapSyncStatusRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapSyncStatusRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPSyncStatus.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/ldap/{slug}/
    /// - LDAP Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter lDAPSourceRequest: (body)  
    /// - returns: AnyPublisher<LDAPSource, Error> 
    open func sourcesLdapUpdate(slug: String, lDAPSourceRequest: LDAPSourceRequest) -> AnyPublisher<LDAPSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(lDAPSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LDAPSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(LDAPSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesLdapUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesLdapUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesLdapUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/ldap/{slug}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesLdapUsedByList(slug: String) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/ldap/{slug}/used_by/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesLdapUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesLdapUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/oauth/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter oAuthSourceRequest: (body)  
    /// - returns: AnyPublisher<OAuthSource, Error> 
    open func sourcesOauthCreate(oAuthSourceRequest: OAuthSourceRequest) -> AnyPublisher<OAuthSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/oauth/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(oAuthSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuthSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuthSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/oauth/{slug}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesOauthDestroy(slug: String) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/oauth/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter policyEngineMode
    ///
    public enum SourcesOauthListPolicyEngineMode: String, Codable, CaseIterable {
        case all = "all"
        case any = "any"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter userMatchingMode
    ///
    public enum SourcesOauthListUserMatchingMode: String, Codable, CaseIterable {
        case emailDeny = "email_deny"
        case emailLink = "email_link"
        case identifier = "identifier"
        case usernameDeny = "username_deny"
        case usernameLink = "username_link"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum SourcesOauthListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthListError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthListError: : \(object)"
            }
        }
    }

    /// - GET /sources/oauth/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter accessTokenUrl: (query)  (optional)
    /// - parameter additionalScopes: (query)  (optional)
    /// - parameter authenticationFlow: (query)  (optional)
    /// - parameter authorizationUrl: (query)  (optional)
    /// - parameter consumerKey: (query)  (optional)
    /// - parameter enabled: (query)  (optional)
    /// - parameter enrollmentFlow: (query)  (optional)
    /// - parameter hasJwks: (query) Only return sources with JWKS data (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyEngineMode: (query) * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
    /// - parameter profileUrl: (query)  (optional)
    /// - parameter providerType: (query)  (optional)
    /// - parameter requestTokenUrl: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter slug: (query)  (optional)
    /// - parameter userMatchingMode: (query) How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
    /// - returns: AnyPublisher<PaginatedOAuthSourceList, Error> 
    open func sourcesOauthList(accessTokenUrl: String? = nil, additionalScopes: String? = nil, authenticationFlow: UUID? = nil, authorizationUrl: String? = nil, consumerKey: String? = nil, enabled: Bool? = nil, enrollmentFlow: UUID? = nil, hasJwks: Bool? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyEngineMode: SourcesOauthListPolicyEngineMode? = nil, profileUrl: String? = nil, providerType: String? = nil, requestTokenUrl: String? = nil, search: String? = nil, slug: String? = nil, userMatchingMode: SourcesOauthListUserMatchingMode? = nil) -> AnyPublisher<PaginatedOAuthSourceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/oauth/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accessTokenUrl = accessTokenUrl { queryItems.append(URLQueryItem(name: "access_token_url", value: accessTokenUrl)) } 
                if let additionalScopes = additionalScopes { queryItems.append(URLQueryItem(name: "additional_scopes", value: additionalScopes)) } 
                if let authenticationFlow = authenticationFlow { queryItems.append(URLQueryItem(name: "authentication_flow", value: authenticationFlow.uuidString)) } 
                if let authorizationUrl = authorizationUrl { queryItems.append(URLQueryItem(name: "authorization_url", value: authorizationUrl)) } 
                if let consumerKey = consumerKey { queryItems.append(URLQueryItem(name: "consumer_key", value: consumerKey)) } 
                if let enabled = enabled { queryItems.append(URLQueryItem(name: "enabled", value: enabled ? "true" : "false")) } 
                if let enrollmentFlow = enrollmentFlow { queryItems.append(URLQueryItem(name: "enrollment_flow", value: enrollmentFlow.uuidString)) } 
                if let hasJwks = hasJwks { queryItems.append(URLQueryItem(name: "has_jwks", value: hasJwks ? "true" : "false")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyEngineMode = policyEngineMode { queryItems.append(URLQueryItem(name: "policy_engine_mode", value: policyEngineMode.rawValue)) } 
                if let profileUrl = profileUrl { queryItems.append(URLQueryItem(name: "profile_url", value: profileUrl)) } 
                if let providerType = providerType { queryItems.append(URLQueryItem(name: "provider_type", value: providerType)) } 
                if let requestTokenUrl = requestTokenUrl { queryItems.append(URLQueryItem(name: "request_token_url", value: requestTokenUrl)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                if let userMatchingMode = userMatchingMode { queryItems.append(URLQueryItem(name: "user_matching_mode", value: userMatchingMode.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedOAuthSourceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedOAuthSourceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/oauth/{slug}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter patchedOAuthSourceRequest: (body)  (optional)
    /// - returns: AnyPublisher<OAuthSource, Error> 
    open func sourcesOauthPartialUpdate(slug: String, patchedOAuthSourceRequest: PatchedOAuthSourceRequest? = nil) -> AnyPublisher<OAuthSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/oauth/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedOAuthSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuthSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuthSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/oauth/{slug}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<OAuthSource, Error> 
    open func sourcesOauthRetrieve(slug: String) -> AnyPublisher<OAuthSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/oauth/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuthSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuthSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthSourceTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthSourceTypesListError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthSourceTypesListError: : \(object)"
            }
        }
    }

    /// - GET /sources/oauth/source_types/
    /// - Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn't found, returns the default type.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - returns: AnyPublisher<[SourceType], Error> 
    open func sourcesOauthSourceTypesList(name: String? = nil) -> AnyPublisher<[SourceType], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/oauth/source_types/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[SourceType], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthSourceTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthSourceTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([SourceType].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/oauth/{slug}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter oAuthSourceRequest: (body)  
    /// - returns: AnyPublisher<OAuthSource, Error> 
    open func sourcesOauthUpdate(slug: String, oAuthSourceRequest: OAuthSourceRequest) -> AnyPublisher<OAuthSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/oauth/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(oAuthSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OAuthSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(OAuthSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesOauthUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesOauthUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesOauthUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/oauth/{slug}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesOauthUsedByList(slug: String) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/oauth/{slug}/used_by/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesOauthUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesOauthUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/plex/
    /// - Plex source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter plexSourceRequest: (body)  
    /// - returns: AnyPublisher<PlexSource, Error> 
    open func sourcesPlexCreate(plexSourceRequest: PlexSourceRequest) -> AnyPublisher<PlexSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/plex/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(plexSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/plex/{slug}/
    /// - Plex source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesPlexDestroy(slug: String) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/plex/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter policyEngineMode
    ///
    public enum SourcesPlexListPolicyEngineMode: String, Codable, CaseIterable {
        case all = "all"
        case any = "any"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter userMatchingMode
    ///
    public enum SourcesPlexListUserMatchingMode: String, Codable, CaseIterable {
        case emailDeny = "email_deny"
        case emailLink = "email_link"
        case identifier = "identifier"
        case usernameDeny = "username_deny"
        case usernameLink = "username_link"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum SourcesPlexListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexListError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexListError: : \(object)"
            }
        }
    }

    /// - GET /sources/plex/
    /// - Plex source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter allowFriends: (query)  (optional)
    /// - parameter authenticationFlow: (query)  (optional)
    /// - parameter clientId: (query)  (optional)
    /// - parameter enabled: (query)  (optional)
    /// - parameter enrollmentFlow: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyEngineMode: (query) * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter slug: (query)  (optional)
    /// - parameter userMatchingMode: (query) How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
    /// - returns: AnyPublisher<PaginatedPlexSourceList, Error> 
    open func sourcesPlexList(allowFriends: Bool? = nil, authenticationFlow: UUID? = nil, clientId: String? = nil, enabled: Bool? = nil, enrollmentFlow: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyEngineMode: SourcesPlexListPolicyEngineMode? = nil, search: String? = nil, slug: String? = nil, userMatchingMode: SourcesPlexListUserMatchingMode? = nil) -> AnyPublisher<PaginatedPlexSourceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/plex/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let allowFriends = allowFriends { queryItems.append(URLQueryItem(name: "allow_friends", value: allowFriends ? "true" : "false")) } 
                if let authenticationFlow = authenticationFlow { queryItems.append(URLQueryItem(name: "authentication_flow", value: authenticationFlow.uuidString)) } 
                if let clientId = clientId { queryItems.append(URLQueryItem(name: "client_id", value: clientId)) } 
                if let enabled = enabled { queryItems.append(URLQueryItem(name: "enabled", value: enabled ? "true" : "false")) } 
                if let enrollmentFlow = enrollmentFlow { queryItems.append(URLQueryItem(name: "enrollment_flow", value: enrollmentFlow.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyEngineMode = policyEngineMode { queryItems.append(URLQueryItem(name: "policy_engine_mode", value: policyEngineMode.rawValue)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                if let userMatchingMode = userMatchingMode { queryItems.append(URLQueryItem(name: "user_matching_mode", value: userMatchingMode.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPlexSourceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPlexSourceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/plex/{slug}/
    /// - Plex source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter patchedPlexSourceRequest: (body)  (optional)
    /// - returns: AnyPublisher<PlexSource, Error> 
    open func sourcesPlexPartialUpdate(slug: String, patchedPlexSourceRequest: PatchedPlexSourceRequest? = nil) -> AnyPublisher<PlexSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/plex/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPlexSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexRedeemTokenAuthenticatedCreateError: Error, CustomStringConvertible {
        // Token not found
        case code400Error
        // Access denied
        case code403Error

        public var description: String {
            switch self {
            case .code400Error:
                return "SourcesPlexRedeemTokenAuthenticatedCreateError: Token not found"
            case .code403Error:
                return "SourcesPlexRedeemTokenAuthenticatedCreateError: Access denied"
            }
        }
    }

    /// - POST /sources/plex/redeem_token_authenticated/
    /// - Redeem a plex token for an authenticated user, creating a connection
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter plexTokenRedeemRequest: (body)  
    /// - parameter slug: (query)  (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesPlexRedeemTokenAuthenticatedCreate(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: String? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/plex/redeem_token_authenticated/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(plexTokenRedeemRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return SourcesPlexRedeemTokenAuthenticatedCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        return SourcesPlexRedeemTokenAuthenticatedCreateError.code403Error
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexRedeemTokenCreateError: Error, CustomStringConvertible {
        // Token not found
        case code400Error
        // Access denied
        case code403Error

        public var description: String {
            switch self {
            case .code400Error:
                return "SourcesPlexRedeemTokenCreateError: Token not found"
            case .code403Error:
                return "SourcesPlexRedeemTokenCreateError: Access denied"
            }
        }
    }

    /// - POST /sources/plex/redeem_token/
    /// - Redeem a plex token, check it's access to resources against what's allowed for the source, and redirect to an authentication/enrollment flow.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter plexTokenRedeemRequest: (body)  
    /// - parameter slug: (query)  (optional)
    /// - returns: AnyPublisher<RedirectChallenge, Error> 
    open func sourcesPlexRedeemTokenCreate(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: String? = nil) -> AnyPublisher<RedirectChallenge, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/plex/redeem_token/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(plexTokenRedeemRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RedirectChallenge, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return SourcesPlexRedeemTokenCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        return SourcesPlexRedeemTokenCreateError.code403Error
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RedirectChallenge.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/plex/{slug}/
    /// - Plex source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<PlexSource, Error> 
    open func sourcesPlexRetrieve(slug: String) -> AnyPublisher<PlexSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/plex/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/plex/{slug}/
    /// - Plex source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter plexSourceRequest: (body)  
    /// - returns: AnyPublisher<PlexSource, Error> 
    open func sourcesPlexUpdate(slug: String, plexSourceRequest: PlexSourceRequest) -> AnyPublisher<PlexSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/plex/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(plexSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesPlexUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesPlexUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesPlexUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/plex/{slug}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesPlexUsedByList(slug: String) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/plex/{slug}/used_by/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesPlexUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesPlexUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/saml/
    /// - SAMLSource Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter sAMLSourceRequest: (body)  
    /// - returns: AnyPublisher<SAMLSource, Error> 
    open func sourcesSamlCreate(sAMLSourceRequest: SAMLSourceRequest) -> AnyPublisher<SAMLSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/saml/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(sAMLSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/saml/{slug}/
    /// - SAMLSource Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesSamlDestroy(slug: String) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/saml/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter bindingType
    ///
    public enum SourcesSamlListBindingType: String, Codable, CaseIterable {
        case post = "POST"
        case postAuto = "POST_AUTO"
        case redirect = "REDIRECT"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter digestAlgorithm
    ///
    public enum SourcesSamlListDigestAlgorithm: String, Codable, CaseIterable {
        case _2000_09_xmldsig_sha1 = "http://www.w3.org/2000/09/xmldsig#sha1"
        case _2001_04_xmldsig-more_sha384 = "http://www.w3.org/2001/04/xmldsig-more#sha384"
        case _2001_04_xmlenc_sha256 = "http://www.w3.org/2001/04/xmlenc#sha256"
        case _2001_04_xmlenc_sha512 = "http://www.w3.org/2001/04/xmlenc#sha512"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter nameIdPolicy
    ///
    public enum SourcesSamlListNameIdPolicy: String, Codable, CaseIterable {
        case _11:nameidFormat:emailAddress = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        case _20:nameidFormat:WindowsDomainQualifiedName = "urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName"
        case _20:nameidFormat:X509SubjectName = "urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName"
        case _20:nameidFormat:persistent = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
        case _20:nameidFormat:transient = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter policyEngineMode
    ///
    public enum SourcesSamlListPolicyEngineMode: String, Codable, CaseIterable {
        case all = "all"
        case any = "any"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter signatureAlgorithm
    ///
    public enum SourcesSamlListSignatureAlgorithm: String, Codable, CaseIterable {
        case _200009xmldsig#dsaSha1 = "http://www.w3.org/2000/09/xmldsig#dsa-sha1"
        case _200009xmldsig#rsaSha1 = "http://www.w3.org/2000/09/xmldsig#rsa-sha1"
        case _200104xmldsigMore#rsaSha256 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"
        case _200104xmldsigMore#rsaSha384 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384"
        case _200104xmldsigMore#rsaSha512 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter userMatchingMode
    ///
    public enum SourcesSamlListUserMatchingMode: String, Codable, CaseIterable {
        case emailDeny = "email_deny"
        case emailLink = "email_link"
        case identifier = "identifier"
        case usernameDeny = "username_deny"
        case usernameLink = "username_link"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum SourcesSamlListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlListError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlListError: : \(object)"
            }
        }
    }

    /// - GET /sources/saml/
    /// - SAMLSource Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter allowIdpInitiated: (query)  (optional)
    /// - parameter authenticationFlow: (query)  (optional)
    /// - parameter bindingType: (query) * &#x60;REDIRECT&#x60; - Redirect Binding * &#x60;POST&#x60; - POST Binding * &#x60;POST_AUTO&#x60; - POST Binding with auto-confirmation (optional)
    /// - parameter digestAlgorithm: (query) * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
    /// - parameter enabled: (query)  (optional)
    /// - parameter enrollmentFlow: (query)  (optional)
    /// - parameter issuer: (query)  (optional)
    /// - parameter managed: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter nameIdPolicy: (query) NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * &#x60;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#x60; - Email * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:persistent&#x60; - Persistent * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName&#x60; - X509 * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName&#x60; - Windows * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&#x60; - Transient (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter policyEngineMode: (query) * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
    /// - parameter preAuthenticationFlow: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter signatureAlgorithm: (query) * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
    /// - parameter signingKp: (query)  (optional)
    /// - parameter sloUrl: (query)  (optional)
    /// - parameter slug: (query)  (optional)
    /// - parameter ssoUrl: (query)  (optional)
    /// - parameter temporaryUserDeleteAfter: (query)  (optional)
    /// - parameter userMatchingMode: (query) How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
    /// - parameter verificationKp: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedSAMLSourceList, Error> 
    open func sourcesSamlList(allowIdpInitiated: Bool? = nil, authenticationFlow: UUID? = nil, bindingType: SourcesSamlListBindingType? = nil, digestAlgorithm: SourcesSamlListDigestAlgorithm? = nil, enabled: Bool? = nil, enrollmentFlow: UUID? = nil, issuer: String? = nil, managed: String? = nil, name: String? = nil, nameIdPolicy: SourcesSamlListNameIdPolicy? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, policyEngineMode: SourcesSamlListPolicyEngineMode? = nil, preAuthenticationFlow: UUID? = nil, search: String? = nil, signatureAlgorithm: SourcesSamlListSignatureAlgorithm? = nil, signingKp: UUID? = nil, sloUrl: String? = nil, slug: String? = nil, ssoUrl: String? = nil, temporaryUserDeleteAfter: String? = nil, userMatchingMode: SourcesSamlListUserMatchingMode? = nil, verificationKp: UUID? = nil) -> AnyPublisher<PaginatedSAMLSourceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/saml/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let allowIdpInitiated = allowIdpInitiated { queryItems.append(URLQueryItem(name: "allow_idp_initiated", value: allowIdpInitiated ? "true" : "false")) } 
                if let authenticationFlow = authenticationFlow { queryItems.append(URLQueryItem(name: "authentication_flow", value: authenticationFlow.uuidString)) } 
                if let bindingType = bindingType { queryItems.append(URLQueryItem(name: "binding_type", value: bindingType.rawValue)) } 
                if let digestAlgorithm = digestAlgorithm { queryItems.append(URLQueryItem(name: "digest_algorithm", value: digestAlgorithm.rawValue)) } 
                if let enabled = enabled { queryItems.append(URLQueryItem(name: "enabled", value: enabled ? "true" : "false")) } 
                if let enrollmentFlow = enrollmentFlow { queryItems.append(URLQueryItem(name: "enrollment_flow", value: enrollmentFlow.uuidString)) } 
                if let issuer = issuer { queryItems.append(URLQueryItem(name: "issuer", value: issuer)) } 
                if let managed = managed { queryItems.append(URLQueryItem(name: "managed", value: managed)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let nameIdPolicy = nameIdPolicy { queryItems.append(URLQueryItem(name: "name_id_policy", value: nameIdPolicy.rawValue)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let policyEngineMode = policyEngineMode { queryItems.append(URLQueryItem(name: "policy_engine_mode", value: policyEngineMode.rawValue)) } 
                if let preAuthenticationFlow = preAuthenticationFlow { queryItems.append(URLQueryItem(name: "pre_authentication_flow", value: preAuthenticationFlow.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let signatureAlgorithm = signatureAlgorithm { queryItems.append(URLQueryItem(name: "signature_algorithm", value: signatureAlgorithm.rawValue)) } 
                if let signingKp = signingKp { queryItems.append(URLQueryItem(name: "signing_kp", value: signingKp.uuidString)) } 
                if let sloUrl = sloUrl { queryItems.append(URLQueryItem(name: "slo_url", value: sloUrl)) } 
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                if let ssoUrl = ssoUrl { queryItems.append(URLQueryItem(name: "sso_url", value: ssoUrl)) } 
                if let temporaryUserDeleteAfter = temporaryUserDeleteAfter { queryItems.append(URLQueryItem(name: "temporary_user_delete_after", value: temporaryUserDeleteAfter)) } 
                if let userMatchingMode = userMatchingMode { queryItems.append(URLQueryItem(name: "user_matching_mode", value: userMatchingMode.rawValue)) } 
                if let verificationKp = verificationKp { queryItems.append(URLQueryItem(name: "verification_kp", value: verificationKp.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSAMLSourceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSAMLSourceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlMetadataRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlMetadataRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlMetadataRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/saml/{slug}/metadata/
    /// - Return metadata as XML string
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<SAMLMetadata, Error> 
    open func sourcesSamlMetadataRetrieve(slug: String) -> AnyPublisher<SAMLMetadata, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/saml/{slug}/metadata/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLMetadata, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlMetadataRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlMetadataRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLMetadata.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/saml/{slug}/
    /// - SAMLSource Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter patchedSAMLSourceRequest: (body)  (optional)
    /// - returns: AnyPublisher<SAMLSource, Error> 
    open func sourcesSamlPartialUpdate(slug: String, patchedSAMLSourceRequest: PatchedSAMLSourceRequest? = nil) -> AnyPublisher<SAMLSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/saml/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSAMLSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/saml/{slug}/
    /// - SAMLSource Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<SAMLSource, Error> 
    open func sourcesSamlRetrieve(slug: String) -> AnyPublisher<SAMLSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/saml/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/saml/{slug}/
    /// - SAMLSource Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter sAMLSourceRequest: (body)  
    /// - returns: AnyPublisher<SAMLSource, Error> 
    open func sourcesSamlUpdate(slug: String, sAMLSourceRequest: SAMLSourceRequest) -> AnyPublisher<SAMLSource, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/saml/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sAMLSourceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SAMLSource, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SAMLSource.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesSamlUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesSamlUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesSamlUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/saml/{slug}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesSamlUsedByList(slug: String) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/saml/{slug}/used_by/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesSamlUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesSamlUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/user_connections/all/{id}/
    /// - User-source connection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this user source connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesUserConnectionsAllDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/all/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsAllListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsAllListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/all/
    /// - User-source connection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter user: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedUserSourceConnectionList, Error> 
    open func sourcesUserConnectionsAllList(ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, user: Int? = nil) -> AnyPublisher<PaginatedUserSourceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let user = user { queryItems.append(URLQueryItem(name: "user", value: "\(user)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserSourceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserSourceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsAllPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsAllPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsAllPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/user_connections/all/{id}/
    /// - User-source connection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this user source connection. 
    /// - returns: AnyPublisher<UserSourceConnection, Error> 
    open func sourcesUserConnectionsAllPartialUpdate(id: Int) -> AnyPublisher<UserSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/all/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsAllPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsAllPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/all/{id}/
    /// - User-source connection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this user source connection. 
    /// - returns: AnyPublisher<UserSourceConnection, Error> 
    open func sourcesUserConnectionsAllRetrieve(id: Int) -> AnyPublisher<UserSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/all/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsAllUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsAllUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsAllUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/user_connections/all/{id}/
    /// - User-source connection Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this user source connection. 
    /// - returns: AnyPublisher<UserSourceConnection, Error> 
    open func sourcesUserConnectionsAllUpdate(id: Int) -> AnyPublisher<UserSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/all/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsAllUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsAllUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/all/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this user source connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesUserConnectionsAllUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/all/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/user_connections/oauth/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userOAuthSourceConnectionRequest: (body)  
    /// - returns: AnyPublisher<UserOAuthSourceConnection, Error> 
    open func sourcesUserConnectionsOauthCreate(userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) -> AnyPublisher<UserOAuthSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/oauth/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(userOAuthSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserOAuthSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserOAuthSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/user_connections/oauth/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User OAuth Source Connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesUserConnectionsOauthDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/oauth/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/oauth/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter sourceSlug: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedUserOAuthSourceConnectionList, Error> 
    open func sourcesUserConnectionsOauthList(ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, sourceSlug: String? = nil) -> AnyPublisher<PaginatedUserOAuthSourceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/oauth/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let sourceSlug = sourceSlug { queryItems.append(URLQueryItem(name: "source__slug", value: sourceSlug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserOAuthSourceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserOAuthSourceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/user_connections/oauth/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User OAuth Source Connection. 
    /// - parameter patchedUserOAuthSourceConnectionRequest: (body)  (optional)
    /// - returns: AnyPublisher<UserOAuthSourceConnection, Error> 
    open func sourcesUserConnectionsOauthPartialUpdate(id: Int, patchedUserOAuthSourceConnectionRequest: PatchedUserOAuthSourceConnectionRequest? = nil) -> AnyPublisher<UserOAuthSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/oauth/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedUserOAuthSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserOAuthSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserOAuthSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/oauth/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User OAuth Source Connection. 
    /// - returns: AnyPublisher<UserOAuthSourceConnection, Error> 
    open func sourcesUserConnectionsOauthRetrieve(id: Int) -> AnyPublisher<UserOAuthSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/oauth/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserOAuthSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserOAuthSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/user_connections/oauth/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User OAuth Source Connection. 
    /// - parameter userOAuthSourceConnectionRequest: (body)  
    /// - returns: AnyPublisher<UserOAuthSourceConnection, Error> 
    open func sourcesUserConnectionsOauthUpdate(id: Int, userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) -> AnyPublisher<UserOAuthSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/oauth/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(userOAuthSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserOAuthSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserOAuthSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsOauthUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsOauthUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsOauthUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/oauth/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User OAuth Source Connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesUserConnectionsOauthUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/oauth/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsOauthUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/user_connections/plex/
    /// - Plex Source connection Serializer
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter plexSourceConnectionRequest: (body)  
    /// - returns: AnyPublisher<PlexSourceConnection, Error> 
    open func sourcesUserConnectionsPlexCreate(plexSourceConnectionRequest: PlexSourceConnectionRequest) -> AnyPublisher<PlexSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/plex/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(plexSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/user_connections/plex/{id}/
    /// - Plex Source connection Serializer
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User Plex Source Connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesUserConnectionsPlexDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/plex/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/plex/
    /// - Plex Source connection Serializer
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter sourceSlug: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedPlexSourceConnectionList, Error> 
    open func sourcesUserConnectionsPlexList(ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, sourceSlug: String? = nil) -> AnyPublisher<PaginatedPlexSourceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/plex/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let sourceSlug = sourceSlug { queryItems.append(URLQueryItem(name: "source__slug", value: sourceSlug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPlexSourceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPlexSourceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/user_connections/plex/{id}/
    /// - Plex Source connection Serializer
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User Plex Source Connection. 
    /// - parameter patchedPlexSourceConnectionRequest: (body)  (optional)
    /// - returns: AnyPublisher<PlexSourceConnection, Error> 
    open func sourcesUserConnectionsPlexPartialUpdate(id: Int, patchedPlexSourceConnectionRequest: PatchedPlexSourceConnectionRequest? = nil) -> AnyPublisher<PlexSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/plex/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPlexSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/plex/{id}/
    /// - Plex Source connection Serializer
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User Plex Source Connection. 
    /// - returns: AnyPublisher<PlexSourceConnection, Error> 
    open func sourcesUserConnectionsPlexRetrieve(id: Int) -> AnyPublisher<PlexSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/plex/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/user_connections/plex/{id}/
    /// - Plex Source connection Serializer
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User Plex Source Connection. 
    /// - parameter plexSourceConnectionRequest: (body)  
    /// - returns: AnyPublisher<PlexSourceConnection, Error> 
    open func sourcesUserConnectionsPlexUpdate(id: Int, plexSourceConnectionRequest: PlexSourceConnectionRequest) -> AnyPublisher<PlexSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/plex/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(plexSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlexSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PlexSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsPlexUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsPlexUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsPlexUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/plex/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User Plex Source Connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesUserConnectionsPlexUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/plex/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsPlexUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlCreateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlCreateError: : \(object)"
            }
        }
    }

    /// - POST /sources/user_connections/saml/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userSAMLSourceConnectionRequest: (body)  
    /// - returns: AnyPublisher<UserSAMLSourceConnection, Error> 
    open func sourcesUserConnectionsSamlCreate(userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) -> AnyPublisher<UserSAMLSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/saml/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(userSAMLSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSAMLSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSAMLSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlDestroyError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /sources/user_connections/saml/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User SAML Source Connection. 
    /// - returns: AnyPublisher<Void, Error> 
    open func sourcesUserConnectionsSamlDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/saml/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter sourceSlug: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedUserSAMLSourceConnectionList, Error> 
    open func sourcesUserConnectionsSamlList(ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, sourceSlug: String? = nil) -> AnyPublisher<PaginatedUserSAMLSourceConnectionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/sources/user_connections/saml/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let sourceSlug = sourceSlug { queryItems.append(URLQueryItem(name: "source__slug", value: sourceSlug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserSAMLSourceConnectionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserSAMLSourceConnectionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /sources/user_connections/saml/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User SAML Source Connection. 
    /// - parameter patchedUserSAMLSourceConnectionRequest: (body)  (optional)
    /// - returns: AnyPublisher<UserSAMLSourceConnection, Error> 
    open func sourcesUserConnectionsSamlPartialUpdate(id: Int, patchedUserSAMLSourceConnectionRequest: PatchedUserSAMLSourceConnectionRequest? = nil) -> AnyPublisher<UserSAMLSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedUserSAMLSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSAMLSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSAMLSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlRetrieveError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/saml/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User SAML Source Connection. 
    /// - returns: AnyPublisher<UserSAMLSourceConnection, Error> 
    open func sourcesUserConnectionsSamlRetrieve(id: Int) -> AnyPublisher<UserSAMLSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSAMLSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSAMLSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlUpdateError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /sources/user_connections/saml/{id}/
    /// - Source Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User SAML Source Connection. 
    /// - parameter userSAMLSourceConnectionRequest: (body)  
    /// - returns: AnyPublisher<UserSAMLSourceConnection, Error> 
    open func sourcesUserConnectionsSamlUpdate(id: Int, userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) -> AnyPublisher<UserSAMLSourceConnection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/saml/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(userSAMLSourceConnectionRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSAMLSourceConnection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserSAMLSourceConnection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum SourcesUserConnectionsSamlUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "SourcesUserConnectionsSamlUsedByListError: : \(object)"
            case .code403Error(let object):
                return "SourcesUserConnectionsSamlUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /sources/user_connections/saml/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User SAML Source Connection. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func sourcesUserConnectionsSamlUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/sources/user_connections/saml/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return SourcesUserConnectionsSamlUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
