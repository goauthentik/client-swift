//
// AuthenticatorsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AuthenticatorsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum AuthenticatorsAdminAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminAllListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminAllListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/all/
    /// - Get all devices for current user
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter user: (query)  (optional)
    /// - returns: AnyPublisher<[Device], Error> 
    open func authenticatorsAdminAllList(user: Int? = nil) -> AnyPublisher<[Device], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let user = user { queryItems.append(URLQueryItem(name: "user", value: "\(user)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Device], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([Device].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminDuoCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminDuoCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminDuoCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/admin/duo/
    /// - Viewset for Duo authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter duoDeviceRequest: (body)  
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsAdminDuoCreate(duoDeviceRequest: DuoDeviceRequest) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/duo/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(duoDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminDuoDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminDuoDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminDuoDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/admin/duo/{id}/
    /// - Viewset for Duo authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsAdminDuoDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminDuoListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminDuoListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminDuoListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/duo/
    /// - Viewset for Duo authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedDuoDeviceList, Error> 
    open func authenticatorsAdminDuoList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedDuoDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/duo/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedDuoDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedDuoDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminDuoPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminDuoPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminDuoPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/admin/duo/{id}/
    /// - Viewset for Duo authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - parameter patchedDuoDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsAdminDuoPartialUpdate(id: Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest? = nil) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedDuoDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminDuoRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminDuoRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminDuoRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/duo/{id}/
    /// - Viewset for Duo authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsAdminDuoRetrieve(id: Int) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminDuoUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminDuoUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminDuoUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/admin/duo/{id}/
    /// - Viewset for Duo authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - parameter duoDeviceRequest: (body)  
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsAdminDuoUpdate(id: Int, duoDeviceRequest: DuoDeviceRequest) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(duoDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminDuoUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminMobileCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminMobileCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminMobileCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/admin/mobile/
    /// - Viewset for Mobile authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter mobileDeviceRequest: (body)  
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsAdminMobileCreate(mobileDeviceRequest: MobileDeviceRequest) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/mobile/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(mobileDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminMobileDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminMobileDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminMobileDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/admin/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsAdminMobileDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminMobileListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminMobileListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminMobileListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/mobile/
    /// - Viewset for Mobile authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedMobileDeviceList, Error> 
    open func authenticatorsAdminMobileList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedMobileDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/mobile/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedMobileDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedMobileDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminMobilePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminMobilePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminMobilePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/admin/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter patchedMobileDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsAdminMobilePartialUpdate(uuid: UUID, patchedMobileDeviceRequest: PatchedMobileDeviceRequest? = nil) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedMobileDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminMobilePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminMobilePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminMobileRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminMobileRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminMobileRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsAdminMobileRetrieve(uuid: UUID) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminMobileUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminMobileUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminMobileUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/admin/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter mobileDeviceRequest: (body)  
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsAdminMobileUpdate(uuid: UUID, mobileDeviceRequest: MobileDeviceRequest) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(mobileDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminMobileUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminSmsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminSmsCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminSmsCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/admin/sms/
    /// - Viewset for sms authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter sMSDeviceRequest: (body)  
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsAdminSmsCreate(sMSDeviceRequest: SMSDeviceRequest) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/sms/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(sMSDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminSmsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminSmsDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminSmsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/admin/sms/{id}/
    /// - Viewset for sms authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsAdminSmsDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminSmsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminSmsListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminSmsListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/sms/
    /// - Viewset for sms authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedSMSDeviceList, Error> 
    open func authenticatorsAdminSmsList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedSMSDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/sms/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSMSDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSMSDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminSmsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminSmsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminSmsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/admin/sms/{id}/
    /// - Viewset for sms authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - parameter patchedSMSDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsAdminSmsPartialUpdate(id: Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest? = nil) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSMSDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminSmsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminSmsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminSmsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/sms/{id}/
    /// - Viewset for sms authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsAdminSmsRetrieve(id: Int) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminSmsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminSmsUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminSmsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/admin/sms/{id}/
    /// - Viewset for sms authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - parameter sMSDeviceRequest: (body)  
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsAdminSmsUpdate(id: Int, sMSDeviceRequest: SMSDeviceRequest) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sMSDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminSmsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminStaticCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminStaticCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminStaticCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/admin/static/
    /// - Viewset for static authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter staticDeviceRequest: (body)  
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsAdminStaticCreate(staticDeviceRequest: StaticDeviceRequest) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/static/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(staticDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminStaticDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminStaticDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminStaticDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/admin/static/{id}/
    /// - Viewset for static authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsAdminStaticDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminStaticListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminStaticListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminStaticListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/static/
    /// - Viewset for static authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedStaticDeviceList, Error> 
    open func authenticatorsAdminStaticList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedStaticDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/static/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedStaticDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedStaticDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminStaticPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminStaticPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminStaticPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/admin/static/{id}/
    /// - Viewset for static authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - parameter patchedStaticDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsAdminStaticPartialUpdate(id: Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest? = nil) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedStaticDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminStaticRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminStaticRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminStaticRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/static/{id}/
    /// - Viewset for static authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsAdminStaticRetrieve(id: Int) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminStaticUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminStaticUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminStaticUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/admin/static/{id}/
    /// - Viewset for static authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - parameter staticDeviceRequest: (body)  
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsAdminStaticUpdate(id: Int, staticDeviceRequest: StaticDeviceRequest) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(staticDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminStaticUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminTotpCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminTotpCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminTotpCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/admin/totp/
    /// - Viewset for totp authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter tOTPDeviceRequest: (body)  
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsAdminTotpCreate(tOTPDeviceRequest: TOTPDeviceRequest) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/totp/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(tOTPDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminTotpDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminTotpDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminTotpDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/admin/totp/{id}/
    /// - Viewset for totp authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsAdminTotpDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminTotpListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminTotpListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminTotpListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/totp/
    /// - Viewset for totp authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedTOTPDeviceList, Error> 
    open func authenticatorsAdminTotpList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedTOTPDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/totp/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedTOTPDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedTOTPDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminTotpPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminTotpPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminTotpPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/admin/totp/{id}/
    /// - Viewset for totp authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - parameter patchedTOTPDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsAdminTotpPartialUpdate(id: Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest? = nil) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedTOTPDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminTotpRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminTotpRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminTotpRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/totp/{id}/
    /// - Viewset for totp authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsAdminTotpRetrieve(id: Int) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminTotpUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminTotpUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminTotpUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/admin/totp/{id}/
    /// - Viewset for totp authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - parameter tOTPDeviceRequest: (body)  
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsAdminTotpUpdate(id: Int, tOTPDeviceRequest: TOTPDeviceRequest) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(tOTPDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminTotpUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminWebauthnCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminWebauthnCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminWebauthnCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/admin/webauthn/
    /// - Viewset for WebAuthn authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter webAuthnDeviceRequest: (body)  
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsAdminWebauthnCreate(webAuthnDeviceRequest: WebAuthnDeviceRequest) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/webauthn/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(webAuthnDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminWebauthnDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminWebauthnDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminWebauthnDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/admin/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsAdminWebauthnDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminWebauthnListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminWebauthnListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminWebauthnListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/webauthn/
    /// - Viewset for WebAuthn authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedWebAuthnDeviceList, Error> 
    open func authenticatorsAdminWebauthnList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedWebAuthnDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/admin/webauthn/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedWebAuthnDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedWebAuthnDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminWebauthnPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminWebauthnPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminWebauthnPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/admin/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - parameter patchedWebAuthnDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsAdminWebauthnPartialUpdate(id: Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest? = nil) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedWebAuthnDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminWebauthnRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminWebauthnRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminWebauthnRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/admin/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsAdminWebauthnRetrieve(id: Int) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAdminWebauthnUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAdminWebauthnUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAdminWebauthnUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/admin/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices (for admins)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - parameter webAuthnDeviceRequest: (body)  
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsAdminWebauthnUpdate(id: Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/admin/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(webAuthnDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAdminWebauthnUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsAllListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsAllListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/all/
    /// - Get all devices for current user
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[Device], Error> 
    open func authenticatorsAllList() -> AnyPublisher<[Device], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/all/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Device], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([Device].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsDuoDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsDuoDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsDuoDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/duo/{id}/
    /// - Viewset for Duo authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsDuoDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsDuoDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsDuoDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsDuoListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsDuoListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsDuoListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/duo/
    /// - Viewset for Duo authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedDuoDeviceList, Error> 
    open func authenticatorsDuoList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedDuoDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/duo/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedDuoDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsDuoListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsDuoListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedDuoDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsDuoPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsDuoPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsDuoPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/duo/{id}/
    /// - Viewset for Duo authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - parameter patchedDuoDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsDuoPartialUpdate(id: Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest? = nil) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedDuoDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsDuoPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsDuoPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsDuoRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsDuoRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsDuoRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/duo/{id}/
    /// - Viewset for Duo authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsDuoRetrieve(id: Int) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsDuoRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsDuoRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsDuoUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsDuoUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsDuoUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/duo/{id}/
    /// - Viewset for Duo authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - parameter duoDeviceRequest: (body)  
    /// - returns: AnyPublisher<DuoDevice, Error> 
    open func authenticatorsDuoUpdate(id: Int, duoDeviceRequest: DuoDeviceRequest) -> AnyPublisher<DuoDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/duo/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(duoDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsDuoUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsDuoUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsDuoUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsDuoUsedByListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsDuoUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/duo/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Duo Device. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func authenticatorsDuoUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/duo/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsDuoUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsDuoUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileCheckInCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileCheckInCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileCheckInCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/mobile/{uuid}/check_in/
    /// - Check in data about a device
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: mobile_device_token
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter mobileDeviceInfoRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsMobileCheckInCreate(uuid: UUID, mobileDeviceInfoRequest: MobileDeviceInfoRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/check_in/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(mobileDeviceInfoRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileCheckInCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileCheckInCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsMobileDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileEnrollmentCallbackCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileEnrollmentCallbackCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileEnrollmentCallbackCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/mobile/{uuid}/enrollment_callback/
    /// - Enrollment callback
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: mobile_device_token
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter mobileDeviceEnrollmentRequest: (body)  
    /// - returns: AnyPublisher<MobileDeviceEnrollmentCallback, Error> 
    open func authenticatorsMobileEnrollmentCallbackCreate(uuid: UUID, mobileDeviceEnrollmentRequest: MobileDeviceEnrollmentRequest) -> AnyPublisher<MobileDeviceEnrollmentCallback, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/enrollment_callback/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(mobileDeviceEnrollmentRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDeviceEnrollmentCallback, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileEnrollmentCallbackCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileEnrollmentCallbackCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDeviceEnrollmentCallback.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileEnrollmentStatusCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileEnrollmentStatusCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileEnrollmentStatusCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/mobile/{uuid}/enrollment_status/
    /// - Check device enrollment status
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: mobile_device_token
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - returns: AnyPublisher<MobileDeviceEnrollmentStatus, Error> 
    open func authenticatorsMobileEnrollmentStatusCreate(uuid: UUID) -> AnyPublisher<MobileDeviceEnrollmentStatus, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/enrollment_status/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDeviceEnrollmentStatus, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileEnrollmentStatusCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileEnrollmentStatusCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDeviceEnrollmentStatus.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/mobile/
    /// - Viewset for Mobile authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedMobileDeviceList, Error> 
    open func authenticatorsMobileList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedMobileDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/mobile/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedMobileDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedMobileDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobilePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobilePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobilePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter patchedMobileDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsMobilePartialUpdate(uuid: UUID, patchedMobileDeviceRequest: PatchedMobileDeviceRequest? = nil) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedMobileDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobilePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobilePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileReceiveResponseCreateError: Error, CustomStringConvertible {
        // Transaction not found
        case code404Error
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code404Error:
                return "AuthenticatorsMobileReceiveResponseCreateError: Transaction not found"
            case .code400Error(let object):
                return "AuthenticatorsMobileReceiveResponseCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileReceiveResponseCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/mobile/{uuid}/receive_response/
    /// - Get response from notification on phone
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: mobile_device_token
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter mobileDeviceResponseRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsMobileReceiveResponseCreate(uuid: UUID, mobileDeviceResponseRequest: MobileDeviceResponseRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/receive_response/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(mobileDeviceResponseRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 404 {
                        return AuthenticatorsMobileReceiveResponseCreateError.code404Error
                    }
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileReceiveResponseCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileReceiveResponseCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsMobileRetrieve(uuid: UUID) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileSetNotificationKeyCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileSetNotificationKeyCreateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileSetNotificationKeyCreateError: : \(object)"
            }
        }
    }

    /// - POST /authenticators/mobile/{uuid}/set_notification_key/
    /// - Called by the phone whenever the firebase key changes and we need to update it
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: mobile_device_token
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter mobileDeviceSetPushKeyRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsMobileSetNotificationKeyCreate(uuid: UUID, mobileDeviceSetPushKeyRequest: MobileDeviceSetPushKeyRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/set_notification_key/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(mobileDeviceSetPushKeyRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileSetNotificationKeyCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileSetNotificationKeyCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/mobile/{uuid}/
    /// - Viewset for Mobile authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - parameter mobileDeviceRequest: (body)  
    /// - returns: AnyPublisher<MobileDevice, Error> 
    open func authenticatorsMobileUpdate(uuid: UUID, mobileDeviceRequest: MobileDeviceRequest) -> AnyPublisher<MobileDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(mobileDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MobileDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(MobileDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsMobileUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsMobileUsedByListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsMobileUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/mobile/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Mobile Device. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func authenticatorsMobileUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/mobile/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsMobileUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsMobileUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsSmsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsSmsDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsSmsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/sms/{id}/
    /// - Viewset for sms authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsSmsDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsSmsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsSmsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsSmsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsSmsListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsSmsListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/sms/
    /// - Viewset for sms authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedSMSDeviceList, Error> 
    open func authenticatorsSmsList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedSMSDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/sms/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedSMSDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsSmsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsSmsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedSMSDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsSmsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsSmsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsSmsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/sms/{id}/
    /// - Viewset for sms authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - parameter patchedSMSDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsSmsPartialUpdate(id: Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest? = nil) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedSMSDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsSmsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsSmsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsSmsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsSmsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsSmsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/sms/{id}/
    /// - Viewset for sms authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsSmsRetrieve(id: Int) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsSmsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsSmsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsSmsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsSmsUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsSmsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/sms/{id}/
    /// - Viewset for sms authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - parameter sMSDeviceRequest: (body)  
    /// - returns: AnyPublisher<SMSDevice, Error> 
    open func authenticatorsSmsUpdate(id: Int, sMSDeviceRequest: SMSDeviceRequest) -> AnyPublisher<SMSDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/sms/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(sMSDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SMSDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsSmsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsSmsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SMSDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsSmsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsSmsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsSmsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/sms/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this SMS Device. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func authenticatorsSmsUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/sms/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsSmsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsSmsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsStaticDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsStaticDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsStaticDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/static/{id}/
    /// - Viewset for static authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsStaticDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsStaticDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsStaticDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsStaticListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsStaticListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsStaticListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/static/
    /// - Viewset for static authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedStaticDeviceList, Error> 
    open func authenticatorsStaticList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedStaticDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/static/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedStaticDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsStaticListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsStaticListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedStaticDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsStaticPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsStaticPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsStaticPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/static/{id}/
    /// - Viewset for static authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - parameter patchedStaticDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsStaticPartialUpdate(id: Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest? = nil) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedStaticDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsStaticPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsStaticPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsStaticRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsStaticRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsStaticRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/static/{id}/
    /// - Viewset for static authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsStaticRetrieve(id: Int) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsStaticRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsStaticRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsStaticUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsStaticUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsStaticUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/static/{id}/
    /// - Viewset for static authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - parameter staticDeviceRequest: (body)  
    /// - returns: AnyPublisher<StaticDevice, Error> 
    open func authenticatorsStaticUpdate(id: Int, staticDeviceRequest: StaticDeviceRequest) -> AnyPublisher<StaticDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/static/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(staticDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<StaticDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsStaticUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsStaticUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(StaticDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsStaticUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsStaticUsedByListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsStaticUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/static/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this Static Device. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func authenticatorsStaticUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/static/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsStaticUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsStaticUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsTotpDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsTotpDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsTotpDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/totp/{id}/
    /// - Viewset for totp authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsTotpDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsTotpDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsTotpDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsTotpListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsTotpListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsTotpListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/totp/
    /// - Viewset for totp authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedTOTPDeviceList, Error> 
    open func authenticatorsTotpList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedTOTPDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/totp/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedTOTPDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsTotpListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsTotpListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedTOTPDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsTotpPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsTotpPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsTotpPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/totp/{id}/
    /// - Viewset for totp authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - parameter patchedTOTPDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsTotpPartialUpdate(id: Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest? = nil) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedTOTPDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsTotpPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsTotpPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsTotpRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsTotpRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsTotpRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/totp/{id}/
    /// - Viewset for totp authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsTotpRetrieve(id: Int) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsTotpRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsTotpRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsTotpUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsTotpUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsTotpUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/totp/{id}/
    /// - Viewset for totp authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - parameter tOTPDeviceRequest: (body)  
    /// - returns: AnyPublisher<TOTPDevice, Error> 
    open func authenticatorsTotpUpdate(id: Int, tOTPDeviceRequest: TOTPDeviceRequest) -> AnyPublisher<TOTPDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/totp/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(tOTPDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TOTPDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsTotpUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsTotpUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(TOTPDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsTotpUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsTotpUsedByListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsTotpUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/totp/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this TOTP Device. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func authenticatorsTotpUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/totp/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsTotpUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsTotpUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsWebauthnDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsWebauthnDestroyError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsWebauthnDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /authenticators/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - returns: AnyPublisher<Void, Error> 
    open func authenticatorsWebauthnDestroy(id: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsWebauthnDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsWebauthnDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsWebauthnListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsWebauthnListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsWebauthnListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/webauthn/
    /// - Viewset for WebAuthn authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedWebAuthnDeviceList, Error> 
    open func authenticatorsWebauthnList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedWebAuthnDeviceList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/authenticators/webauthn/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedWebAuthnDeviceList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsWebauthnListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsWebauthnListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedWebAuthnDeviceList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsWebauthnPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsWebauthnPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsWebauthnPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /authenticators/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - parameter patchedWebAuthnDeviceRequest: (body)  (optional)
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsWebauthnPartialUpdate(id: Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest? = nil) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedWebAuthnDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsWebauthnPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsWebauthnPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsWebauthnRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsWebauthnRetrieveError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsWebauthnRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsWebauthnRetrieve(id: Int) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsWebauthnRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsWebauthnRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsWebauthnUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsWebauthnUpdateError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsWebauthnUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /authenticators/webauthn/{id}/
    /// - Viewset for WebAuthn authenticator devices
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - parameter webAuthnDeviceRequest: (body)  
    /// - returns: AnyPublisher<WebAuthnDevice, Error> 
    open func authenticatorsWebauthnUpdate(id: Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) -> AnyPublisher<WebAuthnDevice, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/webauthn/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(webAuthnDeviceRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WebAuthnDevice, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsWebauthnUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsWebauthnUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(WebAuthnDevice.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum AuthenticatorsWebauthnUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "AuthenticatorsWebauthnUsedByListError: : \(object)"
            case .code403Error(let object):
                return "AuthenticatorsWebauthnUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /authenticators/webauthn/{id}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this WebAuthn Device. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func authenticatorsWebauthnUsedByList(id: Int) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/authenticators/webauthn/{id}/used_by/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return AuthenticatorsWebauthnUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return AuthenticatorsWebauthnUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
