//
// RbacAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RbacAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum RbacPermissionsAssignedByRolesAssignCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsAssignedByRolesAssignCreateError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsAssignedByRolesAssignCreateError: : \(object)"
            }
        }
    }

    /// - POST /rbac/permissions/assigned_by_roles/{uuid}/assign/
    /// - Assign permission(s) to role. When `object_pk` is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - parameter permissionAssignRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func rbacPermissionsAssignedByRolesAssignCreate(uuid: UUID, permissionAssignRequest: PermissionAssignRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/permissions/assigned_by_roles/{uuid}/assign/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(permissionAssignRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsAssignedByRolesAssignCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsAssignedByRolesAssignCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter model
    ///
    public enum RbacPermissionsAssignedByRolesListModel: String, Codable, CaseIterable {
        case blueprintsBlueprintinstance = "authentik_blueprints.blueprintinstance"
        case coreApplication = "authentik_core.application"
        case coreGroup = "authentik_core.group"
        case coreToken = "authentik_core.token"
        case coreUser = "authentik_core.user"
        case cryptoCertificatekeypair = "authentik_crypto.certificatekeypair"
        case enterpriseLicense = "authentik_enterprise.license"
        case eventsEvent = "authentik_events.event"
        case eventsNotification = "authentik_events.notification"
        case eventsNotificationrule = "authentik_events.notificationrule"
        case eventsNotificationtransport = "authentik_events.notificationtransport"
        case eventsNotificationwebhookmapping = "authentik_events.notificationwebhookmapping"
        case flowsFlow = "authentik_flows.flow"
        case flowsFlowstagebinding = "authentik_flows.flowstagebinding"
        case outpostsDockerserviceconnection = "authentik_outposts.dockerserviceconnection"
        case outpostsKubernetesserviceconnection = "authentik_outposts.kubernetesserviceconnection"
        case outpostsOutpost = "authentik_outposts.outpost"
        case policiesPolicybinding = "authentik_policies.policybinding"
        case policiesDummyDummypolicy = "authentik_policies_dummy.dummypolicy"
        case policiesEventMatcherEventmatcherpolicy = "authentik_policies_event_matcher.eventmatcherpolicy"
        case policiesExpiryPasswordexpirypolicy = "authentik_policies_expiry.passwordexpirypolicy"
        case policiesExpressionExpressionpolicy = "authentik_policies_expression.expressionpolicy"
        case policiesPasswordPasswordpolicy = "authentik_policies_password.passwordpolicy"
        case policiesReputationReputation = "authentik_policies_reputation.reputation"
        case policiesReputationReputationpolicy = "authentik_policies_reputation.reputationpolicy"
        case providersLdapLdapprovider = "authentik_providers_ldap.ldapprovider"
        case providersOauth2Accesstoken = "authentik_providers_oauth2.accesstoken"
        case providersOauth2Authorizationcode = "authentik_providers_oauth2.authorizationcode"
        case providersOauth2Oauth2provider = "authentik_providers_oauth2.oauth2provider"
        case providersOauth2Refreshtoken = "authentik_providers_oauth2.refreshtoken"
        case providersOauth2Scopemapping = "authentik_providers_oauth2.scopemapping"
        case providersProxyProxyprovider = "authentik_providers_proxy.proxyprovider"
        case providersRadiusRadiusprovider = "authentik_providers_radius.radiusprovider"
        case providersSamlSamlpropertymapping = "authentik_providers_saml.samlpropertymapping"
        case providersSamlSamlprovider = "authentik_providers_saml.samlprovider"
        case providersScimScimmapping = "authentik_providers_scim.scimmapping"
        case providersScimScimprovider = "authentik_providers_scim.scimprovider"
        case rbacRole = "authentik_rbac.role"
        case sourcesLdapLdappropertymapping = "authentik_sources_ldap.ldappropertymapping"
        case sourcesLdapLdapsource = "authentik_sources_ldap.ldapsource"
        case sourcesOauthOauthsource = "authentik_sources_oauth.oauthsource"
        case sourcesOauthUseroauthsourceconnection = "authentik_sources_oauth.useroauthsourceconnection"
        case sourcesPlexPlexsource = "authentik_sources_plex.plexsource"
        case sourcesPlexPlexsourceconnection = "authentik_sources_plex.plexsourceconnection"
        case sourcesSamlSamlsource = "authentik_sources_saml.samlsource"
        case sourcesSamlUsersamlsourceconnection = "authentik_sources_saml.usersamlsourceconnection"
        case stagesAuthenticatorDuoAuthenticatorduostage = "authentik_stages_authenticator_duo.authenticatorduostage"
        case stagesAuthenticatorDuoDuodevice = "authentik_stages_authenticator_duo.duodevice"
        case stagesAuthenticatorMobileAuthenticatormobilestage = "authentik_stages_authenticator_mobile.authenticatormobilestage"
        case stagesAuthenticatorMobileMobiledevice = "authentik_stages_authenticator_mobile.mobiledevice"
        case stagesAuthenticatorSmsAuthenticatorsmsstage = "authentik_stages_authenticator_sms.authenticatorsmsstage"
        case stagesAuthenticatorSmsSmsdevice = "authentik_stages_authenticator_sms.smsdevice"
        case stagesAuthenticatorStaticAuthenticatorstaticstage = "authentik_stages_authenticator_static.authenticatorstaticstage"
        case stagesAuthenticatorStaticStaticdevice = "authentik_stages_authenticator_static.staticdevice"
        case stagesAuthenticatorTotpAuthenticatortotpstage = "authentik_stages_authenticator_totp.authenticatortotpstage"
        case stagesAuthenticatorTotpTotpdevice = "authentik_stages_authenticator_totp.totpdevice"
        case stagesAuthenticatorValidateAuthenticatorvalidatestage = "authentik_stages_authenticator_validate.authenticatorvalidatestage"
        case stagesAuthenticatorWebauthnAuthenticatewebauthnstage = "authentik_stages_authenticator_webauthn.authenticatewebauthnstage"
        case stagesAuthenticatorWebauthnWebauthndevice = "authentik_stages_authenticator_webauthn.webauthndevice"
        case stagesCaptchaCaptchastage = "authentik_stages_captcha.captchastage"
        case stagesConsentConsentstage = "authentik_stages_consent.consentstage"
        case stagesConsentUserconsent = "authentik_stages_consent.userconsent"
        case stagesDenyDenystage = "authentik_stages_deny.denystage"
        case stagesDummyDummystage = "authentik_stages_dummy.dummystage"
        case stagesEmailEmailstage = "authentik_stages_email.emailstage"
        case stagesIdentificationIdentificationstage = "authentik_stages_identification.identificationstage"
        case stagesInvitationInvitation = "authentik_stages_invitation.invitation"
        case stagesInvitationInvitationstage = "authentik_stages_invitation.invitationstage"
        case stagesPasswordPasswordstage = "authentik_stages_password.passwordstage"
        case stagesPromptPrompt = "authentik_stages_prompt.prompt"
        case stagesPromptPromptstage = "authentik_stages_prompt.promptstage"
        case stagesUserDeleteUserdeletestage = "authentik_stages_user_delete.userdeletestage"
        case stagesUserLoginUserloginstage = "authentik_stages_user_login.userloginstage"
        case stagesUserLogoutUserlogoutstage = "authentik_stages_user_logout.userlogoutstage"
        case stagesUserWriteUserwritestage = "authentik_stages_user_write.userwritestage"
        case tenantsTenant = "authentik_tenants.tenant"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum RbacPermissionsAssignedByRolesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsAssignedByRolesListError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsAssignedByRolesListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/permissions/assigned_by_roles/
    /// - Get assigned object permissions for a single object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter model: (query) * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_mobile.authenticatormobilestage&#x60; - Mobile Authenticator Setup Stage * &#x60;authentik_stages_authenticator_mobile.mobiledevice&#x60; - Mobile Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License 
    /// - parameter objectPk: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedRoleAssignedObjectPermissionList, Error> 
    open func rbacPermissionsAssignedByRolesList(model: RbacPermissionsAssignedByRolesListModel, objectPk: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedRoleAssignedObjectPermissionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/permissions/assigned_by_roles/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "model", value: model.rawValue))
                if let objectPk = objectPk { queryItems.append(URLQueryItem(name: "object_pk", value: objectPk)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedRoleAssignedObjectPermissionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsAssignedByRolesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsAssignedByRolesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedRoleAssignedObjectPermissionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsAssignedByRolesUnassignPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsAssignedByRolesUnassignPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsAssignedByRolesUnassignPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /rbac/permissions/assigned_by_roles/{uuid}/unassign/
    /// - Unassign permission(s) to role. When `object_pk` is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - parameter patchedPermissionAssignRequest: (body)  (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func rbacPermissionsAssignedByRolesUnassignPartialUpdate(uuid: UUID, patchedPermissionAssignRequest: PatchedPermissionAssignRequest? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/permissions/assigned_by_roles/{uuid}/unassign/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPermissionAssignRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsAssignedByRolesUnassignPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsAssignedByRolesUnassignPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsAssignedByUsersAssignCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsAssignedByUsersAssignCreateError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsAssignedByUsersAssignCreateError: : \(object)"
            }
        }
    }

    /// - POST /rbac/permissions/assigned_by_users/{id}/assign/
    /// - Assign permission(s) to user
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User. 
    /// - parameter permissionAssignRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func rbacPermissionsAssignedByUsersAssignCreate(id: Int, permissionAssignRequest: PermissionAssignRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/permissions/assigned_by_users/{id}/assign/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(permissionAssignRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsAssignedByUsersAssignCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsAssignedByUsersAssignCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter model
    ///
    public enum RbacPermissionsAssignedByUsersListModel: String, Codable, CaseIterable {
        case blueprintsBlueprintinstance = "authentik_blueprints.blueprintinstance"
        case coreApplication = "authentik_core.application"
        case coreGroup = "authentik_core.group"
        case coreToken = "authentik_core.token"
        case coreUser = "authentik_core.user"
        case cryptoCertificatekeypair = "authentik_crypto.certificatekeypair"
        case enterpriseLicense = "authentik_enterprise.license"
        case eventsEvent = "authentik_events.event"
        case eventsNotification = "authentik_events.notification"
        case eventsNotificationrule = "authentik_events.notificationrule"
        case eventsNotificationtransport = "authentik_events.notificationtransport"
        case eventsNotificationwebhookmapping = "authentik_events.notificationwebhookmapping"
        case flowsFlow = "authentik_flows.flow"
        case flowsFlowstagebinding = "authentik_flows.flowstagebinding"
        case outpostsDockerserviceconnection = "authentik_outposts.dockerserviceconnection"
        case outpostsKubernetesserviceconnection = "authentik_outposts.kubernetesserviceconnection"
        case outpostsOutpost = "authentik_outposts.outpost"
        case policiesPolicybinding = "authentik_policies.policybinding"
        case policiesDummyDummypolicy = "authentik_policies_dummy.dummypolicy"
        case policiesEventMatcherEventmatcherpolicy = "authentik_policies_event_matcher.eventmatcherpolicy"
        case policiesExpiryPasswordexpirypolicy = "authentik_policies_expiry.passwordexpirypolicy"
        case policiesExpressionExpressionpolicy = "authentik_policies_expression.expressionpolicy"
        case policiesPasswordPasswordpolicy = "authentik_policies_password.passwordpolicy"
        case policiesReputationReputation = "authentik_policies_reputation.reputation"
        case policiesReputationReputationpolicy = "authentik_policies_reputation.reputationpolicy"
        case providersLdapLdapprovider = "authentik_providers_ldap.ldapprovider"
        case providersOauth2Accesstoken = "authentik_providers_oauth2.accesstoken"
        case providersOauth2Authorizationcode = "authentik_providers_oauth2.authorizationcode"
        case providersOauth2Oauth2provider = "authentik_providers_oauth2.oauth2provider"
        case providersOauth2Refreshtoken = "authentik_providers_oauth2.refreshtoken"
        case providersOauth2Scopemapping = "authentik_providers_oauth2.scopemapping"
        case providersProxyProxyprovider = "authentik_providers_proxy.proxyprovider"
        case providersRadiusRadiusprovider = "authentik_providers_radius.radiusprovider"
        case providersSamlSamlpropertymapping = "authentik_providers_saml.samlpropertymapping"
        case providersSamlSamlprovider = "authentik_providers_saml.samlprovider"
        case providersScimScimmapping = "authentik_providers_scim.scimmapping"
        case providersScimScimprovider = "authentik_providers_scim.scimprovider"
        case rbacRole = "authentik_rbac.role"
        case sourcesLdapLdappropertymapping = "authentik_sources_ldap.ldappropertymapping"
        case sourcesLdapLdapsource = "authentik_sources_ldap.ldapsource"
        case sourcesOauthOauthsource = "authentik_sources_oauth.oauthsource"
        case sourcesOauthUseroauthsourceconnection = "authentik_sources_oauth.useroauthsourceconnection"
        case sourcesPlexPlexsource = "authentik_sources_plex.plexsource"
        case sourcesPlexPlexsourceconnection = "authentik_sources_plex.plexsourceconnection"
        case sourcesSamlSamlsource = "authentik_sources_saml.samlsource"
        case sourcesSamlUsersamlsourceconnection = "authentik_sources_saml.usersamlsourceconnection"
        case stagesAuthenticatorDuoAuthenticatorduostage = "authentik_stages_authenticator_duo.authenticatorduostage"
        case stagesAuthenticatorDuoDuodevice = "authentik_stages_authenticator_duo.duodevice"
        case stagesAuthenticatorMobileAuthenticatormobilestage = "authentik_stages_authenticator_mobile.authenticatormobilestage"
        case stagesAuthenticatorMobileMobiledevice = "authentik_stages_authenticator_mobile.mobiledevice"
        case stagesAuthenticatorSmsAuthenticatorsmsstage = "authentik_stages_authenticator_sms.authenticatorsmsstage"
        case stagesAuthenticatorSmsSmsdevice = "authentik_stages_authenticator_sms.smsdevice"
        case stagesAuthenticatorStaticAuthenticatorstaticstage = "authentik_stages_authenticator_static.authenticatorstaticstage"
        case stagesAuthenticatorStaticStaticdevice = "authentik_stages_authenticator_static.staticdevice"
        case stagesAuthenticatorTotpAuthenticatortotpstage = "authentik_stages_authenticator_totp.authenticatortotpstage"
        case stagesAuthenticatorTotpTotpdevice = "authentik_stages_authenticator_totp.totpdevice"
        case stagesAuthenticatorValidateAuthenticatorvalidatestage = "authentik_stages_authenticator_validate.authenticatorvalidatestage"
        case stagesAuthenticatorWebauthnAuthenticatewebauthnstage = "authentik_stages_authenticator_webauthn.authenticatewebauthnstage"
        case stagesAuthenticatorWebauthnWebauthndevice = "authentik_stages_authenticator_webauthn.webauthndevice"
        case stagesCaptchaCaptchastage = "authentik_stages_captcha.captchastage"
        case stagesConsentConsentstage = "authentik_stages_consent.consentstage"
        case stagesConsentUserconsent = "authentik_stages_consent.userconsent"
        case stagesDenyDenystage = "authentik_stages_deny.denystage"
        case stagesDummyDummystage = "authentik_stages_dummy.dummystage"
        case stagesEmailEmailstage = "authentik_stages_email.emailstage"
        case stagesIdentificationIdentificationstage = "authentik_stages_identification.identificationstage"
        case stagesInvitationInvitation = "authentik_stages_invitation.invitation"
        case stagesInvitationInvitationstage = "authentik_stages_invitation.invitationstage"
        case stagesPasswordPasswordstage = "authentik_stages_password.passwordstage"
        case stagesPromptPrompt = "authentik_stages_prompt.prompt"
        case stagesPromptPromptstage = "authentik_stages_prompt.promptstage"
        case stagesUserDeleteUserdeletestage = "authentik_stages_user_delete.userdeletestage"
        case stagesUserLoginUserloginstage = "authentik_stages_user_login.userloginstage"
        case stagesUserLogoutUserlogoutstage = "authentik_stages_user_logout.userlogoutstage"
        case stagesUserWriteUserwritestage = "authentik_stages_user_write.userwritestage"
        case tenantsTenant = "authentik_tenants.tenant"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum RbacPermissionsAssignedByUsersListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsAssignedByUsersListError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsAssignedByUsersListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/permissions/assigned_by_users/
    /// - Get assigned object permissions for a single object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter model: (query) * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_mobile.authenticatormobilestage&#x60; - Mobile Authenticator Setup Stage * &#x60;authentik_stages_authenticator_mobile.mobiledevice&#x60; - Mobile Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License 
    /// - parameter objectPk: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedUserAssignedObjectPermissionList, Error> 
    open func rbacPermissionsAssignedByUsersList(model: RbacPermissionsAssignedByUsersListModel, objectPk: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedUserAssignedObjectPermissionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/permissions/assigned_by_users/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "model", value: model.rawValue))
                if let objectPk = objectPk { queryItems.append(URLQueryItem(name: "object_pk", value: objectPk)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserAssignedObjectPermissionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsAssignedByUsersListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsAssignedByUsersListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserAssignedObjectPermissionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsAssignedByUsersUnassignPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsAssignedByUsersUnassignPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsAssignedByUsersUnassignPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /rbac/permissions/assigned_by_users/{id}/unassign/
    /// - Unassign permission(s) to user. When `object_pk` is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this User. 
    /// - parameter patchedPermissionAssignRequest: (body)  (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func rbacPermissionsAssignedByUsersUnassignPartialUpdate(id: Int, patchedPermissionAssignRequest: PatchedPermissionAssignRequest? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/permissions/assigned_by_users/{id}/unassign/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPermissionAssignRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsAssignedByUsersUnassignPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsAssignedByUsersUnassignPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsListError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/permissions/
    /// - Read-only list of all permissions, filterable by model and app
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter codename: (query)  (optional)
    /// - parameter contentTypeAppLabel: (query)  (optional)
    /// - parameter contentTypeModel: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter role: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter user: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedPermissionList, Error> 
    open func rbacPermissionsList(codename: String? = nil, contentTypeAppLabel: String? = nil, contentTypeModel: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, role: String? = nil, search: String? = nil, user: Int? = nil) -> AnyPublisher<PaginatedPermissionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/permissions/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let codename = codename { queryItems.append(URLQueryItem(name: "codename", value: codename)) } 
                if let contentTypeAppLabel = contentTypeAppLabel { queryItems.append(URLQueryItem(name: "content_type__app_label", value: contentTypeAppLabel)) } 
                if let contentTypeModel = contentTypeModel { queryItems.append(URLQueryItem(name: "content_type__model", value: contentTypeModel)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let user = user { queryItems.append(URLQueryItem(name: "user", value: "\(user)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPermissionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPermissionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /rbac/permissions/{id}/
    /// - Read-only list of all permissions, filterable by model and app
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter id: (path) A unique integer value identifying this permission. 
    /// - returns: AnyPublisher<Permission, Error> 
    open func rbacPermissionsRetrieve(id: Int) -> AnyPublisher<Permission, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/permissions/{id}/"
                path = path.replacingOccurrences(of: "{id}", with: "\(id)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Permission, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Permission.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsRolesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsRolesListError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsRolesListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/permissions/roles/
    /// - Get a role's assigned object permissions
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (query)  
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedExtraRoleObjectPermissionList, Error> 
    open func rbacPermissionsRolesList(uuid: UUID, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedExtraRoleObjectPermissionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/permissions/roles/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                queryItems.append(URLQueryItem(name: "uuid", value: uuid.uuidString))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedExtraRoleObjectPermissionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsRolesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsRolesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedExtraRoleObjectPermissionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacPermissionsUsersListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacPermissionsUsersListError: : \(object)"
            case .code403Error(let object):
                return "RbacPermissionsUsersListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/permissions/users/
    /// - Get a users's assigned object permissions
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userId: (query)  
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedExtraUserObjectPermissionList, Error> 
    open func rbacPermissionsUsersList(userId: Int, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedExtraUserObjectPermissionList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/permissions/users/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                queryItems.append(URLQueryItem(name: "user_id", value: "\(userId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedExtraUserObjectPermissionList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacPermissionsUsersListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacPermissionsUsersListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedExtraUserObjectPermissionList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesCreateError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesCreateError: : \(object)"
            }
        }
    }

    /// - POST /rbac/roles/
    /// - Role viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter roleRequest: (body)  
    /// - returns: AnyPublisher<Role, Error> 
    open func rbacRolesCreate(roleRequest: RoleRequest) -> AnyPublisher<Role, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/roles/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(roleRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Role, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Role.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesDestroyError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /rbac/roles/{uuid}/
    /// - Role viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - returns: AnyPublisher<Void, Error> 
    open func rbacRolesDestroy(uuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/roles/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesListError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/roles/
    /// - Role viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter groupName: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedRoleList, Error> 
    open func rbacRolesList(groupName: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedRoleList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rbac/roles/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let groupName = groupName { queryItems.append(URLQueryItem(name: "group__name", value: groupName)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedRoleList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedRoleList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /rbac/roles/{uuid}/
    /// - Role viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - parameter patchedRoleRequest: (body)  (optional)
    /// - returns: AnyPublisher<Role, Error> 
    open func rbacRolesPartialUpdate(uuid: UUID, patchedRoleRequest: PatchedRoleRequest? = nil) -> AnyPublisher<Role, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/roles/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedRoleRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Role, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Role.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /rbac/roles/{uuid}/
    /// - Role viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - returns: AnyPublisher<Role, Error> 
    open func rbacRolesRetrieve(uuid: UUID) -> AnyPublisher<Role, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/roles/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Role, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Role.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesUpdateError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /rbac/roles/{uuid}/
    /// - Role viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - parameter roleRequest: (body)  
    /// - returns: AnyPublisher<Role, Error> 
    open func rbacRolesUpdate(uuid: UUID, roleRequest: RoleRequest) -> AnyPublisher<Role, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/roles/{uuid}/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(roleRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Role, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Role.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum RbacRolesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "RbacRolesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "RbacRolesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /rbac/roles/{uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter uuid: (path) A UUID string identifying this Role. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func rbacRolesUsedByList(uuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/rbac/roles/{uuid}/used_by/"
                path = path.replacingOccurrences(of: "{uuid}", with: uuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return RbacRolesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return RbacRolesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
