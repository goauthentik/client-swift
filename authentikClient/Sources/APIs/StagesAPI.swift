//
// StagesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class StagesAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum StagesAllDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAllDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAllDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/all/{stage_uuid}/
    /// - Stage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAllDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/all/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAllDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAllDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAllListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAllListError: : \(object)"
            case .code403Error(let object):
                return "StagesAllListError: : \(object)"
            }
        }
    }

    /// - GET /stages/all/
    /// - Stage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedStageList, Error> 
    open func stagesAllList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/all/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAllListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAllListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAllRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAllRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAllRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/all/{stage_uuid}/
    /// - Stage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this stage. 
    /// - returns: AnyPublisher<Stage, Error> 
    open func stagesAllRetrieve(stageUuid: UUID) -> AnyPublisher<Stage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/all/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Stage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAllRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAllRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Stage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAllTypesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAllTypesListError: : \(object)"
            case .code403Error(let object):
                return "StagesAllTypesListError: : \(object)"
            }
        }
    }

    /// - GET /stages/all/types/
    /// - Get all creatable stage types
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func stagesAllTypesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/all/types/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAllTypesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAllTypesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAllUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAllUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAllUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/all/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAllUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/all/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAllUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAllUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAllUserSettingsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAllUserSettingsListError: : \(object)"
            case .code403Error(let object):
                return "StagesAllUserSettingsListError: : \(object)"
            }
        }
    }

    /// - GET /stages/all/user_settings/
    /// - Get all stages the user can configure
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[UserSetting], Error> 
    open func stagesAllUserSettingsList() -> AnyPublisher<[UserSetting], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/all/user_settings/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UserSetting], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAllUserSettingsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAllUserSettingsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UserSetting].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/duo/
    /// - AuthenticatorDuoStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorDuoStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorDuoStage, Error> 
    open func stagesAuthenticatorDuoCreate(authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) -> AnyPublisher<AuthenticatorDuoStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/duo/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorDuoStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorDuoStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorDuoStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/duo/{stage_uuid}/
    /// - AuthenticatorDuoStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorDuoDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoEnrollmentStatusCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoEnrollmentStatusCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoEnrollmentStatusCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/duo/{stage_uuid}/enrollment_status/
    /// - Check enrollment status of user details in current session
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - returns: AnyPublisher<DuoDeviceEnrollmentStatus, Error> 
    open func stagesAuthenticatorDuoEnrollmentStatusCreate(stageUuid: UUID) -> AnyPublisher<DuoDeviceEnrollmentStatus, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/enrollment_status/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DuoDeviceEnrollmentStatus, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoEnrollmentStatusCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoEnrollmentStatusCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DuoDeviceEnrollmentStatus.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoImportDeviceManualCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "StagesAuthenticatorDuoImportDeviceManualCreateError: Bad request"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoImportDeviceManualCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/duo/{stage_uuid}/import_device_manual/
    /// - Import duo devices into authentik
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - parameter authenticatorDuoStageManualDeviceImportRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorDuoImportDeviceManualCreate(stageUuid: UUID, authenticatorDuoStageManualDeviceImportRequest: AuthenticatorDuoStageManualDeviceImportRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/import_device_manual/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorDuoStageManualDeviceImportRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return StagesAuthenticatorDuoImportDeviceManualCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoImportDeviceManualCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoImportDevicesAutomaticCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "StagesAuthenticatorDuoImportDevicesAutomaticCreateError: Bad request"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoImportDevicesAutomaticCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/duo/{stage_uuid}/import_devices_automatic/
    /// - Import duo devices into authentik
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - returns: AnyPublisher<AuthenticatorDuoStageDeviceImportResponse, Error> 
    open func stagesAuthenticatorDuoImportDevicesAutomaticCreate(stageUuid: UUID) -> AnyPublisher<AuthenticatorDuoStageDeviceImportResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/import_devices_automatic/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorDuoStageDeviceImportResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return StagesAuthenticatorDuoImportDevicesAutomaticCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoImportDevicesAutomaticCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorDuoStageDeviceImportResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/duo/
    /// - AuthenticatorDuoStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter apiHostname: (query)  (optional)
    /// - parameter clientId: (query)  (optional)
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticatorDuoStageList, Error> 
    open func stagesAuthenticatorDuoList(apiHostname: String? = nil, clientId: String? = nil, configureFlow: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedAuthenticatorDuoStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/duo/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let apiHostname = apiHostname { queryItems.append(URLQueryItem(name: "api_hostname", value: apiHostname)) } 
                if let clientId = clientId { queryItems.append(URLQueryItem(name: "client_id", value: clientId)) } 
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticatorDuoStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticatorDuoStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/duo/{stage_uuid}/
    /// - AuthenticatorDuoStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - parameter patchedAuthenticatorDuoStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticatorDuoStage, Error> 
    open func stagesAuthenticatorDuoPartialUpdate(stageUuid: UUID, patchedAuthenticatorDuoStageRequest: PatchedAuthenticatorDuoStageRequest? = nil) -> AnyPublisher<AuthenticatorDuoStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticatorDuoStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorDuoStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorDuoStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/duo/{stage_uuid}/
    /// - AuthenticatorDuoStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - returns: AnyPublisher<AuthenticatorDuoStage, Error> 
    open func stagesAuthenticatorDuoRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticatorDuoStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorDuoStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorDuoStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/duo/{stage_uuid}/
    /// - AuthenticatorDuoStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - parameter authenticatorDuoStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorDuoStage, Error> 
    open func stagesAuthenticatorDuoUpdate(stageUuid: UUID, authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) -> AnyPublisher<AuthenticatorDuoStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticatorDuoStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorDuoStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorDuoStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorDuoUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorDuoUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorDuoUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/duo/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Duo Authenticator Setup Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorDuoUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/duo/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorDuoUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorDuoUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobileCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobileCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobileCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/mobile/
    /// - AuthenticatorMobileStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorMobileStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorMobileStage, Error> 
    open func stagesAuthenticatorMobileCreate(authenticatorMobileStageRequest: AuthenticatorMobileStageRequest) -> AnyPublisher<AuthenticatorMobileStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/mobile/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorMobileStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorMobileStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobileCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobileCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorMobileStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobileDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobileDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobileDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/mobile/{stage_uuid}/
    /// - AuthenticatorMobileStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Mobile Authenticator Setup Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorMobileDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/mobile/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobileDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobileDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobileListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobileListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobileListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/mobile/
    /// - AuthenticatorMobileStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticatorMobileStageList, Error> 
    open func stagesAuthenticatorMobileList(configureFlow: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedAuthenticatorMobileStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/mobile/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticatorMobileStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobileListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobileListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticatorMobileStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobilePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobilePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobilePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/mobile/{stage_uuid}/
    /// - AuthenticatorMobileStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Mobile Authenticator Setup Stage. 
    /// - parameter patchedAuthenticatorMobileStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticatorMobileStage, Error> 
    open func stagesAuthenticatorMobilePartialUpdate(stageUuid: UUID, patchedAuthenticatorMobileStageRequest: PatchedAuthenticatorMobileStageRequest? = nil) -> AnyPublisher<AuthenticatorMobileStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/mobile/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticatorMobileStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorMobileStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobilePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobilePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorMobileStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobileRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobileRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobileRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/mobile/{stage_uuid}/
    /// - AuthenticatorMobileStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Mobile Authenticator Setup Stage. 
    /// - returns: AnyPublisher<AuthenticatorMobileStage, Error> 
    open func stagesAuthenticatorMobileRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticatorMobileStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/mobile/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorMobileStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobileRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobileRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorMobileStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobileUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobileUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobileUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/mobile/{stage_uuid}/
    /// - AuthenticatorMobileStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Mobile Authenticator Setup Stage. 
    /// - parameter authenticatorMobileStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorMobileStage, Error> 
    open func stagesAuthenticatorMobileUpdate(stageUuid: UUID, authenticatorMobileStageRequest: AuthenticatorMobileStageRequest) -> AnyPublisher<AuthenticatorMobileStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/mobile/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticatorMobileStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorMobileStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobileUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobileUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorMobileStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorMobileUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorMobileUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorMobileUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/mobile/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Mobile Authenticator Setup Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorMobileUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/mobile/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorMobileUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorMobileUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorSmsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/sms/
    /// - AuthenticatorSMSStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorSMSStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorSMSStage, Error> 
    open func stagesAuthenticatorSmsCreate(authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) -> AnyPublisher<AuthenticatorSMSStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/sms/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorSMSStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorSMSStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorSMSStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorSmsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/sms/{stage_uuid}/
    /// - AuthenticatorSMSStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this SMS Authenticator Setup Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorSmsDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/sms/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter authType
    ///
    public enum StagesAuthenticatorSmsListAuthType: String, Codable, CaseIterable {
        case basic = "basic"
        case bearer = "bearer"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter provider
    ///
    public enum StagesAuthenticatorSmsListProvider: String, Codable, CaseIterable {
        case generic = "generic"
        case twilio = "twilio"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesAuthenticatorSmsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/sms/
    /// - AuthenticatorSMSStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter accountSid: (query)  (optional)
    /// - parameter auth: (query)  (optional)
    /// - parameter authPassword: (query)  (optional)
    /// - parameter authType: (query) * &#x60;basic&#x60; - Basic * &#x60;bearer&#x60; - Bearer (optional)
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter friendlyName: (query)  (optional)
    /// - parameter fromNumber: (query)  (optional)
    /// - parameter mapping: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter provider: (query) * &#x60;twilio&#x60; - Twilio * &#x60;generic&#x60; - Generic (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter verifyOnly: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticatorSMSStageList, Error> 
    open func stagesAuthenticatorSmsList(accountSid: String? = nil, auth: String? = nil, authPassword: String? = nil, authType: StagesAuthenticatorSmsListAuthType? = nil, configureFlow: UUID? = nil, friendlyName: String? = nil, fromNumber: String? = nil, mapping: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, provider: StagesAuthenticatorSmsListProvider? = nil, search: String? = nil, stageUuid: UUID? = nil, verifyOnly: Bool? = nil) -> AnyPublisher<PaginatedAuthenticatorSMSStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/sms/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountSid = accountSid { queryItems.append(URLQueryItem(name: "account_sid", value: accountSid)) } 
                if let auth = auth { queryItems.append(URLQueryItem(name: "auth", value: auth)) } 
                if let authPassword = authPassword { queryItems.append(URLQueryItem(name: "auth_password", value: authPassword)) } 
                if let authType = authType { queryItems.append(URLQueryItem(name: "auth_type", value: authType.rawValue)) } 
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let friendlyName = friendlyName { queryItems.append(URLQueryItem(name: "friendly_name", value: friendlyName)) } 
                if let fromNumber = fromNumber { queryItems.append(URLQueryItem(name: "from_number", value: fromNumber)) } 
                if let mapping = mapping { queryItems.append(URLQueryItem(name: "mapping", value: mapping.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let provider = provider { queryItems.append(URLQueryItem(name: "provider", value: provider.rawValue)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let verifyOnly = verifyOnly { queryItems.append(URLQueryItem(name: "verify_only", value: verifyOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticatorSMSStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticatorSMSStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorSmsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/sms/{stage_uuid}/
    /// - AuthenticatorSMSStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this SMS Authenticator Setup Stage. 
    /// - parameter patchedAuthenticatorSMSStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticatorSMSStage, Error> 
    open func stagesAuthenticatorSmsPartialUpdate(stageUuid: UUID, patchedAuthenticatorSMSStageRequest: PatchedAuthenticatorSMSStageRequest? = nil) -> AnyPublisher<AuthenticatorSMSStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/sms/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticatorSMSStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorSMSStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorSMSStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorSmsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/sms/{stage_uuid}/
    /// - AuthenticatorSMSStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this SMS Authenticator Setup Stage. 
    /// - returns: AnyPublisher<AuthenticatorSMSStage, Error> 
    open func stagesAuthenticatorSmsRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticatorSMSStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/sms/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorSMSStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorSMSStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorSmsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/sms/{stage_uuid}/
    /// - AuthenticatorSMSStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this SMS Authenticator Setup Stage. 
    /// - parameter authenticatorSMSStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorSMSStage, Error> 
    open func stagesAuthenticatorSmsUpdate(stageUuid: UUID, authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) -> AnyPublisher<AuthenticatorSMSStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/sms/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticatorSMSStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorSMSStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorSMSStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorSmsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorSmsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorSmsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/sms/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this SMS Authenticator Setup Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorSmsUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/sms/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorSmsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorSmsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/static/
    /// - AuthenticatorStaticStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorStaticStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorStaticStage, Error> 
    open func stagesAuthenticatorStaticCreate(authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) -> AnyPublisher<AuthenticatorStaticStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/static/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorStaticStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorStaticStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorStaticStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/static/{stage_uuid}/
    /// - AuthenticatorStaticStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Static Authenticator Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorStaticDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/static/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/static/
    /// - AuthenticatorStaticStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter friendlyName: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter tokenCount: (query)  (optional)
    /// - parameter tokenLength: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticatorStaticStageList, Error> 
    open func stagesAuthenticatorStaticList(configureFlow: UUID? = nil, friendlyName: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil, tokenCount: Int? = nil, tokenLength: Int? = nil) -> AnyPublisher<PaginatedAuthenticatorStaticStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/static/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let friendlyName = friendlyName { queryItems.append(URLQueryItem(name: "friendly_name", value: friendlyName)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let tokenCount = tokenCount { queryItems.append(URLQueryItem(name: "token_count", value: "\(tokenCount)")) } 
                if let tokenLength = tokenLength { queryItems.append(URLQueryItem(name: "token_length", value: "\(tokenLength)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticatorStaticStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticatorStaticStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/static/{stage_uuid}/
    /// - AuthenticatorStaticStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Static Authenticator Stage. 
    /// - parameter patchedAuthenticatorStaticStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticatorStaticStage, Error> 
    open func stagesAuthenticatorStaticPartialUpdate(stageUuid: UUID, patchedAuthenticatorStaticStageRequest: PatchedAuthenticatorStaticStageRequest? = nil) -> AnyPublisher<AuthenticatorStaticStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/static/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticatorStaticStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorStaticStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorStaticStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/static/{stage_uuid}/
    /// - AuthenticatorStaticStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Static Authenticator Stage. 
    /// - returns: AnyPublisher<AuthenticatorStaticStage, Error> 
    open func stagesAuthenticatorStaticRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticatorStaticStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/static/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorStaticStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorStaticStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/static/{stage_uuid}/
    /// - AuthenticatorStaticStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Static Authenticator Stage. 
    /// - parameter authenticatorStaticStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorStaticStage, Error> 
    open func stagesAuthenticatorStaticUpdate(stageUuid: UUID, authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) -> AnyPublisher<AuthenticatorStaticStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/static/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticatorStaticStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorStaticStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorStaticStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorStaticUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorStaticUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorStaticUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/static/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Static Authenticator Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorStaticUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/static/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorStaticUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorStaticUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorTotpCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/totp/
    /// - AuthenticatorTOTPStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorTOTPStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorTOTPStage, Error> 
    open func stagesAuthenticatorTotpCreate(authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) -> AnyPublisher<AuthenticatorTOTPStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/totp/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorTOTPStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorTOTPStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorTOTPStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorTotpDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/totp/{stage_uuid}/
    /// - AuthenticatorTOTPStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this TOTP Authenticator Setup Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorTotpDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/totp/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter digits
    ///
    public enum StagesAuthenticatorTotpListDigits: String, Codable, CaseIterable {
        case _6 = "6"
        case _8 = "8"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesAuthenticatorTotpListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/totp/
    /// - AuthenticatorTOTPStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter digits: (query) * &#x60;6&#x60; - 6 digits, widely compatible * &#x60;8&#x60; - 8 digits, not compatible with apps like Google Authenticator (optional)
    /// - parameter friendlyName: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticatorTOTPStageList, Error> 
    open func stagesAuthenticatorTotpList(configureFlow: UUID? = nil, digits: StagesAuthenticatorTotpListDigits? = nil, friendlyName: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil) -> AnyPublisher<PaginatedAuthenticatorTOTPStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/totp/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let digits = digits { queryItems.append(URLQueryItem(name: "digits", value: digits.rawValue)) } 
                if let friendlyName = friendlyName { queryItems.append(URLQueryItem(name: "friendly_name", value: friendlyName)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticatorTOTPStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticatorTOTPStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorTotpPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/totp/{stage_uuid}/
    /// - AuthenticatorTOTPStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this TOTP Authenticator Setup Stage. 
    /// - parameter patchedAuthenticatorTOTPStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticatorTOTPStage, Error> 
    open func stagesAuthenticatorTotpPartialUpdate(stageUuid: UUID, patchedAuthenticatorTOTPStageRequest: PatchedAuthenticatorTOTPStageRequest? = nil) -> AnyPublisher<AuthenticatorTOTPStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/totp/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticatorTOTPStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorTOTPStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorTOTPStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorTotpRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/totp/{stage_uuid}/
    /// - AuthenticatorTOTPStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this TOTP Authenticator Setup Stage. 
    /// - returns: AnyPublisher<AuthenticatorTOTPStage, Error> 
    open func stagesAuthenticatorTotpRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticatorTOTPStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/totp/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorTOTPStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorTOTPStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorTotpUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/totp/{stage_uuid}/
    /// - AuthenticatorTOTPStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this TOTP Authenticator Setup Stage. 
    /// - parameter authenticatorTOTPStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorTOTPStage, Error> 
    open func stagesAuthenticatorTotpUpdate(stageUuid: UUID, authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) -> AnyPublisher<AuthenticatorTOTPStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/totp/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticatorTOTPStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorTOTPStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorTOTPStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorTotpUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorTotpUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorTotpUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/totp/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this TOTP Authenticator Setup Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorTotpUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/totp/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorTotpUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorTotpUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorValidateCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidateCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidateCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/validate/
    /// - AuthenticatorValidateStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorValidateStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorValidateStage, Error> 
    open func stagesAuthenticatorValidateCreate(authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) -> AnyPublisher<AuthenticatorValidateStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/validate/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticatorValidateStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorValidateStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidateCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidateCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorValidateStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorValidateDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidateDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidateDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/validate/{stage_uuid}/
    /// - AuthenticatorValidateStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Authenticator Validation Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorValidateDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/validate/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidateDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidateDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter notConfiguredAction
    ///
    public enum StagesAuthenticatorValidateListNotConfiguredAction: String, Codable, CaseIterable {
        case configure = "configure"
        case deny = "deny"
        case skip = "skip"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesAuthenticatorValidateListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidateListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidateListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/validate/
    /// - AuthenticatorValidateStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter configurationStages: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter notConfiguredAction: (query) * &#x60;skip&#x60; - Skip * &#x60;deny&#x60; - Deny * &#x60;configure&#x60; - Configure (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticatorValidateStageList, Error> 
    open func stagesAuthenticatorValidateList(configurationStages: [UUID]? = nil, name: String? = nil, notConfiguredAction: StagesAuthenticatorValidateListNotConfiguredAction? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedAuthenticatorValidateStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/validate/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let configurationStages = configurationStages { queryItems.append(URLQueryItem(name: "configuration_stages", value: configurationStages.map { $0.uuidString }.joined(separator: ","))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let notConfiguredAction = notConfiguredAction { queryItems.append(URLQueryItem(name: "not_configured_action", value: notConfiguredAction.rawValue)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticatorValidateStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidateListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidateListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticatorValidateStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorValidatePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidatePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidatePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/validate/{stage_uuid}/
    /// - AuthenticatorValidateStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Authenticator Validation Stage. 
    /// - parameter patchedAuthenticatorValidateStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticatorValidateStage, Error> 
    open func stagesAuthenticatorValidatePartialUpdate(stageUuid: UUID, patchedAuthenticatorValidateStageRequest: PatchedAuthenticatorValidateStageRequest? = nil) -> AnyPublisher<AuthenticatorValidateStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/validate/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticatorValidateStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorValidateStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidatePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidatePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorValidateStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorValidateRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidateRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidateRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/validate/{stage_uuid}/
    /// - AuthenticatorValidateStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Authenticator Validation Stage. 
    /// - returns: AnyPublisher<AuthenticatorValidateStage, Error> 
    open func stagesAuthenticatorValidateRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticatorValidateStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/validate/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorValidateStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidateRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidateRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorValidateStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorValidateUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidateUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidateUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/validate/{stage_uuid}/
    /// - AuthenticatorValidateStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Authenticator Validation Stage. 
    /// - parameter authenticatorValidateStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticatorValidateStage, Error> 
    open func stagesAuthenticatorValidateUpdate(stageUuid: UUID, authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) -> AnyPublisher<AuthenticatorValidateStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/validate/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticatorValidateStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticatorValidateStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidateUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidateUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticatorValidateStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorValidateUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorValidateUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorValidateUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/validate/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Authenticator Validation Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorValidateUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/validate/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorValidateUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorValidateUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorWebauthnCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/authenticator/webauthn/
    /// - AuthenticateWebAuthnStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticateWebAuthnStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticateWebAuthnStage, Error> 
    open func stagesAuthenticatorWebauthnCreate(authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) -> AnyPublisher<AuthenticateWebAuthnStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/webauthn/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(authenticateWebAuthnStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticateWebAuthnStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticateWebAuthnStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorWebauthnDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/authenticator/webauthn/{stage_uuid}/
    /// - AuthenticateWebAuthnStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this WebAuthn Authenticator Setup Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesAuthenticatorWebauthnDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/webauthn/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter authenticatorAttachment
    ///
    public enum StagesAuthenticatorWebauthnListAuthenticatorAttachment: String, Codable, CaseIterable {
        case crossPlatform = "cross-platform"
        case platform = "platform"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter residentKeyRequirement
    ///
    public enum StagesAuthenticatorWebauthnListResidentKeyRequirement: String, Codable, CaseIterable {
        case discouraged = "discouraged"
        case preferred = "preferred"
        case _required = "required"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter userVerification
    ///
    public enum StagesAuthenticatorWebauthnListUserVerification: String, Codable, CaseIterable {
        case discouraged = "discouraged"
        case preferred = "preferred"
        case _required = "required"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesAuthenticatorWebauthnListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/webauthn/
    /// - AuthenticateWebAuthnStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter authenticatorAttachment: (query) * &#x60;platform&#x60; - Platform * &#x60;cross-platform&#x60; - Cross Platform (optional)
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter friendlyName: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter residentKeyRequirement: (query) * &#x60;discouraged&#x60; - Discouraged * &#x60;preferred&#x60; - Preferred * &#x60;required&#x60; - Required (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter userVerification: (query) * &#x60;required&#x60; - Required * &#x60;preferred&#x60; - Preferred * &#x60;discouraged&#x60; - Discouraged (optional)
    /// - returns: AnyPublisher<PaginatedAuthenticateWebAuthnStageList, Error> 
    open func stagesAuthenticatorWebauthnList(authenticatorAttachment: StagesAuthenticatorWebauthnListAuthenticatorAttachment? = nil, configureFlow: UUID? = nil, friendlyName: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, residentKeyRequirement: StagesAuthenticatorWebauthnListResidentKeyRequirement? = nil, search: String? = nil, stageUuid: UUID? = nil, userVerification: StagesAuthenticatorWebauthnListUserVerification? = nil) -> AnyPublisher<PaginatedAuthenticateWebAuthnStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/authenticator/webauthn/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let authenticatorAttachment = authenticatorAttachment { queryItems.append(URLQueryItem(name: "authenticator_attachment", value: authenticatorAttachment.rawValue)) } 
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let friendlyName = friendlyName { queryItems.append(URLQueryItem(name: "friendly_name", value: friendlyName)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let residentKeyRequirement = residentKeyRequirement { queryItems.append(URLQueryItem(name: "resident_key_requirement", value: residentKeyRequirement.rawValue)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let userVerification = userVerification { queryItems.append(URLQueryItem(name: "user_verification", value: userVerification.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedAuthenticateWebAuthnStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedAuthenticateWebAuthnStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorWebauthnPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/authenticator/webauthn/{stage_uuid}/
    /// - AuthenticateWebAuthnStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this WebAuthn Authenticator Setup Stage. 
    /// - parameter patchedAuthenticateWebAuthnStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<AuthenticateWebAuthnStage, Error> 
    open func stagesAuthenticatorWebauthnPartialUpdate(stageUuid: UUID, patchedAuthenticateWebAuthnStageRequest: PatchedAuthenticateWebAuthnStageRequest? = nil) -> AnyPublisher<AuthenticateWebAuthnStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/webauthn/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedAuthenticateWebAuthnStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticateWebAuthnStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticateWebAuthnStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorWebauthnRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/webauthn/{stage_uuid}/
    /// - AuthenticateWebAuthnStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this WebAuthn Authenticator Setup Stage. 
    /// - returns: AnyPublisher<AuthenticateWebAuthnStage, Error> 
    open func stagesAuthenticatorWebauthnRetrieve(stageUuid: UUID) -> AnyPublisher<AuthenticateWebAuthnStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/webauthn/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticateWebAuthnStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticateWebAuthnStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorWebauthnUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/authenticator/webauthn/{stage_uuid}/
    /// - AuthenticateWebAuthnStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this WebAuthn Authenticator Setup Stage. 
    /// - parameter authenticateWebAuthnStageRequest: (body)  
    /// - returns: AnyPublisher<AuthenticateWebAuthnStage, Error> 
    open func stagesAuthenticatorWebauthnUpdate(stageUuid: UUID, authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) -> AnyPublisher<AuthenticateWebAuthnStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/webauthn/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(authenticateWebAuthnStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AuthenticateWebAuthnStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(AuthenticateWebAuthnStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesAuthenticatorWebauthnUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesAuthenticatorWebauthnUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesAuthenticatorWebauthnUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/authenticator/webauthn/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this WebAuthn Authenticator Setup Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesAuthenticatorWebauthnUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/authenticator/webauthn/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesAuthenticatorWebauthnUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/captcha/
    /// - CaptchaStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter captchaStageRequest: (body)  
    /// - returns: AnyPublisher<CaptchaStage, Error> 
    open func stagesCaptchaCreate(captchaStageRequest: CaptchaStageRequest) -> AnyPublisher<CaptchaStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/captcha/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(captchaStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CaptchaStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CaptchaStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/captcha/{stage_uuid}/
    /// - CaptchaStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Captcha Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesCaptchaDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/captcha/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaListError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaListError: : \(object)"
            }
        }
    }

    /// - GET /stages/captcha/
    /// - CaptchaStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter publicKey: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedCaptchaStageList, Error> 
    open func stagesCaptchaList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, publicKey: String? = nil, search: String? = nil) -> AnyPublisher<PaginatedCaptchaStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/captcha/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let publicKey = publicKey { queryItems.append(URLQueryItem(name: "public_key", value: publicKey)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedCaptchaStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedCaptchaStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/captcha/{stage_uuid}/
    /// - CaptchaStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Captcha Stage. 
    /// - parameter patchedCaptchaStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<CaptchaStage, Error> 
    open func stagesCaptchaPartialUpdate(stageUuid: UUID, patchedCaptchaStageRequest: PatchedCaptchaStageRequest? = nil) -> AnyPublisher<CaptchaStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/captcha/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedCaptchaStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CaptchaStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CaptchaStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/captcha/{stage_uuid}/
    /// - CaptchaStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Captcha Stage. 
    /// - returns: AnyPublisher<CaptchaStage, Error> 
    open func stagesCaptchaRetrieve(stageUuid: UUID) -> AnyPublisher<CaptchaStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/captcha/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CaptchaStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CaptchaStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/captcha/{stage_uuid}/
    /// - CaptchaStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Captcha Stage. 
    /// - parameter captchaStageRequest: (body)  
    /// - returns: AnyPublisher<CaptchaStage, Error> 
    open func stagesCaptchaUpdate(stageUuid: UUID, captchaStageRequest: CaptchaStageRequest) -> AnyPublisher<CaptchaStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/captcha/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(captchaStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CaptchaStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CaptchaStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesCaptchaUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesCaptchaUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesCaptchaUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/captcha/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Captcha Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesCaptchaUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/captcha/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesCaptchaUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesCaptchaUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesConsentCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/consent/
    /// - ConsentStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter consentStageRequest: (body)  
    /// - returns: AnyPublisher<ConsentStage, Error> 
    open func stagesConsentCreate(consentStageRequest: ConsentStageRequest) -> AnyPublisher<ConsentStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/consent/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(consentStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConsentStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ConsentStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesConsentDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/consent/{stage_uuid}/
    /// - ConsentStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Consent Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesConsentDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/consent/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter mode
    ///
    public enum StagesConsentListMode: String, Codable, CaseIterable {
        case alwaysRequire = "always_require"
        case expiring = "expiring"
        case permanent = "permanent"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesConsentListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentListError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentListError: : \(object)"
            }
        }
    }

    /// - GET /stages/consent/
    /// - ConsentStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter consentExpireIn: (query)  (optional)
    /// - parameter mode: (query) * &#x60;always_require&#x60; - Always Require * &#x60;permanent&#x60; - Permanent * &#x60;expiring&#x60; - Expiring (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedConsentStageList, Error> 
    open func stagesConsentList(consentExpireIn: String? = nil, mode: StagesConsentListMode? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil) -> AnyPublisher<PaginatedConsentStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/consent/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let consentExpireIn = consentExpireIn { queryItems.append(URLQueryItem(name: "consent_expire_in", value: consentExpireIn)) } 
                if let mode = mode { queryItems.append(URLQueryItem(name: "mode", value: mode.rawValue)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedConsentStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedConsentStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesConsentPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/consent/{stage_uuid}/
    /// - ConsentStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Consent Stage. 
    /// - parameter patchedConsentStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<ConsentStage, Error> 
    open func stagesConsentPartialUpdate(stageUuid: UUID, patchedConsentStageRequest: PatchedConsentStageRequest? = nil) -> AnyPublisher<ConsentStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/consent/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedConsentStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConsentStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ConsentStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesConsentRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/consent/{stage_uuid}/
    /// - ConsentStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Consent Stage. 
    /// - returns: AnyPublisher<ConsentStage, Error> 
    open func stagesConsentRetrieve(stageUuid: UUID) -> AnyPublisher<ConsentStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/consent/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConsentStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ConsentStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesConsentUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/consent/{stage_uuid}/
    /// - ConsentStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Consent Stage. 
    /// - parameter consentStageRequest: (body)  
    /// - returns: AnyPublisher<ConsentStage, Error> 
    open func stagesConsentUpdate(stageUuid: UUID, consentStageRequest: ConsentStageRequest) -> AnyPublisher<ConsentStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/consent/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(consentStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConsentStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ConsentStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesConsentUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesConsentUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesConsentUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/consent/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Consent Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesConsentUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/consent/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesConsentUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesConsentUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/deny/
    /// - DenyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter denyStageRequest: (body)  
    /// - returns: AnyPublisher<DenyStage, Error> 
    open func stagesDenyCreate(denyStageRequest: DenyStageRequest) -> AnyPublisher<DenyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/deny/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(denyStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DenyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DenyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/deny/{stage_uuid}/
    /// - DenyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Deny Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesDenyDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/deny/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyListError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyListError: : \(object)"
            }
        }
    }

    /// - GET /stages/deny/
    /// - DenyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter denyMessage: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedDenyStageList, Error> 
    open func stagesDenyList(denyMessage: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil) -> AnyPublisher<PaginatedDenyStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/deny/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let denyMessage = denyMessage { queryItems.append(URLQueryItem(name: "deny_message", value: denyMessage)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedDenyStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedDenyStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/deny/{stage_uuid}/
    /// - DenyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Deny Stage. 
    /// - parameter patchedDenyStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<DenyStage, Error> 
    open func stagesDenyPartialUpdate(stageUuid: UUID, patchedDenyStageRequest: PatchedDenyStageRequest? = nil) -> AnyPublisher<DenyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/deny/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedDenyStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DenyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DenyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/deny/{stage_uuid}/
    /// - DenyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Deny Stage. 
    /// - returns: AnyPublisher<DenyStage, Error> 
    open func stagesDenyRetrieve(stageUuid: UUID) -> AnyPublisher<DenyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/deny/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DenyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DenyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/deny/{stage_uuid}/
    /// - DenyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Deny Stage. 
    /// - parameter denyStageRequest: (body)  
    /// - returns: AnyPublisher<DenyStage, Error> 
    open func stagesDenyUpdate(stageUuid: UUID, denyStageRequest: DenyStageRequest) -> AnyPublisher<DenyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/deny/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(denyStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DenyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DenyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDenyUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDenyUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesDenyUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/deny/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Deny Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesDenyUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/deny/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDenyUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDenyUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/dummy/
    /// - DummyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter dummyStageRequest: (body)  
    /// - returns: AnyPublisher<DummyStage, Error> 
    open func stagesDummyCreate(dummyStageRequest: DummyStageRequest) -> AnyPublisher<DummyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/dummy/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(dummyStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/dummy/{stage_uuid}/
    /// - DummyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Dummy Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesDummyDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/dummy/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyListError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyListError: : \(object)"
            }
        }
    }

    /// - GET /stages/dummy/
    /// - DummyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter throwError: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedDummyStageList, Error> 
    open func stagesDummyList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil, throwError: Bool? = nil) -> AnyPublisher<PaginatedDummyStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/dummy/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let throwError = throwError { queryItems.append(URLQueryItem(name: "throw_error", value: throwError ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedDummyStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedDummyStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/dummy/{stage_uuid}/
    /// - DummyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Dummy Stage. 
    /// - parameter patchedDummyStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<DummyStage, Error> 
    open func stagesDummyPartialUpdate(stageUuid: UUID, patchedDummyStageRequest: PatchedDummyStageRequest? = nil) -> AnyPublisher<DummyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/dummy/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedDummyStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/dummy/{stage_uuid}/
    /// - DummyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Dummy Stage. 
    /// - returns: AnyPublisher<DummyStage, Error> 
    open func stagesDummyRetrieve(stageUuid: UUID) -> AnyPublisher<DummyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/dummy/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/dummy/{stage_uuid}/
    /// - DummyStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Dummy Stage. 
    /// - parameter dummyStageRequest: (body)  
    /// - returns: AnyPublisher<DummyStage, Error> 
    open func stagesDummyUpdate(stageUuid: UUID, dummyStageRequest: DummyStageRequest) -> AnyPublisher<DummyStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/dummy/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(dummyStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DummyStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DummyStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesDummyUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesDummyUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesDummyUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/dummy/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Dummy Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesDummyUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/dummy/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesDummyUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesDummyUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/email/
    /// - EmailStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter emailStageRequest: (body)  
    /// - returns: AnyPublisher<EmailStage, Error> 
    open func stagesEmailCreate(emailStageRequest: EmailStageRequest) -> AnyPublisher<EmailStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/email/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(emailStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmailStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EmailStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/email/{stage_uuid}/
    /// - EmailStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Email Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesEmailDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/email/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailListError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailListError: : \(object)"
            }
        }
    }

    /// - GET /stages/email/
    /// - EmailStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter activateUserOnSuccess: (query)  (optional)
    /// - parameter fromAddress: (query)  (optional)
    /// - parameter host: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter port: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter subject: (query)  (optional)
    /// - parameter template: (query)  (optional)
    /// - parameter timeout: (query)  (optional)
    /// - parameter tokenExpiry: (query)  (optional)
    /// - parameter useGlobalSettings: (query)  (optional)
    /// - parameter useSsl: (query)  (optional)
    /// - parameter useTls: (query)  (optional)
    /// - parameter username: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedEmailStageList, Error> 
    open func stagesEmailList(activateUserOnSuccess: Bool? = nil, fromAddress: String? = nil, host: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, port: Int? = nil, search: String? = nil, subject: String? = nil, template: String? = nil, timeout: Int? = nil, tokenExpiry: Int? = nil, useGlobalSettings: Bool? = nil, useSsl: Bool? = nil, useTls: Bool? = nil, username: String? = nil) -> AnyPublisher<PaginatedEmailStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/email/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let activateUserOnSuccess = activateUserOnSuccess { queryItems.append(URLQueryItem(name: "activate_user_on_success", value: activateUserOnSuccess ? "true" : "false")) } 
                if let fromAddress = fromAddress { queryItems.append(URLQueryItem(name: "from_address", value: fromAddress)) } 
                if let host = host { queryItems.append(URLQueryItem(name: "host", value: host)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let port = port { queryItems.append(URLQueryItem(name: "port", value: "\(port)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let subject = subject { queryItems.append(URLQueryItem(name: "subject", value: subject)) } 
                if let template = template { queryItems.append(URLQueryItem(name: "template", value: template)) } 
                if let timeout = timeout { queryItems.append(URLQueryItem(name: "timeout", value: "\(timeout)")) } 
                if let tokenExpiry = tokenExpiry { queryItems.append(URLQueryItem(name: "token_expiry", value: "\(tokenExpiry)")) } 
                if let useGlobalSettings = useGlobalSettings { queryItems.append(URLQueryItem(name: "use_global_settings", value: useGlobalSettings ? "true" : "false")) } 
                if let useSsl = useSsl { queryItems.append(URLQueryItem(name: "use_ssl", value: useSsl ? "true" : "false")) } 
                if let useTls = useTls { queryItems.append(URLQueryItem(name: "use_tls", value: useTls ? "true" : "false")) } 
                if let username = username { queryItems.append(URLQueryItem(name: "username", value: username)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedEmailStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedEmailStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/email/{stage_uuid}/
    /// - EmailStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Email Stage. 
    /// - parameter patchedEmailStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<EmailStage, Error> 
    open func stagesEmailPartialUpdate(stageUuid: UUID, patchedEmailStageRequest: PatchedEmailStageRequest? = nil) -> AnyPublisher<EmailStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/email/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedEmailStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmailStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EmailStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/email/{stage_uuid}/
    /// - EmailStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Email Stage. 
    /// - returns: AnyPublisher<EmailStage, Error> 
    open func stagesEmailRetrieve(stageUuid: UUID) -> AnyPublisher<EmailStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/email/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmailStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EmailStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailTemplatesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailTemplatesListError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailTemplatesListError: : \(object)"
            }
        }
    }

    /// - GET /stages/email/templates/
    /// - Get all available templates, including custom templates
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<[TypeCreate], Error> 
    open func stagesEmailTemplatesList() -> AnyPublisher<[TypeCreate], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/email/templates/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TypeCreate], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailTemplatesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailTemplatesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([TypeCreate].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/email/{stage_uuid}/
    /// - EmailStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Email Stage. 
    /// - parameter emailStageRequest: (body)  
    /// - returns: AnyPublisher<EmailStage, Error> 
    open func stagesEmailUpdate(stageUuid: UUID, emailStageRequest: EmailStageRequest) -> AnyPublisher<EmailStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/email/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(emailStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmailStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(EmailStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesEmailUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesEmailUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesEmailUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/email/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Email Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesEmailUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/email/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesEmailUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesEmailUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/identification/
    /// - IdentificationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter identificationStageRequest: (body)  
    /// - returns: AnyPublisher<IdentificationStage, Error> 
    open func stagesIdentificationCreate(identificationStageRequest: IdentificationStageRequest) -> AnyPublisher<IdentificationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/identification/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(identificationStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<IdentificationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(IdentificationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/identification/{stage_uuid}/
    /// - IdentificationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Identification Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesIdentificationDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/identification/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationListError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationListError: : \(object)"
            }
        }
    }

    /// - GET /stages/identification/
    /// - IdentificationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter caseInsensitiveMatching: (query)  (optional)
    /// - parameter enrollmentFlow: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter passwordStage: (query)  (optional)
    /// - parameter passwordlessFlow: (query)  (optional)
    /// - parameter recoveryFlow: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter showMatchedUser: (query)  (optional)
    /// - parameter showSourceLabels: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedIdentificationStageList, Error> 
    open func stagesIdentificationList(caseInsensitiveMatching: Bool? = nil, enrollmentFlow: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, passwordStage: UUID? = nil, passwordlessFlow: UUID? = nil, recoveryFlow: UUID? = nil, search: String? = nil, showMatchedUser: Bool? = nil, showSourceLabels: Bool? = nil) -> AnyPublisher<PaginatedIdentificationStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/identification/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let caseInsensitiveMatching = caseInsensitiveMatching { queryItems.append(URLQueryItem(name: "case_insensitive_matching", value: caseInsensitiveMatching ? "true" : "false")) } 
                if let enrollmentFlow = enrollmentFlow { queryItems.append(URLQueryItem(name: "enrollment_flow", value: enrollmentFlow.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let passwordStage = passwordStage { queryItems.append(URLQueryItem(name: "password_stage", value: passwordStage.uuidString)) } 
                if let passwordlessFlow = passwordlessFlow { queryItems.append(URLQueryItem(name: "passwordless_flow", value: passwordlessFlow.uuidString)) } 
                if let recoveryFlow = recoveryFlow { queryItems.append(URLQueryItem(name: "recovery_flow", value: recoveryFlow.uuidString)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let showMatchedUser = showMatchedUser { queryItems.append(URLQueryItem(name: "show_matched_user", value: showMatchedUser ? "true" : "false")) } 
                if let showSourceLabels = showSourceLabels { queryItems.append(URLQueryItem(name: "show_source_labels", value: showSourceLabels ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedIdentificationStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedIdentificationStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/identification/{stage_uuid}/
    /// - IdentificationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Identification Stage. 
    /// - parameter patchedIdentificationStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<IdentificationStage, Error> 
    open func stagesIdentificationPartialUpdate(stageUuid: UUID, patchedIdentificationStageRequest: PatchedIdentificationStageRequest? = nil) -> AnyPublisher<IdentificationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/identification/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedIdentificationStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<IdentificationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(IdentificationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/identification/{stage_uuid}/
    /// - IdentificationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Identification Stage. 
    /// - returns: AnyPublisher<IdentificationStage, Error> 
    open func stagesIdentificationRetrieve(stageUuid: UUID) -> AnyPublisher<IdentificationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/identification/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<IdentificationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(IdentificationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/identification/{stage_uuid}/
    /// - IdentificationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Identification Stage. 
    /// - parameter identificationStageRequest: (body)  
    /// - returns: AnyPublisher<IdentificationStage, Error> 
    open func stagesIdentificationUpdate(stageUuid: UUID, identificationStageRequest: IdentificationStageRequest) -> AnyPublisher<IdentificationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/identification/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(identificationStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<IdentificationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(IdentificationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesIdentificationUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesIdentificationUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesIdentificationUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/identification/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Identification Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesIdentificationUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/identification/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesIdentificationUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesIdentificationUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/invitation/invitations/
    /// - Invitation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter invitationRequest: (body)  
    /// - returns: AnyPublisher<Invitation, Error> 
    open func stagesInvitationInvitationsCreate(invitationRequest: InvitationRequest) -> AnyPublisher<Invitation, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/invitation/invitations/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(invitationRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Invitation, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Invitation.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/invitation/invitations/{invite_uuid}/
    /// - Invitation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter inviteUuid: (path) A UUID string identifying this Invitation. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesInvitationInvitationsDestroy(inviteUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/invitations/{invite_uuid}/"
                path = path.replacingOccurrences(of: "{invite_uuid}", with: inviteUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsListError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsListError: : \(object)"
            }
        }
    }

    /// - GET /stages/invitation/invitations/
    /// - Invitation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter createdByUsername: (query)  (optional)
    /// - parameter expires: (query)  (optional)
    /// - parameter flowSlug: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedInvitationList, Error> 
    open func stagesInvitationInvitationsList(createdByUsername: String? = nil, expires: Date? = nil, flowSlug: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedInvitationList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/invitation/invitations/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let createdByUsername = createdByUsername { queryItems.append(URLQueryItem(name: "created_by__username", value: createdByUsername)) } 
                if let expires = expires { queryItems.append(URLQueryItem(name: "expires", value: OpenISO8601DateFormatter.shared.string(from: expires))) } 
                if let flowSlug = flowSlug { queryItems.append(URLQueryItem(name: "flow__slug", value: flowSlug)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedInvitationList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedInvitationList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/invitation/invitations/{invite_uuid}/
    /// - Invitation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter inviteUuid: (path) A UUID string identifying this Invitation. 
    /// - parameter patchedInvitationRequest: (body)  (optional)
    /// - returns: AnyPublisher<Invitation, Error> 
    open func stagesInvitationInvitationsPartialUpdate(inviteUuid: UUID, patchedInvitationRequest: PatchedInvitationRequest? = nil) -> AnyPublisher<Invitation, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/invitations/{invite_uuid}/"
                path = path.replacingOccurrences(of: "{invite_uuid}", with: inviteUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedInvitationRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Invitation, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Invitation.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/invitation/invitations/{invite_uuid}/
    /// - Invitation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter inviteUuid: (path) A UUID string identifying this Invitation. 
    /// - returns: AnyPublisher<Invitation, Error> 
    open func stagesInvitationInvitationsRetrieve(inviteUuid: UUID) -> AnyPublisher<Invitation, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/invitations/{invite_uuid}/"
                path = path.replacingOccurrences(of: "{invite_uuid}", with: inviteUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Invitation, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Invitation.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/invitation/invitations/{invite_uuid}/
    /// - Invitation Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter inviteUuid: (path) A UUID string identifying this Invitation. 
    /// - parameter invitationRequest: (body)  
    /// - returns: AnyPublisher<Invitation, Error> 
    open func stagesInvitationInvitationsUpdate(inviteUuid: UUID, invitationRequest: InvitationRequest) -> AnyPublisher<Invitation, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/invitations/{invite_uuid}/"
                path = path.replacingOccurrences(of: "{invite_uuid}", with: inviteUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(invitationRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Invitation, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Invitation.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationInvitationsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationInvitationsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationInvitationsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/invitation/invitations/{invite_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter inviteUuid: (path) A UUID string identifying this Invitation. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesInvitationInvitationsUsedByList(inviteUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/invitations/{invite_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{invite_uuid}", with: inviteUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationInvitationsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationInvitationsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/invitation/stages/
    /// - InvitationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter invitationStageRequest: (body)  
    /// - returns: AnyPublisher<InvitationStage, Error> 
    open func stagesInvitationStagesCreate(invitationStageRequest: InvitationStageRequest) -> AnyPublisher<InvitationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/invitation/stages/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(invitationStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<InvitationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(InvitationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/invitation/stages/{stage_uuid}/
    /// - InvitationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Invitation Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesInvitationStagesDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesListError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesListError: : \(object)"
            }
        }
    }

    /// - GET /stages/invitation/stages/
    /// - InvitationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter continueFlowWithoutInvitation: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter noFlows: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedInvitationStageList, Error> 
    open func stagesInvitationStagesList(continueFlowWithoutInvitation: Bool? = nil, name: String? = nil, noFlows: Bool? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil) -> AnyPublisher<PaginatedInvitationStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/invitation/stages/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let continueFlowWithoutInvitation = continueFlowWithoutInvitation { queryItems.append(URLQueryItem(name: "continue_flow_without_invitation", value: continueFlowWithoutInvitation ? "true" : "false")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let noFlows = noFlows { queryItems.append(URLQueryItem(name: "no_flows", value: noFlows ? "true" : "false")) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedInvitationStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedInvitationStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/invitation/stages/{stage_uuid}/
    /// - InvitationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Invitation Stage. 
    /// - parameter patchedInvitationStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<InvitationStage, Error> 
    open func stagesInvitationStagesPartialUpdate(stageUuid: UUID, patchedInvitationStageRequest: PatchedInvitationStageRequest? = nil) -> AnyPublisher<InvitationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedInvitationStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<InvitationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(InvitationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/invitation/stages/{stage_uuid}/
    /// - InvitationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Invitation Stage. 
    /// - returns: AnyPublisher<InvitationStage, Error> 
    open func stagesInvitationStagesRetrieve(stageUuid: UUID) -> AnyPublisher<InvitationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<InvitationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(InvitationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/invitation/stages/{stage_uuid}/
    /// - InvitationStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Invitation Stage. 
    /// - parameter invitationStageRequest: (body)  
    /// - returns: AnyPublisher<InvitationStage, Error> 
    open func stagesInvitationStagesUpdate(stageUuid: UUID, invitationStageRequest: InvitationStageRequest) -> AnyPublisher<InvitationStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(invitationStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<InvitationStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(InvitationStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesInvitationStagesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesInvitationStagesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesInvitationStagesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/invitation/stages/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Invitation Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesInvitationStagesUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/invitation/stages/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesInvitationStagesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesInvitationStagesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/password/
    /// - PasswordStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter passwordStageRequest: (body)  
    /// - returns: AnyPublisher<PasswordStage, Error> 
    open func stagesPasswordCreate(passwordStageRequest: PasswordStageRequest) -> AnyPublisher<PasswordStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/password/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(passwordStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/password/{stage_uuid}/
    /// - PasswordStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Password Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesPasswordDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/password/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordListError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordListError: : \(object)"
            }
        }
    }

    /// - GET /stages/password/
    /// - PasswordStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter configureFlow: (query)  (optional)
    /// - parameter failedAttemptsBeforeCancel: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - returns: AnyPublisher<PaginatedPasswordStageList, Error> 
    open func stagesPasswordList(configureFlow: UUID? = nil, failedAttemptsBeforeCancel: Int? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil) -> AnyPublisher<PaginatedPasswordStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/password/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let configureFlow = configureFlow { queryItems.append(URLQueryItem(name: "configure_flow", value: configureFlow.uuidString)) } 
                if let failedAttemptsBeforeCancel = failedAttemptsBeforeCancel { queryItems.append(URLQueryItem(name: "failed_attempts_before_cancel", value: "\(failedAttemptsBeforeCancel)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPasswordStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPasswordStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/password/{stage_uuid}/
    /// - PasswordStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Password Stage. 
    /// - parameter patchedPasswordStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<PasswordStage, Error> 
    open func stagesPasswordPartialUpdate(stageUuid: UUID, patchedPasswordStageRequest: PatchedPasswordStageRequest? = nil) -> AnyPublisher<PasswordStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/password/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPasswordStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/password/{stage_uuid}/
    /// - PasswordStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Password Stage. 
    /// - returns: AnyPublisher<PasswordStage, Error> 
    open func stagesPasswordRetrieve(stageUuid: UUID) -> AnyPublisher<PasswordStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/password/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/password/{stage_uuid}/
    /// - PasswordStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Password Stage. 
    /// - parameter passwordStageRequest: (body)  
    /// - returns: AnyPublisher<PasswordStage, Error> 
    open func stagesPasswordUpdate(stageUuid: UUID, passwordStageRequest: PasswordStageRequest) -> AnyPublisher<PasswordStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/password/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(passwordStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PasswordStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PasswordStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPasswordUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPasswordUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesPasswordUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/password/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Password Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesPasswordUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/password/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPasswordUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPasswordUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/prompt/prompts/
    /// - Prompt Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptRequest: (body)  
    /// - returns: AnyPublisher<Prompt, Error> 
    open func stagesPromptPromptsCreate(promptRequest: PromptRequest) -> AnyPublisher<Prompt, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/prompt/prompts/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(promptRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Prompt, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Prompt.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/prompt/prompts/{prompt_uuid}/
    /// - Prompt Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptUuid: (path) A UUID string identifying this Prompt. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesPromptPromptsDestroy(promptUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/prompts/{prompt_uuid}/"
                path = path.replacingOccurrences(of: "{prompt_uuid}", with: promptUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter type
    ///
    public enum StagesPromptPromptsListModelType: String, Codable, CaseIterable {
        case akLocale = "ak-locale"
        case checkbox = "checkbox"
        case date = "date"
        case dateTime = "date-time"
        case dropdown = "dropdown"
        case email = "email"
        case file = "file"
        case hidden = "hidden"
        case number = "number"
        case password = "password"
        case radioButtonGroup = "radio-button-group"
        case separator = "separator"
        case _static = "static"
        case text = "text"
        case textArea = "text_area"
        case textAreaReadOnly = "text_area_read_only"
        case textReadOnly = "text_read_only"
        case username = "username"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesPromptPromptsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsListError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsListError: : \(object)"
            }
        }
    }

    /// - GET /stages/prompt/prompts/
    /// - Prompt Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fieldKey: (query)  (optional)
    /// - parameter label: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter placeholder: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter type: (query) * &#x60;text&#x60; - Text: Simple Text input * &#x60;text_area&#x60; - Text area: Multiline Text Input. * &#x60;text_read_only&#x60; - Text (read-only): Simple Text input, but cannot be edited. * &#x60;text_area_read_only&#x60; - Text area (read-only): Multiline Text input, but cannot be edited. * &#x60;username&#x60; - Username: Same as Text input, but checks for and prevents duplicate usernames. * &#x60;email&#x60; - Email: Text field with Email type. * &#x60;password&#x60; - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * &#x60;number&#x60; - Number * &#x60;checkbox&#x60; - Checkbox * &#x60;radio-button-group&#x60; - Fixed choice field rendered as a group of radio buttons. * &#x60;dropdown&#x60; - Fixed choice field rendered as a dropdown. * &#x60;date&#x60; - Date * &#x60;date-time&#x60; - Date Time * &#x60;file&#x60; - File: File upload for arbitrary files. File content will be available in flow context as data-URI * &#x60;separator&#x60; - Separator: Static Separator Line * &#x60;hidden&#x60; - Hidden: Hidden field, can be used to insert data into form. * &#x60;static&#x60; - Static: Static value, displayed as-is. * &#x60;ak-locale&#x60; - authentik: Selection of locales authentik supports (optional)
    /// - returns: AnyPublisher<PaginatedPromptList, Error> 
    open func stagesPromptPromptsList(fieldKey: String? = nil, label: String? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, placeholder: String? = nil, search: String? = nil, type: StagesPromptPromptsListModelType? = nil) -> AnyPublisher<PaginatedPromptList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/prompt/prompts/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let fieldKey = fieldKey { queryItems.append(URLQueryItem(name: "field_key", value: fieldKey)) } 
                if let label = label { queryItems.append(URLQueryItem(name: "label", value: label)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let placeholder = placeholder { queryItems.append(URLQueryItem(name: "placeholder", value: placeholder)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPromptList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPromptList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/prompt/prompts/{prompt_uuid}/
    /// - Prompt Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptUuid: (path) A UUID string identifying this Prompt. 
    /// - parameter patchedPromptRequest: (body)  (optional)
    /// - returns: AnyPublisher<Prompt, Error> 
    open func stagesPromptPromptsPartialUpdate(promptUuid: UUID, patchedPromptRequest: PatchedPromptRequest? = nil) -> AnyPublisher<Prompt, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/prompts/{prompt_uuid}/"
                path = path.replacingOccurrences(of: "{prompt_uuid}", with: promptUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPromptRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Prompt, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Prompt.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsPreviewCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsPreviewCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsPreviewCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/prompt/prompts/preview/
    /// - Preview a prompt as a challenge, just like a flow would receive
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptRequest: (body)  
    /// - returns: AnyPublisher<PromptChallenge, Error> 
    open func stagesPromptPromptsPreviewCreate(promptRequest: PromptRequest) -> AnyPublisher<PromptChallenge, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/prompt/prompts/preview/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(promptRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PromptChallenge, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsPreviewCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsPreviewCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PromptChallenge.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/prompt/prompts/{prompt_uuid}/
    /// - Prompt Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptUuid: (path) A UUID string identifying this Prompt. 
    /// - returns: AnyPublisher<Prompt, Error> 
    open func stagesPromptPromptsRetrieve(promptUuid: UUID) -> AnyPublisher<Prompt, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/prompts/{prompt_uuid}/"
                path = path.replacingOccurrences(of: "{prompt_uuid}", with: promptUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Prompt, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Prompt.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/prompt/prompts/{prompt_uuid}/
    /// - Prompt Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptUuid: (path) A UUID string identifying this Prompt. 
    /// - parameter promptRequest: (body)  
    /// - returns: AnyPublisher<Prompt, Error> 
    open func stagesPromptPromptsUpdate(promptUuid: UUID, promptRequest: PromptRequest) -> AnyPublisher<Prompt, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/prompts/{prompt_uuid}/"
                path = path.replacingOccurrences(of: "{prompt_uuid}", with: promptUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(promptRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Prompt, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Prompt.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptPromptsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptPromptsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptPromptsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/prompt/prompts/{prompt_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptUuid: (path) A UUID string identifying this Prompt. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesPromptPromptsUsedByList(promptUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/prompts/{prompt_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{prompt_uuid}", with: promptUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptPromptsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptPromptsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/prompt/stages/
    /// - PromptStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter promptStageRequest: (body)  
    /// - returns: AnyPublisher<PromptStage, Error> 
    open func stagesPromptStagesCreate(promptStageRequest: PromptStageRequest) -> AnyPublisher<PromptStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/prompt/stages/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(promptStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PromptStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PromptStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/prompt/stages/{stage_uuid}/
    /// - PromptStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Prompt Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesPromptStagesDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesListError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesListError: : \(object)"
            }
        }
    }

    /// - GET /stages/prompt/stages/
    /// - PromptStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fields: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter validationPolicies: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedPromptStageList, Error> 
    open func stagesPromptStagesList(fields: [UUID]? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil, validationPolicies: [UUID]? = nil) -> AnyPublisher<PaginatedPromptStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/prompt/stages/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let fields = fields { queryItems.append(URLQueryItem(name: "fields", value: fields.map { $0.uuidString }.joined(separator: ","))) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let validationPolicies = validationPolicies { queryItems.append(URLQueryItem(name: "validation_policies", value: validationPolicies.map { $0.uuidString }.joined(separator: ","))) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedPromptStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedPromptStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/prompt/stages/{stage_uuid}/
    /// - PromptStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Prompt Stage. 
    /// - parameter patchedPromptStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<PromptStage, Error> 
    open func stagesPromptStagesPartialUpdate(stageUuid: UUID, patchedPromptStageRequest: PatchedPromptStageRequest? = nil) -> AnyPublisher<PromptStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedPromptStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PromptStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PromptStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/prompt/stages/{stage_uuid}/
    /// - PromptStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Prompt Stage. 
    /// - returns: AnyPublisher<PromptStage, Error> 
    open func stagesPromptStagesRetrieve(stageUuid: UUID) -> AnyPublisher<PromptStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PromptStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PromptStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/prompt/stages/{stage_uuid}/
    /// - PromptStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Prompt Stage. 
    /// - parameter promptStageRequest: (body)  
    /// - returns: AnyPublisher<PromptStage, Error> 
    open func stagesPromptStagesUpdate(stageUuid: UUID, promptStageRequest: PromptStageRequest) -> AnyPublisher<PromptStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/stages/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(promptStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PromptStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PromptStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesPromptStagesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesPromptStagesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesPromptStagesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/prompt/stages/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this Prompt Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesPromptStagesUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/prompt/stages/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesPromptStagesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesPromptStagesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeleteCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeleteCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeleteCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/user_delete/
    /// - UserDeleteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userDeleteStageRequest: (body)  
    /// - returns: AnyPublisher<UserDeleteStage, Error> 
    open func stagesUserDeleteCreate(userDeleteStageRequest: UserDeleteStageRequest) -> AnyPublisher<UserDeleteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_delete/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(userDeleteStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserDeleteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeleteCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeleteCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserDeleteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeleteDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeleteDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeleteDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/user_delete/{stage_uuid}/
    /// - UserDeleteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Delete Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesUserDeleteDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_delete/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeleteDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeleteDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeleteListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeleteListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeleteListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_delete/
    /// - UserDeleteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedUserDeleteStageList, Error> 
    open func stagesUserDeleteList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil) -> AnyPublisher<PaginatedUserDeleteStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_delete/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserDeleteStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeleteListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeleteListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserDeleteStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeletePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeletePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeletePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/user_delete/{stage_uuid}/
    /// - UserDeleteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Delete Stage. 
    /// - parameter patchedUserDeleteStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<UserDeleteStage, Error> 
    open func stagesUserDeletePartialUpdate(stageUuid: UUID, patchedUserDeleteStageRequest: PatchedUserDeleteStageRequest? = nil) -> AnyPublisher<UserDeleteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_delete/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedUserDeleteStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserDeleteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeletePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeletePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserDeleteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeleteRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeleteRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeleteRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_delete/{stage_uuid}/
    /// - UserDeleteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Delete Stage. 
    /// - returns: AnyPublisher<UserDeleteStage, Error> 
    open func stagesUserDeleteRetrieve(stageUuid: UUID) -> AnyPublisher<UserDeleteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_delete/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserDeleteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeleteRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeleteRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserDeleteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeleteUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeleteUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeleteUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/user_delete/{stage_uuid}/
    /// - UserDeleteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Delete Stage. 
    /// - parameter userDeleteStageRequest: (body)  
    /// - returns: AnyPublisher<UserDeleteStage, Error> 
    open func stagesUserDeleteUpdate(stageUuid: UUID, userDeleteStageRequest: UserDeleteStageRequest) -> AnyPublisher<UserDeleteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_delete/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(userDeleteStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserDeleteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeleteUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeleteUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserDeleteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserDeleteUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserDeleteUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserDeleteUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_delete/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Delete Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesUserDeleteUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_delete/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserDeleteUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserDeleteUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/user_login/
    /// - UserLoginStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userLoginStageRequest: (body)  
    /// - returns: AnyPublisher<UserLoginStage, Error> 
    open func stagesUserLoginCreate(userLoginStageRequest: UserLoginStageRequest) -> AnyPublisher<UserLoginStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_login/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(userLoginStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLoginStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLoginStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/user_login/{stage_uuid}/
    /// - UserLoginStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Login Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesUserLoginDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_login/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_login/
    /// - UserLoginStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter rememberMeOffset: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter sessionDuration: (query)  (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter terminateOtherSessions: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedUserLoginStageList, Error> 
    open func stagesUserLoginList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, rememberMeOffset: String? = nil, search: String? = nil, sessionDuration: String? = nil, stageUuid: UUID? = nil, terminateOtherSessions: Bool? = nil) -> AnyPublisher<PaginatedUserLoginStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_login/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let rememberMeOffset = rememberMeOffset { queryItems.append(URLQueryItem(name: "remember_me_offset", value: rememberMeOffset)) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let sessionDuration = sessionDuration { queryItems.append(URLQueryItem(name: "session_duration", value: sessionDuration)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let terminateOtherSessions = terminateOtherSessions { queryItems.append(URLQueryItem(name: "terminate_other_sessions", value: terminateOtherSessions ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserLoginStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserLoginStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/user_login/{stage_uuid}/
    /// - UserLoginStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Login Stage. 
    /// - parameter patchedUserLoginStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<UserLoginStage, Error> 
    open func stagesUserLoginPartialUpdate(stageUuid: UUID, patchedUserLoginStageRequest: PatchedUserLoginStageRequest? = nil) -> AnyPublisher<UserLoginStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_login/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedUserLoginStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLoginStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLoginStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_login/{stage_uuid}/
    /// - UserLoginStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Login Stage. 
    /// - returns: AnyPublisher<UserLoginStage, Error> 
    open func stagesUserLoginRetrieve(stageUuid: UUID) -> AnyPublisher<UserLoginStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_login/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLoginStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLoginStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/user_login/{stage_uuid}/
    /// - UserLoginStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Login Stage. 
    /// - parameter userLoginStageRequest: (body)  
    /// - returns: AnyPublisher<UserLoginStage, Error> 
    open func stagesUserLoginUpdate(stageUuid: UUID, userLoginStageRequest: UserLoginStageRequest) -> AnyPublisher<UserLoginStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_login/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(userLoginStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLoginStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLoginStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLoginUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLoginUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLoginUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_login/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Login Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesUserLoginUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_login/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLoginUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLoginUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/user_logout/
    /// - UserLogoutStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userLogoutStageRequest: (body)  
    /// - returns: AnyPublisher<UserLogoutStage, Error> 
    open func stagesUserLogoutCreate(userLogoutStageRequest: UserLogoutStageRequest) -> AnyPublisher<UserLogoutStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_logout/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(userLogoutStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLogoutStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLogoutStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/user_logout/{stage_uuid}/
    /// - UserLogoutStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Logout Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesUserLogoutDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_logout/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_logout/
    /// - UserLogoutStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedUserLogoutStageList, Error> 
    open func stagesUserLogoutList(name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil) -> AnyPublisher<PaginatedUserLogoutStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_logout/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserLogoutStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserLogoutStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/user_logout/{stage_uuid}/
    /// - UserLogoutStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Logout Stage. 
    /// - parameter patchedUserLogoutStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<UserLogoutStage, Error> 
    open func stagesUserLogoutPartialUpdate(stageUuid: UUID, patchedUserLogoutStageRequest: PatchedUserLogoutStageRequest? = nil) -> AnyPublisher<UserLogoutStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_logout/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedUserLogoutStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLogoutStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLogoutStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_logout/{stage_uuid}/
    /// - UserLogoutStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Logout Stage. 
    /// - returns: AnyPublisher<UserLogoutStage, Error> 
    open func stagesUserLogoutRetrieve(stageUuid: UUID) -> AnyPublisher<UserLogoutStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_logout/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLogoutStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLogoutStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/user_logout/{stage_uuid}/
    /// - UserLogoutStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Logout Stage. 
    /// - parameter userLogoutStageRequest: (body)  
    /// - returns: AnyPublisher<UserLogoutStage, Error> 
    open func stagesUserLogoutUpdate(stageUuid: UUID, userLogoutStageRequest: UserLogoutStageRequest) -> AnyPublisher<UserLogoutStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_logout/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(userLogoutStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLogoutStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserLogoutStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserLogoutUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserLogoutUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserLogoutUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_logout/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Logout Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesUserLogoutUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_logout/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserLogoutUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserLogoutUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserWriteCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWriteCreateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWriteCreateError: : \(object)"
            }
        }
    }

    /// - POST /stages/user_write/
    /// - UserWriteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter userWriteStageRequest: (body)  
    /// - returns: AnyPublisher<UserWriteStage, Error> 
    open func stagesUserWriteCreate(userWriteStageRequest: UserWriteStageRequest) -> AnyPublisher<UserWriteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_write/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(userWriteStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserWriteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWriteCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWriteCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserWriteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserWriteDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWriteDestroyError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWriteDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /stages/user_write/{stage_uuid}/
    /// - UserWriteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Write Stage. 
    /// - returns: AnyPublisher<Void, Error> 
    open func stagesUserWriteDestroy(stageUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_write/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWriteDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWriteDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter userCreationMode
    ///
    public enum StagesUserWriteListUserCreationMode: String, Codable, CaseIterable {
        case alwaysCreate = "always_create"
        case createWhenRequired = "create_when_required"
        case neverCreate = "never_create"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter userType
    ///
    public enum StagesUserWriteListUserType: String, Codable, CaseIterable {
        case external = "external"
        case _internal = "internal"
        case internalServiceAccount = "internal_service_account"
        case serviceAccount = "service_account"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum StagesUserWriteListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWriteListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWriteListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_write/
    /// - UserWriteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter createUsersAsInactive: (query)  (optional)
    /// - parameter createUsersGroup: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stageUuid: (query)  (optional)
    /// - parameter userCreationMode: (query) * &#x60;never_create&#x60; - Never Create * &#x60;create_when_required&#x60; - Create When Required * &#x60;always_create&#x60; - Always Create (optional)
    /// - parameter userPathTemplate: (query)  (optional)
    /// - parameter userType: (query) * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
    /// - returns: AnyPublisher<PaginatedUserWriteStageList, Error> 
    open func stagesUserWriteList(createUsersAsInactive: Bool? = nil, createUsersGroup: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, stageUuid: UUID? = nil, userCreationMode: StagesUserWriteListUserCreationMode? = nil, userPathTemplate: String? = nil, userType: StagesUserWriteListUserType? = nil) -> AnyPublisher<PaginatedUserWriteStageList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/stages/user_write/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let createUsersAsInactive = createUsersAsInactive { queryItems.append(URLQueryItem(name: "create_users_as_inactive", value: createUsersAsInactive ? "true" : "false")) } 
                if let createUsersGroup = createUsersGroup { queryItems.append(URLQueryItem(name: "create_users_group", value: createUsersGroup.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stageUuid = stageUuid { queryItems.append(URLQueryItem(name: "stage_uuid", value: stageUuid.uuidString)) } 
                if let userCreationMode = userCreationMode { queryItems.append(URLQueryItem(name: "user_creation_mode", value: userCreationMode.rawValue)) } 
                if let userPathTemplate = userPathTemplate { queryItems.append(URLQueryItem(name: "user_path_template", value: userPathTemplate)) } 
                if let userType = userType { queryItems.append(URLQueryItem(name: "user_type", value: userType.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedUserWriteStageList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWriteListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWriteListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedUserWriteStageList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserWritePartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWritePartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWritePartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /stages/user_write/{stage_uuid}/
    /// - UserWriteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Write Stage. 
    /// - parameter patchedUserWriteStageRequest: (body)  (optional)
    /// - returns: AnyPublisher<UserWriteStage, Error> 
    open func stagesUserWritePartialUpdate(stageUuid: UUID, patchedUserWriteStageRequest: PatchedUserWriteStageRequest? = nil) -> AnyPublisher<UserWriteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_write/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedUserWriteStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserWriteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWritePartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWritePartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserWriteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserWriteRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWriteRetrieveError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWriteRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_write/{stage_uuid}/
    /// - UserWriteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Write Stage. 
    /// - returns: AnyPublisher<UserWriteStage, Error> 
    open func stagesUserWriteRetrieve(stageUuid: UUID) -> AnyPublisher<UserWriteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_write/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserWriteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWriteRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWriteRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserWriteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserWriteUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWriteUpdateError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWriteUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /stages/user_write/{stage_uuid}/
    /// - UserWriteStage Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Write Stage. 
    /// - parameter userWriteStageRequest: (body)  
    /// - returns: AnyPublisher<UserWriteStage, Error> 
    open func stagesUserWriteUpdate(stageUuid: UUID, userWriteStageRequest: UserWriteStageRequest) -> AnyPublisher<UserWriteStage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_write/{stage_uuid}/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(userWriteStageRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserWriteStage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWriteUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWriteUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(UserWriteStage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum StagesUserWriteUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "StagesUserWriteUsedByListError: : \(object)"
            case .code403Error(let object):
                return "StagesUserWriteUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /stages/user_write/{stage_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter stageUuid: (path) A UUID string identifying this User Write Stage. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func stagesUserWriteUsedByList(stageUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/stages/user_write/{stage_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{stage_uuid}", with: stageUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return StagesUserWriteUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return StagesUserWriteUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
