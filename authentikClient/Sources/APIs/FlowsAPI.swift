//
// FlowsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class FlowsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost/api/v3")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum FlowsBindingsCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsCreateError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsCreateError: : \(object)"
            }
        }
    }

    /// - POST /flows/bindings/
    /// - FlowStageBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter flowStageBindingRequest: (body)  
    /// - returns: AnyPublisher<FlowStageBinding, Error> 
    open func flowsBindingsCreate(flowStageBindingRequest: FlowStageBindingRequest) -> AnyPublisher<FlowStageBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/bindings/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(flowStageBindingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowStageBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowStageBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsBindingsDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsDestroyError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /flows/bindings/{fsb_uuid}/
    /// - FlowStageBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fsbUuid: (path) A UUID string identifying this Flow Stage Binding. 
    /// - returns: AnyPublisher<Void, Error> 
    open func flowsBindingsDestroy(fsbUuid: UUID) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/bindings/{fsb_uuid}/"
                path = path.replacingOccurrences(of: "{fsb_uuid}", with: fsbUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter invalidResponseAction
    ///
    public enum FlowsBindingsListInvalidResponseAction: String, Codable, CaseIterable {
        case restart = "restart"
        case restartWithContext = "restart_with_context"
        case retry = "retry"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter policyEngineMode
    ///
    public enum FlowsBindingsListPolicyEngineMode: String, Codable, CaseIterable {
        case all = "all"
        case any = "any"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum FlowsBindingsListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsListError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsListError: : \(object)"
            }
        }
    }

    /// - GET /flows/bindings/
    /// - FlowStageBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter evaluateOnPlan: (query)  (optional)
    /// - parameter fsbUuid: (query)  (optional)
    /// - parameter invalidResponseAction: (query) Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * &#x60;retry&#x60; - Retry * &#x60;restart&#x60; - Restart * &#x60;restart_with_context&#x60; - Restart With Context (optional)
    /// - parameter order: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter pbmUuid: (query)  (optional)
    /// - parameter policies: (query)  (optional)
    /// - parameter policyEngineMode: (query) * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
    /// - parameter reEvaluatePolicies: (query)  (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter stage: (query)  (optional)
    /// - parameter target: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedFlowStageBindingList, Error> 
    open func flowsBindingsList(evaluateOnPlan: Bool? = nil, fsbUuid: UUID? = nil, invalidResponseAction: FlowsBindingsListInvalidResponseAction? = nil, order: Int? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, pbmUuid: UUID? = nil, policies: [UUID]? = nil, policyEngineMode: FlowsBindingsListPolicyEngineMode? = nil, reEvaluatePolicies: Bool? = nil, search: String? = nil, stage: UUID? = nil, target: UUID? = nil) -> AnyPublisher<PaginatedFlowStageBindingList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/bindings/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let evaluateOnPlan = evaluateOnPlan { queryItems.append(URLQueryItem(name: "evaluate_on_plan", value: evaluateOnPlan ? "true" : "false")) } 
                if let fsbUuid = fsbUuid { queryItems.append(URLQueryItem(name: "fsb_uuid", value: fsbUuid.uuidString)) } 
                if let invalidResponseAction = invalidResponseAction { queryItems.append(URLQueryItem(name: "invalid_response_action", value: invalidResponseAction.rawValue)) } 
                if let order = order { queryItems.append(URLQueryItem(name: "order", value: "\(order)")) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let pbmUuid = pbmUuid { queryItems.append(URLQueryItem(name: "pbm_uuid", value: pbmUuid.uuidString)) } 
                if let policies = policies { queryItems.append(URLQueryItem(name: "policies", value: policies.map { $0.uuidString }.joined(separator: ","))) } 
                if let policyEngineMode = policyEngineMode { queryItems.append(URLQueryItem(name: "policy_engine_mode", value: policyEngineMode.rawValue)) } 
                if let reEvaluatePolicies = reEvaluatePolicies { queryItems.append(URLQueryItem(name: "re_evaluate_policies", value: reEvaluatePolicies ? "true" : "false")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let stage = stage { queryItems.append(URLQueryItem(name: "stage", value: stage.uuidString)) } 
                if let target = target { queryItems.append(URLQueryItem(name: "target", value: target.uuidString)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedFlowStageBindingList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedFlowStageBindingList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsBindingsPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /flows/bindings/{fsb_uuid}/
    /// - FlowStageBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fsbUuid: (path) A UUID string identifying this Flow Stage Binding. 
    /// - parameter patchedFlowStageBindingRequest: (body)  (optional)
    /// - returns: AnyPublisher<FlowStageBinding, Error> 
    open func flowsBindingsPartialUpdate(fsbUuid: UUID, patchedFlowStageBindingRequest: PatchedFlowStageBindingRequest? = nil) -> AnyPublisher<FlowStageBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/bindings/{fsb_uuid}/"
                path = path.replacingOccurrences(of: "{fsb_uuid}", with: fsbUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedFlowStageBindingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowStageBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowStageBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsBindingsRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsRetrieveError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /flows/bindings/{fsb_uuid}/
    /// - FlowStageBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fsbUuid: (path) A UUID string identifying this Flow Stage Binding. 
    /// - returns: AnyPublisher<FlowStageBinding, Error> 
    open func flowsBindingsRetrieve(fsbUuid: UUID) -> AnyPublisher<FlowStageBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/bindings/{fsb_uuid}/"
                path = path.replacingOccurrences(of: "{fsb_uuid}", with: fsbUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowStageBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowStageBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsBindingsUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsUpdateError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /flows/bindings/{fsb_uuid}/
    /// - FlowStageBinding Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fsbUuid: (path) A UUID string identifying this Flow Stage Binding. 
    /// - parameter flowStageBindingRequest: (body)  
    /// - returns: AnyPublisher<FlowStageBinding, Error> 
    open func flowsBindingsUpdate(fsbUuid: UUID, flowStageBindingRequest: FlowStageBindingRequest) -> AnyPublisher<FlowStageBinding, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/bindings/{fsb_uuid}/"
                path = path.replacingOccurrences(of: "{fsb_uuid}", with: fsbUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(flowStageBindingRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowStageBinding, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowStageBinding.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsBindingsUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsBindingsUsedByListError: : \(object)"
            case .code403Error(let object):
                return "FlowsBindingsUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /flows/bindings/{fsb_uuid}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter fsbUuid: (path) A UUID string identifying this Flow Stage Binding. 
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func flowsBindingsUsedByList(fsbUuid: UUID) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/bindings/{fsb_uuid}/used_by/"
                path = path.replacingOccurrences(of: "{fsb_uuid}", with: fsbUuid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsBindingsUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsBindingsUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsExecutorGetError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsExecutorGetError: : \(object)"
            case .code403Error(let object):
                return "FlowsExecutorGetError: : \(object)"
            }
        }
    }

    /// - GET /flows/executor/{flow_slug}/
    /// - Get the next pending challenge from the currently active flow.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter flowSlug: (path)  
    /// - parameter query: (query) Querystring as received 
    /// - returns: AnyPublisher<ChallengeTypes, Error> 
    open func flowsExecutorGet(flowSlug: String, query: String) -> AnyPublisher<ChallengeTypes, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/executor/{flow_slug}/"
                path = path.replacingOccurrences(of: "{flow_slug}", with: flowSlug)
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "query", value: query))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ChallengeTypes, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsExecutorGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsExecutorGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ChallengeTypes.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsExecutorSolveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsExecutorSolveError: : \(object)"
            case .code403Error(let object):
                return "FlowsExecutorSolveError: : \(object)"
            }
        }
    }

    /// - POST /flows/executor/{flow_slug}/
    /// - Solve the previously retrieved challenge and advanced to the next stage.
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter flowSlug: (path)  
    /// - parameter query: (query) Querystring as received 
    /// - parameter flowChallengeResponseRequest: (body)  (optional)
    /// - returns: AnyPublisher<ChallengeTypes, Error> 
    open func flowsExecutorSolve(flowSlug: String, query: String, flowChallengeResponseRequest: FlowChallengeResponseRequest? = nil) -> AnyPublisher<ChallengeTypes, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/executor/{flow_slug}/"
                path = path.replacingOccurrences(of: "{flow_slug}", with: flowSlug)
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "query", value: query))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(flowChallengeResponseRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ChallengeTypes, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsExecutorSolveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsExecutorSolveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ChallengeTypes.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInspectorGetError: Error, CustomStringConvertible {
        // No flow plan in session.
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "FlowsInspectorGetError: No flow plan in session."
            case .code403Error(let object):
                return "FlowsInspectorGetError: : \(object)"
            }
        }
    }

    /// - GET /flows/inspector/{flow_slug}/
    /// - Get current flow state and record it
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter flowSlug: (path)  
    /// - returns: AnyPublisher<FlowInspection, Error> 
    open func flowsInspectorGet(flowSlug: String) -> AnyPublisher<FlowInspection, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/inspector/{flow_slug}/"
                path = path.replacingOccurrences(of: "{flow_slug}", with: flowSlug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowInspection, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return FlowsInspectorGetError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInspectorGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowInspection.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesCacheClearCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "FlowsInstancesCacheClearCreateError: Bad request"
            case .code403Error(let object):
                return "FlowsInstancesCacheClearCreateError: : \(object)"
            }
        }
    }

    /// - POST /flows/instances/cache_clear/
    /// - Clear flow cache
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<Void, Error> 
    open func flowsInstancesCacheClearCreate() -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/instances/cache_clear/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return FlowsInstancesCacheClearCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesCacheClearCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesCacheInfoRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesCacheInfoRetrieveError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesCacheInfoRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/cache_info/
    /// - Info about cached flows
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - returns: AnyPublisher<Cache, Error> 
    open func flowsInstancesCacheInfoRetrieve() -> AnyPublisher<Cache, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/instances/cache_info/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Cache, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesCacheInfoRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesCacheInfoRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Cache.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesCreateError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesCreateError: : \(object)"
            }
        }
    }

    /// - POST /flows/instances/
    /// - Flow Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter flowRequest: (body)  
    /// - returns: AnyPublisher<Flow, Error> 
    open func flowsInstancesCreate(flowRequest: FlowRequest) -> AnyPublisher<Flow, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/instances/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(flowRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Flow, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Flow.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesDestroyError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesDestroyError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesDestroyError: : \(object)"
            }
        }
    }

    /// - DELETE /flows/instances/{slug}/
    /// - Flow Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Void, Error> 
    open func flowsInstancesDestroy(slug: String) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesDestroyError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesDestroyError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesDiagramRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesDiagramRetrieveError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesDiagramRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/{slug}/diagram/
    /// - Return diagram for flow with slug `slug`, in the format used by flowchart.js
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<FlowDiagram, Error> 
    open func flowsInstancesDiagramRetrieve(slug: String) -> AnyPublisher<FlowDiagram, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/diagram/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowDiagram, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesDiagramRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesDiagramRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowDiagram.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesExecuteRetrieveError: Error, CustomStringConvertible {
        // Flow not applicable
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "FlowsInstancesExecuteRetrieveError: Flow not applicable"
            case .code403Error(let object):
                return "FlowsInstancesExecuteRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/{slug}/execute/
    /// - Execute flow for current user
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Link, Error> 
    open func flowsInstancesExecuteRetrieve(slug: String) -> AnyPublisher<Link, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/execute/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Link, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return FlowsInstancesExecuteRetrieveError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesExecuteRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Link.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesExportRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesExportRetrieveError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesExportRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/{slug}/export/
    /// - Export flow to .yaml file
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Data, Error> 
    open func flowsInstancesExportRetrieve(slug: String) -> AnyPublisher<Data, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/export/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Data, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesExportRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesExportRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Data.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesImportCreateError: Error, CustomStringConvertible {
        // 
        case code400Error(FlowImportResult)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesImportCreateError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesImportCreateError: : \(object)"
            }
        }
    }

    /// - POST /flows/instances/import/
    /// - Import flow from .yaml file
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter file: (form)  (optional)
    /// - parameter clear: (form)  (optional, default to false)
    /// - returns: AnyPublisher<FlowImportResult, Error> 
    open func flowsInstancesImportCreate(file: Data? = nil, clear: Bool? = nil) -> AnyPublisher<FlowImportResult, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/instances/import/"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                let multipartBoundary = String(format: "Boundary+%08X%08X", arc4random(), arc4random())
                var multipartData = Data()
				if let file = file {
					let fileHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"file\"; filename=\"file\"\r\n")
					    .appending("\r\n")
					multipartData.append(fileHeader.data(using: .utf8) ?? Data())
					multipartData.append(file)
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let clear = clear {
					let clearHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"clear\"\r\n")
					    .appending("\r\n")
					multipartData.append(clearHeader.data(using: .utf8) ?? Data())
					multipartData.append()
				}

                multipartData.append("\r\n--\(multipartBoundary)--\r\n".data(using: .utf8) ?? Data())
                request.httpBody = multipartData
                request.setValue("\(multipartData.count)", forHTTPHeaderField: "Content-Length")
                request.setValue("multipart/form-data; boundary=\(multipartBoundary)", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FlowImportResult, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(FlowImportResult.self, from: transportError.data)
                            return FlowsInstancesImportCreateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesImportCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(FlowImportResult.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter deniedAction
    ///
    public enum FlowsInstancesListDeniedAction: String, Codable, CaseIterable {
        case _continue = "continue"
        case message = "message"
        case messageContinue = "message_continue"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    ///
    /// Enum for parameter designation
    ///
    public enum FlowsInstancesListDesignation: String, Codable, CaseIterable {
        case authentication = "authentication"
        case authorization = "authorization"
        case enrollment = "enrollment"
        case invalidation = "invalidation"
        case recovery = "recovery"
        case stageConfiguration = "stage_configuration"
        case unenrollment = "unenrollment"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum FlowsInstancesListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesListError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesListError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/
    /// - Flow Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter deniedAction: (query) Configure what should happen when a flow denies access to a user.  * &#x60;message_continue&#x60; - Message Continue * &#x60;message&#x60; - Message * &#x60;continue&#x60; - Continue (optional)
    /// - parameter designation: (query) Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * &#x60;authentication&#x60; - Authentication * &#x60;authorization&#x60; - Authorization * &#x60;invalidation&#x60; - Invalidation * &#x60;enrollment&#x60; - Enrollment * &#x60;unenrollment&#x60; - Unrenollment * &#x60;recovery&#x60; - Recovery * &#x60;stage_configuration&#x60; - Stage Configuration (optional)
    /// - parameter flowUuid: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter ordering: (query) Which field to use when ordering the results. (optional)
    /// - parameter page: (query) A page number within the paginated result set. (optional)
    /// - parameter pageSize: (query) Number of results to return per page. (optional)
    /// - parameter search: (query) A search term. (optional)
    /// - parameter slug: (query)  (optional)
    /// - returns: AnyPublisher<PaginatedFlowList, Error> 
    open func flowsInstancesList(deniedAction: FlowsInstancesListDeniedAction? = nil, designation: FlowsInstancesListDesignation? = nil, flowUuid: UUID? = nil, name: String? = nil, ordering: String? = nil, page: Int? = nil, pageSize: Int? = nil, search: String? = nil, slug: String? = nil) -> AnyPublisher<PaginatedFlowList, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/flows/instances/"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deniedAction = deniedAction { queryItems.append(URLQueryItem(name: "denied_action", value: deniedAction.rawValue)) } 
                if let designation = designation { queryItems.append(URLQueryItem(name: "designation", value: designation.rawValue)) } 
                if let flowUuid = flowUuid { queryItems.append(URLQueryItem(name: "flow_uuid", value: flowUuid.uuidString)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let ordering = ordering { queryItems.append(URLQueryItem(name: "ordering", value: ordering)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)")) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let slug = slug { queryItems.append(URLQueryItem(name: "slug", value: slug)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaginatedFlowList, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(PaginatedFlowList.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesPartialUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesPartialUpdateError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesPartialUpdateError: : \(object)"
            }
        }
    }

    /// - PATCH /flows/instances/{slug}/
    /// - Flow Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter patchedFlowRequest: (body)  (optional)
    /// - returns: AnyPublisher<Flow, Error> 
    open func flowsInstancesPartialUpdate(slug: String, patchedFlowRequest: PatchedFlowRequest? = nil) -> AnyPublisher<Flow, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(patchedFlowRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Flow, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesPartialUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesPartialUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Flow.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesRetrieveError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesRetrieveError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesRetrieveError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/{slug}/
    /// - Flow Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<Flow, Error> 
    open func flowsInstancesRetrieve(slug: String) -> AnyPublisher<Flow, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Flow, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesRetrieveError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesRetrieveError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Flow.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesSetBackgroundCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "FlowsInstancesSetBackgroundCreateError: Bad request"
            case .code403Error(let object):
                return "FlowsInstancesSetBackgroundCreateError: : \(object)"
            }
        }
    }

    /// - POST /flows/instances/{slug}/set_background/
    /// - Set Flow background
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter file: (form)  (optional)
    /// - parameter clear: (form)  (optional, default to false)
    /// - returns: AnyPublisher<Void, Error> 
    open func flowsInstancesSetBackgroundCreate(slug: String, file: Data? = nil, clear: Bool? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/set_background/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                let multipartBoundary = String(format: "Boundary+%08X%08X", arc4random(), arc4random())
                var multipartData = Data()
				if let file = file {
					let fileHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"file\"; filename=\"file\"\r\n")
					    .appending("\r\n")
					multipartData.append(fileHeader.data(using: .utf8) ?? Data())
					multipartData.append(file)
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let clear = clear {
					let clearHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"clear\"\r\n")
					    .appending("\r\n")
					multipartData.append(clearHeader.data(using: .utf8) ?? Data())
					multipartData.append()
				}

                multipartData.append("\r\n--\(multipartBoundary)--\r\n".data(using: .utf8) ?? Data())
                request.httpBody = multipartData
                request.setValue("\(multipartData.count)", forHTTPHeaderField: "Content-Length")
                request.setValue("multipart/form-data; boundary=\(multipartBoundary)", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return FlowsInstancesSetBackgroundCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesSetBackgroundCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesSetBackgroundUrlCreateError: Error, CustomStringConvertible {
        // Bad request
        case code400Error
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error:
                return "FlowsInstancesSetBackgroundUrlCreateError: Bad request"
            case .code403Error(let object):
                return "FlowsInstancesSetBackgroundUrlCreateError: : \(object)"
            }
        }
    }

    /// - POST /flows/instances/{slug}/set_background_url/
    /// - Set Flow background (as URL)
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter filePathRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func flowsInstancesSetBackgroundUrlCreate(slug: String, filePathRequest: FilePathRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/set_background_url/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(filePathRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return FlowsInstancesSetBackgroundUrlCreateError.code400Error
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesSetBackgroundUrlCreateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesUpdateError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesUpdateError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesUpdateError: : \(object)"
            }
        }
    }

    /// - PUT /flows/instances/{slug}/
    /// - Flow Viewset
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - parameter flowRequest: (body)  
    /// - returns: AnyPublisher<Flow, Error> 
    open func flowsInstancesUpdate(slug: String, flowRequest: FlowRequest) -> AnyPublisher<Flow, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(flowRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Flow, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesUpdateError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesUpdateError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(Flow.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum FlowsInstancesUsedByListError: Error, CustomStringConvertible {
        // 
        case code400Error(ValidationError)
        // 
        case code403Error(GenericError)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "FlowsInstancesUsedByListError: : \(object)"
            case .code403Error(let object):
                return "FlowsInstancesUsedByListError: : \(object)"
            }
        }
    }

    /// - GET /flows/instances/{slug}/used_by/
    /// - Get a list of all objects that use this object
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: authentik
    /// - parameter slug: (path)  
    /// - returns: AnyPublisher<[UsedBy], Error> 
    open func flowsInstancesUsedByList(slug: String) -> AnyPublisher<[UsedBy], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/flows/instances/{slug}/used_by/"
                path = path.replacingOccurrences(of: "{slug}", with: slug)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UsedBy], Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ValidationError.self, from: transportError.data)
                            return FlowsInstancesUsedByListError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(GenericError.self, from: transportError.data)
                            return FlowsInstancesUsedByListError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode([UsedBy].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
