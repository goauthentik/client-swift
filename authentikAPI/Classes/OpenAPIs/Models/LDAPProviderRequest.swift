//
// LDAPProviderRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** LDAPProvider Serializer */
public struct LDAPProviderRequest: Codable, JSONEncodable, Hashable {

    public var name: String
    /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
    public var authenticationFlow: UUID?
    /** Flow used when authorizing this provider. */
    public var authorizationFlow: UUID
    public var propertyMappings: [UUID]?
    /** DN under which objects are accessible. */
    public var baseDn: String?
    /** Users in this group can do search queries. If not set, every user can execute search queries. */
    public var searchGroup: UUID?
    public var certificate: UUID?
    public var tlsServerName: String?
    /** The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
    public var uidStartNumber: Int?
    /** The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
    public var gidStartNumber: Int?
    public var searchMode: LDAPAPIAccessMode?
    public var bindMode: LDAPAPIAccessMode?
    /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
    public var mfaSupport: Bool?

    public init(name: String, authenticationFlow: UUID? = nil, authorizationFlow: UUID, propertyMappings: [UUID]? = nil, baseDn: String? = nil, searchGroup: UUID? = nil, certificate: UUID? = nil, tlsServerName: String? = nil, uidStartNumber: Int? = nil, gidStartNumber: Int? = nil, searchMode: LDAPAPIAccessMode? = nil, bindMode: LDAPAPIAccessMode? = nil, mfaSupport: Bool? = nil) {
        self.name = name
        self.authenticationFlow = authenticationFlow
        self.authorizationFlow = authorizationFlow
        self.propertyMappings = propertyMappings
        self.baseDn = baseDn
        self.searchGroup = searchGroup
        self.certificate = certificate
        self.tlsServerName = tlsServerName
        self.uidStartNumber = uidStartNumber
        self.gidStartNumber = gidStartNumber
        self.searchMode = searchMode
        self.bindMode = bindMode
        self.mfaSupport = mfaSupport
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case authenticationFlow = "authentication_flow"
        case authorizationFlow = "authorization_flow"
        case propertyMappings = "property_mappings"
        case baseDn = "base_dn"
        case searchGroup = "search_group"
        case certificate
        case tlsServerName = "tls_server_name"
        case uidStartNumber = "uid_start_number"
        case gidStartNumber = "gid_start_number"
        case searchMode = "search_mode"
        case bindMode = "bind_mode"
        case mfaSupport = "mfa_support"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encode(authorizationFlow, forKey: .authorizationFlow)
        try container.encodeIfPresent(propertyMappings, forKey: .propertyMappings)
        try container.encodeIfPresent(baseDn, forKey: .baseDn)
        try container.encodeIfPresent(searchGroup, forKey: .searchGroup)
        try container.encodeIfPresent(certificate, forKey: .certificate)
        try container.encodeIfPresent(tlsServerName, forKey: .tlsServerName)
        try container.encodeIfPresent(uidStartNumber, forKey: .uidStartNumber)
        try container.encodeIfPresent(gidStartNumber, forKey: .gidStartNumber)
        try container.encodeIfPresent(searchMode, forKey: .searchMode)
        try container.encodeIfPresent(bindMode, forKey: .bindMode)
        try container.encodeIfPresent(mfaSupport, forKey: .mfaSupport)
    }
}

