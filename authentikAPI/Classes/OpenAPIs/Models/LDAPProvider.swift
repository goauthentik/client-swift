//
// LDAPProvider.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** LDAPProvider Serializer */
public struct LDAPProvider: Codable, JSONEncodable, Hashable {

    public var pk: Int
    public var name: String
    /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
    public var authenticationFlow: UUID?
    /** Flow used when authorizing this provider. */
    public var authorizationFlow: UUID
    public var propertyMappings: [UUID]?
    /** Get object component so that we know how to edit the object */
    public var component: String
    /** Internal application name, used in URLs. */
    public var assignedApplicationSlug: String
    /** Application's display Name. */
    public var assignedApplicationName: String
    /** Internal application name, used in URLs. */
    public var assignedBackchannelApplicationSlug: String
    /** Application's display Name. */
    public var assignedBackchannelApplicationName: String
    /** Return object's verbose_name */
    public var verboseName: String
    /** Return object's plural verbose_name */
    public var verboseNamePlural: String
    /** Return internal model name */
    public var metaModelName: String
    /** DN under which objects are accessible. */
    public var baseDn: String?
    /** Users in this group can do search queries. If not set, every user can execute search queries. */
    public var searchGroup: UUID?
    public var certificate: UUID?
    public var tlsServerName: String?
    /** The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
    public var uidStartNumber: Int?
    /** The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
    public var gidStartNumber: Int?
    public var outpostSet: [String]
    public var searchMode: LDAPAPIAccessMode?
    public var bindMode: LDAPAPIAccessMode?
    /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
    public var mfaSupport: Bool?

    public init(pk: Int, name: String, authenticationFlow: UUID? = nil, authorizationFlow: UUID, propertyMappings: [UUID]? = nil, component: String, assignedApplicationSlug: String, assignedApplicationName: String, assignedBackchannelApplicationSlug: String, assignedBackchannelApplicationName: String, verboseName: String, verboseNamePlural: String, metaModelName: String, baseDn: String? = nil, searchGroup: UUID? = nil, certificate: UUID? = nil, tlsServerName: String? = nil, uidStartNumber: Int? = nil, gidStartNumber: Int? = nil, outpostSet: [String], searchMode: LDAPAPIAccessMode? = nil, bindMode: LDAPAPIAccessMode? = nil, mfaSupport: Bool? = nil) {
        self.pk = pk
        self.name = name
        self.authenticationFlow = authenticationFlow
        self.authorizationFlow = authorizationFlow
        self.propertyMappings = propertyMappings
        self.component = component
        self.assignedApplicationSlug = assignedApplicationSlug
        self.assignedApplicationName = assignedApplicationName
        self.assignedBackchannelApplicationSlug = assignedBackchannelApplicationSlug
        self.assignedBackchannelApplicationName = assignedBackchannelApplicationName
        self.verboseName = verboseName
        self.verboseNamePlural = verboseNamePlural
        self.metaModelName = metaModelName
        self.baseDn = baseDn
        self.searchGroup = searchGroup
        self.certificate = certificate
        self.tlsServerName = tlsServerName
        self.uidStartNumber = uidStartNumber
        self.gidStartNumber = gidStartNumber
        self.outpostSet = outpostSet
        self.searchMode = searchMode
        self.bindMode = bindMode
        self.mfaSupport = mfaSupport
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pk
        case name
        case authenticationFlow = "authentication_flow"
        case authorizationFlow = "authorization_flow"
        case propertyMappings = "property_mappings"
        case component
        case assignedApplicationSlug = "assigned_application_slug"
        case assignedApplicationName = "assigned_application_name"
        case assignedBackchannelApplicationSlug = "assigned_backchannel_application_slug"
        case assignedBackchannelApplicationName = "assigned_backchannel_application_name"
        case verboseName = "verbose_name"
        case verboseNamePlural = "verbose_name_plural"
        case metaModelName = "meta_model_name"
        case baseDn = "base_dn"
        case searchGroup = "search_group"
        case certificate
        case tlsServerName = "tls_server_name"
        case uidStartNumber = "uid_start_number"
        case gidStartNumber = "gid_start_number"
        case outpostSet = "outpost_set"
        case searchMode = "search_mode"
        case bindMode = "bind_mode"
        case mfaSupport = "mfa_support"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pk, forKey: .pk)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(authenticationFlow, forKey: .authenticationFlow)
        try container.encode(authorizationFlow, forKey: .authorizationFlow)
        try container.encodeIfPresent(propertyMappings, forKey: .propertyMappings)
        try container.encode(component, forKey: .component)
        try container.encode(assignedApplicationSlug, forKey: .assignedApplicationSlug)
        try container.encode(assignedApplicationName, forKey: .assignedApplicationName)
        try container.encode(assignedBackchannelApplicationSlug, forKey: .assignedBackchannelApplicationSlug)
        try container.encode(assignedBackchannelApplicationName, forKey: .assignedBackchannelApplicationName)
        try container.encode(verboseName, forKey: .verboseName)
        try container.encode(verboseNamePlural, forKey: .verboseNamePlural)
        try container.encode(metaModelName, forKey: .metaModelName)
        try container.encodeIfPresent(baseDn, forKey: .baseDn)
        try container.encodeIfPresent(searchGroup, forKey: .searchGroup)
        try container.encodeIfPresent(certificate, forKey: .certificate)
        try container.encodeIfPresent(tlsServerName, forKey: .tlsServerName)
        try container.encodeIfPresent(uidStartNumber, forKey: .uidStartNumber)
        try container.encodeIfPresent(gidStartNumber, forKey: .gidStartNumber)
        try container.encode(outpostSet, forKey: .outpostSet)
        try container.encodeIfPresent(searchMode, forKey: .searchMode)
        try container.encodeIfPresent(bindMode, forKey: .bindMode)
        try container.encodeIfPresent(mfaSupport, forKey: .mfaSupport)
    }
}

